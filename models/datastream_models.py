#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Jul 27 18:48:26 2025 by generateDS.py version 2.44.3.
# Python 3.13.5 (tags/v3.13.5:6cb20a2, Jun 11 2025, 16:15:46) [MSC v.1943 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'datastream_models.py')
#
# Command line arguments:
#   .\scap-source-data-stream_1.3.xsd
#
# Command line:
#   C:\Program Files\Python313\Scripts\generateDS -o "datastream_models.py" .\scap-source-data-stream_1.3.xsd
#
# Current working directory (os.getcwd()):
#   schema
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_
from . import cpe_dictionary_models
from . import oval_core_models as oval_models
from .xccdf_models import Benchmark, tailoringType

Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile('(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'{.*}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class ArithmeticEnumeration(str, Enum):
    """ArithmeticEnumeration -- The ArithmeticEnumeration simple type defines basic arithmetic operations.  Currently add and multiply are defined.
    
    """
    ADD='add'
    MULTIPLY='multiply'


class BooleanQuestionModelType(str, Enum):
    """BooleanQuestionModelType -- The BooleanQuestionModelType type provides the acceptable
    models (i.e. set of acceptable responses) for a
    boolean_question.
    
    """
    MODEL_YES_NO='MODEL_YES_NO' # MODEL_YES_NO represents a response set of {YES, NO}.
    MODEL_TRUE_FALSE='MODEL_TRUE_FALSE' # MODEL_TRUE_FALSE represents a response set of {TRUE, FALSE}.


class CheckEnumeration(str, Enum):
    """CheckEnumeration -- The CheckEnumeration simple type defines acceptable check values, which are used to determine the final result of something based on the results of individual components. When used to define the relationship between objects and states, each check value defines how many of the matching objects (items except those with a status of does not exist) must satisfy the given state for the test to return true. When used to define the relationship between instances of a given entity, the different check values defines how many instances must be true for the entity to return true. When used to define the relationship between entities and multiple variable values, each check value defines how many variable values must be true for the entity to return true.
    
    """
    ALL='all' # A value of 'all' means that a final result of true is given if all the individual results under consideration are true.
    ATLEASTONE='at least one' # A value of 'at least one' means that a final result of true is given if at least one of the individual results under consideration is true.
    NONEEXIST='none exist' # A value of 'none exists' means that a test evaluates to true if no matching object exists that satisfy the data requirements.
    NONESATISFY='none satisfy' # A value of 'none satisfy' means that a final result of true is given if none the individual results under consideration are true.
    ONLYONE='only one' # A value of 'only one' means that a final result of true is given if one and only one of the individual results under consideration are true.


class ClassEnumeration(str, Enum):
    """ClassEnumeration -- The ClassEnumeration simple type defines the different classes of definitions. Each class defines a certain intent regarding how an OVAL Definition is written and what that definition is describing. The specified class gives a hint about the definition so a user can know what the definition writer is trying to say. Note that the class does not make a statement about whether a true result is good or bad as this depends on the use of an OVAL Definition. These classes are also used to group definitions by the type of system state they are describing. For example, this allows users to find all the vulnerability (or patch, or inventory, etc) definitions.
    
    """
    COMPLIANCE='compliance' # A compliance definition describes the state of a machine as it complies with a specific policy. A definition of this class will evaluate to true when the system is found to be compliant with the stated policy. Another way of thinking about this is that a compliance definition is stating "the system is compliant if ...".
    INVENTORY='inventory' # An inventory definition describes whether a specific piece of software is installed on the system. A definition of this class will evaluate to true when the specified software is found on the system. Another way of thinking about this is that an inventory definition is stating "the software is installed if ...".
    MISCELLANEOUS='miscellaneous' # The 'miscellaneous' class is used to identify definitions that do not fall into any of the other defined classes.
    PATCH='patch' # A patch definition details the machine state of whether a patch executable should be installed. A definition of this class will evaluate to true when the specified patch is missing from the system. Another way of thinking about this is that a patch definition is stating "the patch should be installed if ...". Note that word SHOULD is intended to mean more than just CAN the patch executable be installed. In other words, if a more recent patch is already installed then the specified patch might not need to be installed.
    VULNERABILITY='vulnerability' # A vulnerability definition describes the conditions under which a machine is vulnerable. A definition of this class will evaluate to true when the system is found to be vulnerable with the stated issue. Another way of thinking about this is that a vulnerability definition is stating "the system is vulnerable if ...".


class ComplexDatatypeEnumeration(str, Enum):
    """ComplexDatatypeEnumeration -- The ComplexDatatypeEnumeration simple type defines the complex legal datatypes that are supported in OVAL. These datatype describe the values of individual entities where the entity has some complex structure beyond simple string like content.
    
    """
    RECORD='record' # The record datatype describes an entity with structured set of named fields and values as its content. The only allowed operation within OVAL for record values is 'equals'. Note that the record datatype is not currently allowed when using variables.


class DateTimeFormatEnumeration(str, Enum):
    """DateTimeFormatEnumeration -- The DateTimeFormatEnumeration simple type defines the different date-time formats that are understood by OVAL. Note that in some cases there are a few different possibilities within a given format. Each of these possibilities is unique though and can be distinguished from each other. The different formats are used to clarify the higher level structure of the date-time string being used.
    
    """
    YEAR_MONTH_DAY='year_month_day' # The year_month_day value specifies date-time strings that follow the formats: 'yyyymmdd', 'yyyymmddThhmmss', 'yyyy/mm/dd hh:mm:ss', 'yyyy/mm/dd', 'yyyy-mm-dd hh:mm:ss', or 'yyyy-mm-dd'
    MONTH_DAY_YEAR='month_day_year' # The month_day_year value specifies date-time strings that follow the formats: 'mm/dd/yyyy hh:mm:ss', 'mm/dd/yyyy', 'mm-dd-yyyy hh:mm:ss', 'mm-dd-yyyy', 'NameOfMonth, dd yyyy hh:mm:ss' or 'NameOfMonth, dd yyyy', 'AbreviatedNameOfMonth, dd yyyy hh:mm:ss', or 'AbreviatedNameOfMonth, dd yyyy'
    DAY_MONTH_YEAR='day_month_year' # The day_month_year value specifies date-time strings that follow the formats: 'dd/mm/yyyy hh:mm:ss', 'dd/mm/yyyy', 'dd-mm-yyyy hh:mm:ss', or 'dd-mm-yyyy'
    WIN_FILETIME='win_filetime' # The win_filetime value specifies date-time strings that follow the windows file time format.
    SECONDS_SINCE_EPOCH='seconds_since_epoch' # The seconds_since_epoch value specifies date-time values that represent the time in seconds since the UNIX epoch. The Unix epoch is the time 00:00:00 UTC on January 1, 1970.
    CIM_DATETIME='cim_datetime' # The cim_datetime model is used by WMI and its value specifies date-time strings that follow the format: 'yyyymmddHHMMSS.mmmmmmsUUU', and alternatively 'yyyy-mm-dd HH:MM:SS:mmm' only when used in WMI Query Language queries.


class ExceptionalResultType(str, Enum):
    """ExceptionalResultType -- The ExceptionalResultType type defines possible
    exceptional results of a question.
    
    """
    UNKNOWN='UNKNOWN' # An UNKNOWN value indicates that the result of a test cannot be determined.
    ERROR='ERROR' # An ERROR value indicates that an error occured while processing the check. Among other causes, this can indicate an unexpected response.
    NOT_TESTED='NOT_TESTED' # A NOT_TESTED value indicates that the check has not been tested yet.
    NOT_APPLICABLE='NOT_APPLICABLE' # A NOT_APPLICABLE value indicates that the check is not relevant and can be skipped.


class ExistenceEnumeration(str, Enum):
    """ExistenceEnumeration -- The ExistenceEnumeration simple type defines acceptable existence values, which are used to determine a result based on the existence of individual components. The main use for this is for a test regarding the existence of objects on the system. Its secondary use is for a state regarding the existence of entities in corresponding items.
    
    """
    ALL_EXIST='all_exist' # When used in the context of an OVAL state entity's check_existence attribute, a value of 'all_exist' means that every item entity for an object defined by the description exists on the system. When used in the context of an OVAL test's check_existence attribute, this value is equivalent to 'at_least_one_exists' because non-existent items have no impact upon evaluation.
    ANY_EXIST='any_exist' # A value of 'any_exist' means that zero or more objects defined by the description exist on the system.
    AT_LEAST_ONE_EXISTS='at_least_one_exists' # A value of 'at_least_one_exists' means that at least one object defined by the description exists on the system.
    NONE_EXIST='none_exist' # A value of 'none_exist' means that none of the objects defined by the description exist on the system.
    ONLY_ONE_EXISTS='only_one_exists' # A value of 'only_one_exists' means that only one object defined by the description exists on the system.


class FamilyEnumeration(str, Enum):
    """FamilyEnumeration -- The FamilyEnumeration simple type is a listing of families that OVAL supports at this time.  Since new family values can only be added with new version of the schema, the value of 'undefined' is to be used when the desired family is not available.  Note that use of the undefined family value does not target all families, rather it means that some family other than one of the defined values is targeted.
    
    """
    ANDROID='android' # The android value describes the Android mobile operating system.
    ASA='asa' # The asa value describes the Cisco ASA security devices.
    APPLE_IOS='apple_ios' # The apple_ios value describes the iOS mobile operating system.
    CATOS='catos' # The catos value describes the Cisco CatOS operating system.
    IOS='ios' # The ios value describes the Cisco IOS operating system.
    IOSXE='iosxe' # The iosxe value describes the Cisco IOS XE operating system.
    JUNOS='junos' # The junos value describes the Juniper JunOS operating system.
    MACOS='macos' # The macos value describes the Mac operating system.
    PIXOS='pixos' # The pixos value describes the Cisco PIX operating system.
    UNDEFINED='undefined' # The undefined value is to be used when the desired family is not available.
    UNIX='unix' # The unix value describes the UNIX operating system.
    VMWARE_INFRASTRUCTURE='vmware_infrastructure' # The vmware_infrastructure value describes VMWare Infrastructure.
    WINDOWS='windows' # The windows value describes the Microsoft Windows operating system.


class FilterActionEnumeration(str, Enum):
    """FilterActionEnumeration -- The FilterActionEnumeration simple type defines the different options for filtering sets of items.
    
    """
    EXCLUDE='exclude' # The exclude value specifies that all items that match the filter shall be excluded from set that the filter is applied to.
    INCLUDE='include' # The include value specifies that only items that match the filter shall be included in the set that the filter is applied to.


class MessageLevelEnumeration(str, Enum):
    """MessageLevelEnumeration -- The MessageLevelEnumeration simple type defines the different levels associated with a message. There is no specific criteria about which messages get assigned which level. This is completely arbitrary and up to the content producer to decide what is an error message and what is a debug message.
    
    """
    DEBUG='debug' # Debug messages should only be displayed by a tool when run in some sort of verbose mode.
    ERROR='error' # Error messages should be recorded when there was an error that did not allow the collection of specific data.
    FATAL='fatal' # A fatal message should be recorded when an error causes the failure of more than just a single piece of data.
    INFO='info' # Info messages are used to pass useful information about the data collection to a user.
    WARNING='warning' # A warning message reports something that might not correct but information was still collected.


class OperationEnumeration(str, Enum):
    """OperationEnumeration -- The OperationEnumeration simple type defines acceptable operations. Each operation defines how to compare entities against their actual values.
    
    """
    EQUALS='equals' # The 'equals' operation returns true if the actual value on the system is equal to the stated entity. When the specified datatype is a string, this results in a case-sensitive comparison.
    NOTEQUAL='not equal' # The 'not equal' operation returns true if the actual value on the system is not equal to the stated entity. When the specified datatype is a string, this results in a case-sensitive comparison.
    CASEINSENSITIVEEQUALS='case insensitive equals' # The 'case insensitive equals' operation is meant for string data and returns true if the actual value on the system is equal (using a case insensitive comparison) to the stated entity.
    CASEINSENSITIVENOTEQUAL='case insensitive not equal' # The 'case insensitive not equal' operation is meant for string data and returns true if the actual value on the system is not equal (using a case insensitive comparison) to the stated entity.
    GREATERTHAN='greater than' # The 'greater than' operation returns true if the actual value on the system is greater than the stated entity.
    LESSTHAN='less than' # The 'less than' operation returns true if the actual value on the system is less than the stated entity.
    GREATERTHANOREQUAL='greater than or equal' # The 'greater than or equal' operation returns true if the actual value on the system is greater than or equal to the stated entity.
    LESSTHANOREQUAL='less than or equal' # The 'less than or equal' operation returns true if the actual value on the system is less than or equal to the stated entity.
    BITWISEAND='bitwise and' # The 'bitwise and' operation is used to determine if a specific bit is set. It returns true if performing a BITWISE AND with the binary representation of the stated entity against the binary representation of the actual value on the system results in a binary value that is equal to the binary representation of the stated entity. For example, assuming a datatype of 'int', if the actual integer value of the setting on your machine is 6 (same as 0110 in binary), then performing a 'bitwise and' with the stated integer 4 (0100) returns 4 (0100). Since the result is the same as the state mask, then the test returns true. If the actual value on your machine is 1 (0001), then the 'bitwise and' with the stated integer 4 (0100) returns 0 (0000). Since the result is not the same as the stated mask, then the test fails.
    BITWISEOR='bitwise or' # The 'bitwise or' operation is used to determine if a specific bit is not set. It returns true if performing a BITWISE OR with the binary representation of the stated entity against the binary representation of the actual value on the system results in a binary value that is equal to the binary representation of the stated entity. For example, assuming a datatype of 'int', if the actual integer value of the setting on your machine is 6 (same as 0110 in binary), then performing a 'bitwise or' with the stated integer 14 (1110) returns 14 (1110). Since the result is the same as the state mask, then the test returns true. If the actual value on your machine is 1 (0001), then the 'bitwise or' with the stated integer 14 (1110) returns 15 (1111). Since the result is not the same as the stated mask, then the test fails.
    PATTERNMATCH='pattern match' # The 'pattern match' operation allows an item to be tested against a regular expression. When used by an entity in an OVAL Object, the regular expression represents the unique set of matching items on the system. OVAL supports a common subset of the regular expression character classes, operations, expressions and other lexical tokens defined within Perl 5's regular expression specification. For more information on the supported regular expression syntax in OVAL see: http://oval.mitre.org/language/about/re_support_5.6.html
    SUBSETOF='subset of' # The 'subset of' operation returns true if the actual set on the system is a subset of the set defined by the stated entity.
    SUPERSETOF='superset of' # The 'superset of' operation returns true if the actual set on the system is a superset of the set defined by the stated entity.


class OperatorEnumeration(str, Enum):
    """OperatorEnumeration -- The OperatorEnumeration simple type defines acceptable operators. Each operator defines how to evaluate multiple arguments.
    
    """
    AND='AND' # The AND operator produces a true result if every argument is true. If one or more arguments are false, the result of the AND is false. If one or more of the arguments are unknown, and if none of the arguments are false, then the AND operator produces a result of unknown.
    ONE='ONE' # The ONE operator produces a true result if one and only one argument is true. If there are more than argument is true (or if there are no true arguments), the result of the ONE is false. If one or more of the arguments are unknown, then the ONE operator produces a result of unknown.
    OR='OR' # The OR operator produces a true result if one or more arguments is true. If every argument is false, the result of the OR is false. If one or more of the arguments are unknown and if none of arguments are true, then the OR operator produces a result of unknown.
    XOR='XOR' # XOR is defined to be true if an odd number of its arguments are true, and false otherwise. If any of the arguments are unknown, then the XOR operator produces a result of unknown.


class OperatorType(str, Enum):
    """OperatorType -- The OperatorType simple type provides a list of possible
    operator values that operate on a set of test_action
    elements.
    
    """
    AND='AND' # The AND operator produces a true result if every argument is true. If one or more arguments are false, the result of the AND is false. See the truth table provided in the ResultType type for a complete list of how the various result types are combined by an AND operation.
    OR='OR' # The OR operator produces a true result if one or more arguments is true. If every argument is false, the result of the OR is false. See the truth table provided in the ResultType type for a complete list of how the various result types are combined by an OR operation.


class ResultType(str, Enum):
    """ResultType -- The ResultType simple type defines acceptable result
    values for questionnaires and test_actions.
    || P   | F | E | U | NT | NA ||
    ---------------||-----------------------------||------------------||------------------------------------------
    || 1+ | 0   | 0   | 0   | 0   | 0+ || Pass
    || 0+ | 1+ | 0+ | 0+ | 0+ | 0+ || Fail
    AND 	|| 0+ | 0   | 1+ | 0+ | 0+ | 0+ || Error
    || 0+ | 0   | 0   | 1+ | 0+ | 0+ || Unknown
    || 0+ | 0   | 0   | 0   | 1+ | 0+ || Not Tested
    || 0   | 0   | 0   | 0   | 0   | 1+ || Not Applicable
    || 0   | 0   | 0   | 0   | 0   | 0   || Not Tested
    ---------------||-----------------------------||------------------||------------------------------------------
    || 1+ | 0+ | 0+ | 0+ | 0+ | 0+ || Pass
    || 0   | 1+ | 0   | 0   | 0   | 0+ || Fail
    OR 	|| 0   | 0+ | 1+ | 0+ | 0+ | 0+ || Error
    || 0   | 0+ | 0   | 1+ | 0+ | 0+ || Unknown
    || 0   | 0+ | 0   | 0   | 1+ | 0+ || Not Tested
    || 0   | 0   | 0   | 0   | 0   | 1+ || Not Applicable
    || 0   | 0   | 0   | 0   | 0   | 0   || Not Tested
    
    """
    PASS='PASS' # A PASS value indicates that the check passed its test.
    FAIL='FAIL' # A FAIL value indicates that the check did not pass its test.


class SetOperatorEnumeration(str, Enum):
    """SetOperatorEnumeration -- The SetOperatorEnumeration simple type defines acceptable set operations. Set operations are used to take multiple different sets of objects within OVAL and merge them into a single unique set. The different operators that guide this merge are defined below. For each operator, if only a single object has been supplied, then the resulting set is simply that complete object.
    
    """
    COMPLEMENT='COMPLEMENT' # The complement operator is defined in OVAL as a relative complement. The resulting unique set contains everything that belongs to the first declared set that is not part of the second declared set. If A and B are sets (with A being the first declared set), then the relative complement is the set of elements in A, but not in B, with the duplicates removed.
    INTERSECTION='INTERSECTION' # The intersection of two sets in OVAL results in a unique set that contains everything that belongs to both sets in the collection, but nothing else. If A and B are sets, then the intersection of A and B contains all the elements of A that also belong to B, but no other elements, with the duplicates removed.
    UNION='UNION' # The union of two sets in OVAL results in a unique set that contains everything that belongs to either of the original sets. If A and B are sets, then the union of A and B contains all the elements of A and all elements of B, with the duplicates removed.


class SimpleDatatypeEnumeration(str, Enum):
    """SimpleDatatypeEnumeration -- The SimpleDatatypeEnumeration simple type defines the legal datatypes that are used to describe the values of individual entities that can be represented in a XML string field. The value may have structure and a pattern, but it is represented as string content.
    
    """
    BINARY='binary' # The binary datatype is used to represent hex-encoded data that is in raw (non-printable) form. This datatype conforms to the W3C Recommendation for binary data meaning that each binary octet is encoded as a character tuple, consisting of two hexadecimal digits {[0-9a-fA-F]} representing the octet code. Expected operations within OVAL for binary values are 'equals' and 'not equal'.
    BOOLEAN='boolean' # The boolean datatype represents standard boolean data, either true or false. This datatype conforms to the W3C Recommendation for boolean data meaning that the following literals are legal values: {true, false, 1, 0}. Expected operations within OVAL for boolean values are 'equals' and 'not equal'.
    EVR_STRING='evr_string' # The evr_string datatype represents the epoch, version, and release fields as a single version string. It has the form "EPOCH:VERSION-RELEASE". Comparisons involving this datatype should follow the algorithm of librpm's rpmvercmp() function. Expected operations within OVAL for evr_string values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.
    DEBIAN_EVR_STRING='debian_evr_string' # The debian_evr_string datatype represents the epoch, upstream_version, and debian_revision fields, for a Debian package, as a single version string. It has the form "EPOCH:UPSTREAM_VERSION-DEBIAN_REVISION". Comparisons involving this datatype should follow the algorithm outlined in Chapter 5 of the "Debian Policy Manual" (https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version). Note that a null epoch is equivalent to a value of '0'. An implementation of this is the cmpversions() function in dpkg's enquiry.c. Expected operations within OVAL for debian_evr_string values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.
    FILESET_REVISION='fileset_revision' # The fileset_revision datatype represents the version string related to filesets in HP-UX. An example would be 'A.03.61.00'. For more information, see the HP-UX "Software Distributor Administration Guide" (http://h20000.www2.hp.com/bc/docs/support/SupportManual/c01919399/c01919399.pdf). Expected operations within OVAL for fileset_version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.
    FLOAT='float' # The float datatype describes standard float data. This datatype conforms to the W3C Recommendation for float data meaning it is patterned after the IEEE single-precision 32-bit floating point type. The format consists of a decimal followed, optionally, by the character 'E' or 'e', followed by an integer exponent. The special values positive and negative infinity and not-a-number have are represented by INF, -INF and NaN, respectively. Expected operations within OVAL for float values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.
    IOS_VERSION='ios_version' # The ios_version datatype describes Cisco IOS Train strings. These are in essence version strings for IOS. Please refer to Cisco's IOS Reference Guide for information on how to compare different Trains as they follow a very specific pattern. Expected operations within OVAL for ios_version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.
    INT='int' # The int datatype describes standard integer data. This datatype conforms to the W3C Recommendation for integer data which follows the standard mathematical concept of the integer numbers. (no decimal point and infinite range) Expected operations within OVAL for int values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'bitwise and', and 'bitwise or'.
    IPV_4_ADDRESS='ipv4_address' # The ipv4_address datatype represents IPv4 addresses and IPv4 address prefixes. Its value space consists of the set of ordered pairs of integers where the first element of each pair is in the range [0,2^32) (the representable range of a 32-bit unsigned int), and the second is in the range [0,32]. The first element is an address, and the second is a prefix length. The lexical space is dotted-quad CIDR-like notation ('a.b.c.d' where 'a', 'b', 'c', and 'd' are integers from 0-255), optionally followed by a slash ('/') and either a prefix length (an integer from 0-32) or a netmask represented in the dotted-quad notation described previously. Examples of legal values are '192.0.2.0', '192.0.2.0/32', and '192.0.2.0/255.255.255.255'. Additionally, leading zeros are permitted such that '192.0.2.0' is equal to '192.000.002.000'. If a prefix length is not specified, it is implicitly equal to 32.The expected operations within OVAL for ipv4_address values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'subset of', and 'superset of'. All operations are defined in terms of the value space. Let A and B be ipv4_address values (i.e. ordered pairs from the value space). The following definitions assume that bits outside the prefix have been zeroed out. By zeroing the low order bits, they are effectively ignored for all operations. Implementations of the following operations MUST behave as if this has been done.The following defines how to perform each operation for the ipv4_address datatype. Let P_addr mean the first element of ordered pair P and P_prefix mean the second element.equals: A equals B if and only if A_addr == B_addr and A_prefix == B_prefix.not equal: A is not equal to B if and only if they don't satisfy the criteria for operator "equals".greater than: A is greater than B if and only if A_prefix == B_prefix and A_addr > B_addr. If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.greater than or equal: A is greater than or equal to B if and only if A_prefix == B_prefix and they satisfy either the criteria for operators "equal" or "greater than". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.less than: A is less than B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than or equal". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.less than or equal: A is less than or equal to B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.subset of: A is a subset of B if and only if every IPv4 address in subnet A is present in subnet B. In other words, A_prefix >= B_prefix and the high B_prefix bits of A_addr and B_addr are equal.superset of: A is a superset of B if and only if B is a subset of A.
    IPV_6_ADDRESS='ipv6_address' # The ipv6_address datatype represents IPv6 addresses and IPv6 address prefixes. Its value space consists of the set of ordered pairs of integers where the first element of each pair is in the range [0,2^128) (the representable range of a 128-bit unsigned int), and the second is in the range [0,128]. The first element is an address, and the second is a prefix length.The lexical space is CIDR notation given in IETF specification RFC 4291 for textual representations of IPv6 addresses and IPv6 address prefixes (see sections 2.2 and 2.3). If a prefix-length is not specified, it is implicitly equal to 128.The expected operations within OVAL for ipv6_address values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'subset of', and 'superset of'. All operations are defined in terms of the value space. Let A and B be ipv6_address values (i.e. ordered pairs from the value space). The following definitions assume that bits outside the prefix have been zeroed out. By zeroing the low order bits, they are effectively ignored for all operations. Implementations of the following operations MUST behave as if this has been done.The following defines how to perform each operation for the ipv6_address datatype. Let P_addr mean the first element of ordered pair P and P_prefix mean the second element.equals: A equals B if and only if A_addr == B_addr and A_prefix == B_prefix.not equal: A is not equal to B if and only if they don't satisfy the criteria for operator "equals".greater than: A is greater than B if and only if A_prefix == B_prefix and A_addr > B_addr. If A_prefix != B_prefix, an error MUST be reported.greater than or equal: A is greater than or equal to B if and only if A_prefix == B_prefix and they satisfy either the criteria for operators "equal" or "greater than". If A_prefix != B_prefix, an error MUST be reported.less than: A is less than B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than or equal". If A_prefix != B_prefix, an error MUST be reported.less than or equal: A is less than or equal to B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than". If A_prefix != B_prefix, an error MUST be reported.subset of: A is a subset of B if and only if every IPv6 address in subnet A is present in subnet B. In other words, A_prefix >= B_prefix and the high B_prefix bits of A_addr and B_addr are equal.superset of: A is a superset of B if and only if B is a subset of A.
    STRING='string' # The string datatype describes standard string data. This datatype conforms to the W3C Recommendation for string data. Expected operations within OVAL for string values are 'equals', 'not equal', 'case insensitive equals', 'case insensitive not equal', 'pattern match'.
    VERSION='version' # The version datatype represents a value that is a hierarchical list of non-negative integers separated by a single character delimiter. Note that any non-number character can be used as a delimiter and that different characters can be used within the same version string. So '#.#-#' is the same as '#.#.#' or '#c#c#' where '#' is any non-negative integer. Expected operations within OVAL for version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.For example '#.#.#' or '#-#-#-#' where the numbers to the left are more significant than the numbers to the right. When performing an 'equals' operation on a version datatype, you should first check the left most number for equality. If that fails, then the values are not equal. If it succeeds, then check the second left most number for equality. Continue checking the numbers from left to right until the last number has been checked. If, after testing all the previous numbers, the last number is equal then the two versions are equal. When performing other operations, such as 'less than', 'less than or equal', 'greater than, or 'greater than or equal', similar logic as above is used. Start with the left most number and move from left to right. For each number, check if it is less than the number you are testing against. If it is, then the version in question is less than the version you are testing against. If the number is equal, then move to check the next number to the right. For example, to test if 5.7.23 is less than or equal to 5.8.0 you first compare 5 to 5. They are equal so you move on to compare 7 to 8. 7 is less than 8 so the entire test succeeds and 5.7.23 is 'less than or equal' to 5.8.0. The difference between the 'less than' and 'less than or equal' operations is how the last number is handled. If the last number is reached, the check should use the given operation (either 'less than' and 'less than or equal') to test the number. For example, to test if 4.23.6 is greater than 4.23.6 you first compare 4 to 4. They are equal so you move on to compare 23 to 23. They are equal so you move on to compare 6 to 6. This is the last number in the version and since 6 is not greater than 6, the entire test fails and 4.23.6 is not greater than 4.23.6.Version strings with a different number of components shall be padded with zeros to make them the same size. For example, if the version strings '1.2.3' and '6.7.8.9' are being compared, then the short one should be padded to become '1.2.3.0'.


class UserResponseType(str, Enum):
    """UserResponseType -- The UserResponseType type defines structures containing
    the type of response. The question could have been answered or an
    exceptional condition may have occurred.
    
    """
    ANSWERED='ANSWERED' # Indicates that the question was answered.


class VariableDataType(str, Enum):
    """VariableDataType -- The VariableDataType simple type defines how a variable
    data value should be treated or used.
    
    """
    TEXT='TEXT' # The TEXT value specifies that the variable data value should be treated as text.
    NUMERIC='NUMERIC' # The NUMERIC value specifies that the variable data value should be treated as numeric.


class actuateType(str, Enum):
    ON_LOAD='onLoad'
    ON_REQUEST='onRequest'
    OTHER='other'
    NONE='none'


class ccOperatorEnumType(str, Enum):
    """ccOperatorEnumType --  The type for the allowed @operator names for the
    <
    xccdf:complex-check
    >
    operator attribute. Only AND and OR operators are
    supported. (The
    <
    xccdf:complex-check
    >
    has a separate mechanism for negation.)
    
    """
    OR='OR' # The logical OR of the component terms
    AND='AND' # The logical AND of the component terms


class datatypeType(str, Enum):
    IPV_4_ADDRESS='ipv4_address'
    IPV_6_ADDRESS='ipv6_address'


class datatypeType44(str, Enum):
    IPV_4_ADDRESS='ipv4_address'
    IPV_6_ADDRESS='ipv6_address'
    STRING='string'


class datatypeType45(str, Enum):
    IPV_4_ADDRESS='ipv4_address'
    IPV_6_ADDRESS='ipv6_address'


class datatypeType46(str, Enum):
    IPV_4_ADDRESS='ipv4_address'
    IPV_6_ADDRESS='ipv6_address'
    STRING='string'


class datatypeType47(str, Enum):
    IOS_VERSION='ios_version'
    STRING='string' # 'string' is included to allow for regular expressions on IOS version strings.


class fixStrategyEnumType(str, Enum):
    """fixStrategyEnumType --  Allowed @strategy keyword values for an
    <
    xccdf:Rule
    >
    element's
    <
    xccdf:fix
    >
    or
    <
    xccdf:fixtext
    >
    elements.
    The values indicate the method or approach for fixing non-compliance with a
    particular
    <
    xccdf:Rule
    >
    .
    
    """
    UNKNOWN='unknown' # Strategy not defined (default)
    CONFIGURE='configure' # Adjust target configuration/settings
    COMBINATION='combination' # Combination of two or more approaches
    DISABLE='disable' # Turn off or uninstall a target component
    ENABLE='enable' # Turn on or install a target component
    PATCH='patch' # Apply a patch, hotfix, update, etc.
    POLICY='policy' # Remediation requires out-of-band adjustments to policies or procedures
    RESTRICT='restrict' # Adjust permissions, access rights, filters, or other access restrictions
    UPDATE='update' # Install, upgrade or update the system


class interfaceHintType(str, Enum):
    """interfaceHintType --  Allowed interface hint values.
    <
    xccdf:Value
    >
    elements may contain a hint or recommendation to a benchmark consumer or producer
    about how the user might select or adjust the
    <
    xccdf:Value
    >
    . This type
    enumerates the possible values of this hint.
    
    """
    CHOICE='choice' # Multiple choice
    TEXTLINE='textline' # Multiple lines of text
    TEXT='text' # Single line of text
    DATE='date' # Date
    DATETIME='datetime' # Date and time


class msgSevEnumType(str, Enum):
    """msgSevEnumType --  Allowed values to indicate the severity of messages
    from the checking engine. These values don't affect scoring themselves but are
    present merely to convey diagnostic information from the checking engine. Benchmark
    consumers may choose to log these messages or display them to the user.
    
    """
    ERROR='error' # Denotes a serious problem identified; test did not run.
    WARNING='warning' # Denotes a possible issue; test may not have run.
    INFO='info' # Denotes important information about the tests.


class operatorEnumeration(str, Enum):
    AND='AND'
    OR='OR'


class ratingEnumType(str, Enum):
    """ratingEnumType --  This type enumerates allowed rating values the
    disruption and complexity properties of an
    <
    xccdf:Rule
    >
    element's
    <
    xccdf:fix
    >
    or
    <
    xccdf:fixtext
    >
    elements.
    
    """
    UNKNOWN='unknown' # Rating unknown or impossible to estimate (default)
    LOW='low' # Little or no potential for disruption, very modest complexity
    MEDIUM='medium' # Some chance of minor disruption, substantial complexity
    HIGH='high' # Likely to cause serious disruption, very complex


class resultEnumType(str, Enum):
    """resultEnumType -- Allowed result indicators for a
    test.
    
    """
    PASS='pass' # The target system or system component satisfied all the conditions of the <xccdf:Rule>.
    FAIL='fail' # The target system or system component did not satisfy all the conditions of the <xccdf:Rule>.
    ERROR='error' # The checking engine could not complete the evaluation; therefore the status of the targets compliance with the <xccdf:Rule> is not certain. This could happen, for example, if a testing tool was run with insufficient privileges and could not gather all of the necessary information.
    UNKNOWN='unknown' # The testing tool encountered some problem and the result is unknown. For example, a result of unknown might be given if the testing tool was unable to interpret the output of the checking engine (the output has no meaning to the testing tool).
    NOTAPPLICABLE='notapplicable' # The <xccdf:Rule> was not applicable to the target of the test. For example, the <xccdf:Rule> might have been specific to a different version of the target OS, or it might have been a test against a platform feature that was not installed.
    NOTCHECKED='notchecked' # The <xccdf:Rule> was not evaluated by the checking engine. This status is designed for <xccdf:Rule> elements that have no check. It may also correspond to a status returned by a checking engine if the checking engine does not support the indicated check code.
    NOTSELECTED='notselected' # The <xccdf:Rule> was not selected in the <xccdf:Benchmark>.
    INFORMATIONAL='informational' # The <xccdf:Rule> was checked, but the output from the checking engine is simply information for auditors or administrators; it is not a compliance category. This status value is designed for <xccdf:Rule> elements whose main purpose is to extract information from the target rather than test the target.
    FIXED='fixed' # The <xccdf:Rule> had failed, but was then fixed (possibly by a tool that can automatically apply remediation, or possibly by the human auditor).


class roleEnumType(str, Enum):
    """roleEnumType -- Allowed checking and scoring roles for an
    <
    xccdf:Rule
    >
    .
    
    """
    FULL='full' # If the <xccdf:Rule> is selected, then check it and let the result contribute to the score and appear in reports (default).
    UNSCORED='unscored' # If the <xccdf:Rule> is selected, then check it and include it in the test report, but give the result a status of informational and do not use the result in score computations.
    UNCHECKED='unchecked' # Do not check the <xccdf:Rule>; just force the result status to notchecked.


class scapVersionType(str, Enum):
    _1_0='1.0'
    _1_1='1.1'
    _1_2='1.2'
    _1_3='1.3'


class severityEnumType(str, Enum):
    """severityEnumType -- Allowed severity values for the @severity attribute of
    an
    <
    xccdf:Rule
    >
    . The value of this attribute provides an indication of the
    importance of the
    <
    xccdf:Rule
    >
    element's recommendation. This information is
    informative only and does not affect scoring.
    
    """
    UNKNOWN='unknown' # Severity not defined (default).
    INFO='info' # <xccdf:Rule> is informational and failure does not represent a problem.
    LOW='low' # Not a serious problem.
    MEDIUM='medium' # Fairly serious problem.
    HIGH='high' # A grave or critical problem.


class showType(str, Enum):
    NEW='new'
    REPLACE='replace'
    EMBED='embed'
    OTHER='other'
    NONE='none'


class statusType(str, Enum):
    """statusType --  The statusType represents the possible levels of
    maturity or consensus level for its parent element as recorded by an
    <
    xccdf:status
    >
    element.
    
    """
    ACCEPTED='accepted' # Released as final
    DEPRECATED='deprecated' # No longer needed
    DRAFT='draft' # Released in draft state
    INCOMPLETE='incomplete' # Under initial development
    INTERIM='interim' # Revised and in the process of being finalized


class subUseEnumType(str, Enum):
    """subUseEnumType -- This holds the possible values of the @use attribute
    within an
    <
    xccdf:sub
    >
    element. The @use attribute is only applicable with the
    subType's @idref attribute holds the value of the @id of an
    <
    xccdf:Value
    >
    element.
    
    """
    VALUE='value' # Replace with the selected <xccdf:value> or <xccdf:complex-value> of an <xccdf:Value>.
    TITLE='title' # Replace with the <xccdf:title> of the <xccdf:Value>.
    LEGACY='legacy' # Use the context-dependent processing of <xccdf:sub> elements outlined in XCCDF 1.1.4.


class systemOrPublic(str, Enum):
    SYSTEM='system'
    PUBLIC='public'


class typeType(str, Enum):
    SIMPLE='simple'
    EXTENDED='extended'
    TITLE='title'
    RESOURCE='resource'
    LOCATOR='locator'
    ARC='arc'


class useCaseType(str, Enum):
    CONFIGURATION='CONFIGURATION'
    VULNERABILITY='VULNERABILITY'
    INVENTORY='INVENTORY'
    OTHER='OTHER'


class valueOperatorType(str, Enum):
    """valueOperatorType --  This type enumerates allowed values of the @operator
    property of
    <
    xccdf:Value
    >
    elements. The specific interpretation of these
    operators depends on the checking system used.
    
    """
    EQUALS='equals'
    NOTEQUAL='not equal'
    GREATERTHAN='greater than'
    LESSTHAN='less than'
    GREATERTHANOREQUAL='greater than or equal'
    LESSTHANOREQUAL='less than or equal'
    PATTERNMATCH='pattern match'


class valueTypeType(str, Enum):
    """valueTypeType -- Allowed data types for
    <
    xccdf:Value
    >
    elements,
    string, numeric, and boolean. A tool may choose any convenient form to store an
    <
    xccdf:Value
    >
    element
    
    s
    <
    xccdf:value
    >
    element, but the @type conveys how
    the value should be treated for user input validation purposes during tailoring
    processing. The @type may also be used to give additional guidance to the user or to
    validate the user
    
    s input. For example, if an
    <
    xccdf:value
    >
    element
    
    s @type
    attribute is
    
    number
    
    , then a tool might choose to reject user tailoring input that
    is not composed of digits. In the case of a list of values, the @type applies to all
    elements of the list individually. Note that checking systems may have their own
    understanding of data types that may not be identical to the typing indicated in
    XCCDF
    
    """
    NUMBER='number' # A numeric value. This may be decimal or integer.
    STRING='string' # Any character data
    BOOLEAN='boolean' # True/false


class warningCategoryEnumType(str, Enum):
    """warningCategoryEnumType --  Allowed warning category keywords for the
    <
    xccdf:warning
    >
    element used in
    <
    xccdf:Rule
    >
    elements.
    
    """
    GENERAL='general' # Broad or general-purpose warning (default)
    FUNCTIONALITY='functionality' # Warning about possible impacts to functionality or operational features
    PERFORMANCE='performance' # Warning about changes to target system performance or throughput
    HARDWARE='hardware' # Warning about hardware restrictions or possible impacts to hardware
    LEGAL='legal' # Warning about legal implications
    REGULATORY='regulatory' # Warning about regulatory obligations or compliance implications
    MANAGEMENT='management' # Warning about impacts to the management or administration of the target system
    AUDIT='audit' # Warning about impacts to audit or logging
    DEPENDENCY='dependency' # Warning about dependencies between this element and other parts of the target system, or version dependencies


#
# Start data representation classes
#
class data_stream_collection(GeneratedsSuper):
    """Signature -- A digital signature of a data stream.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, schematron_version=None, data_stream=None, component=None, extended_component=None, Signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.schematron_version = _cast(None, schematron_version)
        self.schematron_version_nsprefix_ = None
        if data_stream is None:
            self.data_stream = []
        else:
            self.data_stream = data_stream
        self.data_stream_nsprefix_ = "ds"
        if component is None:
            self.component = []
        else:
            self.component = component
        self.component_nsprefix_ = "ds"
        if extended_component is None:
            self.extended_component = []
        else:
            self.extended_component = extended_component
        self.extended_component_nsprefix_ = "ds"
        if Signature is None:
            self.Signature = []
        else:
            self.Signature = Signature
        self.Signature_nsprefix_ = "dsig"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, data_stream_collection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if data_stream_collection.subclass:
            return data_stream_collection.subclass(*args_, **kwargs_)
        else:
            return data_stream_collection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_data_stream(self):
        return self.data_stream
    def set_data_stream(self, data_stream):
        self.data_stream = data_stream
    def add_data_stream(self, value):
        self.data_stream.append(value)
    def insert_data_stream_at(self, index, value):
        self.data_stream.insert(index, value)
    def replace_data_stream_at(self, index, value):
        self.data_stream[index] = value
    def get_component(self):
        return self.component
    def set_component(self, component):
        self.component = component
    def add_component(self, value):
        self.component.append(value)
    def insert_component_at(self, index, value):
        self.component.insert(index, value)
    def replace_component_at(self, index, value):
        self.component[index] = value
    def get_extended_component(self):
        return self.extended_component
    def set_extended_component(self, extended_component):
        self.extended_component = extended_component
    def add_extended_component(self, value):
        self.extended_component.append(value)
    def insert_extended_component_at(self, index, value):
        self.extended_component.insert(index, value)
    def replace_extended_component_at(self, index, value):
        self.extended_component[index] = value
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def add_Signature(self, value):
        self.Signature.append(value)
    def insert_Signature_at(self, index, value):
        self.Signature.insert(index, value)
    def replace_Signature_at(self, index, value):
        self.Signature[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_schematron_version(self):
        return self.schematron_version
    def set_schematron_version(self, schematron_version):
        self.schematron_version = schematron_version
    def validate_idType(self, value):
        # Validate type idType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idType_patterns_, ))
    validate_idType_patterns_ = [['^(scap_[^_]+_collection_.+)$']]
    def has__content(self):
        if (
            self.data_stream or
            self.component or
            self.extended_component or
            self.Signature
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" ', name_='data-stream-collection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('data-stream-collection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'data-stream-collection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='data-stream-collection')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='data-stream-collection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='data-stream-collection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.schematron_version is not None and 'schematron_version' not in already_processed:
            already_processed.add('schematron_version')
            outfile.write(' schematron-version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.schematron_version), input_name='schematron-version')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" ', name_='data-stream-collection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_stream_ in self.data_stream:
            namespaceprefix_ = self.data_stream_nsprefix_ + ':' if (UseCapturedNS_ and self.data_stream_nsprefix_) else ''
            data_stream_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='data-stream', pretty_print=pretty_print)
        for component_ in self.component:
            namespaceprefix_ = self.component_nsprefix_ + ':' if (UseCapturedNS_ and self.component_nsprefix_) else ''
            component_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='component', pretty_print=pretty_print)
        for extended_component_ in self.extended_component:
            namespaceprefix_ = self.extended_component_nsprefix_ + ':' if (UseCapturedNS_ and self.extended_component_nsprefix_) else ''
            extended_component_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='extended-component', pretty_print=pretty_print)
        for Signature_ in self.Signature:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            Signature_.export(outfile, level, namespaceprefix_='dsig:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_idType(self.id)    # validate type idType
        value = find_attr_value_('schematron-version', node)
        if value is not None and 'schematron-version' not in already_processed:
            already_processed.add('schematron-version')
            self.schematron_version = value
            self.schematron_version = ' '.join(self.schematron_version.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'data-stream':
            obj_ = data_stream.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.data_stream.append(obj_)
            obj_.original_tagname_ = 'data-stream'
        elif nodeName_ == 'component':
            obj_ = component.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
        elif nodeName_ == 'extended-component':
            obj_ = extended_component.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extended_component.append(obj_)
            obj_.original_tagname_ = 'extended-component'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature.append(obj_)
            obj_.original_tagname_ = 'Signature'
# end class data_stream_collection


class data_stream(GeneratedsSuper):
    """dictionaries -- Holds pointers to dictionary components.
    checklists -- Holds pointers to checklist components.
    checks -- Holds pointers to check components.
    extended-components -- Holds pointers to non-standard SCAP components captured as extended-component
    elements.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, use_case=None, scap_version=None, timestamp=None, dictionaries=None, checklists=None, checks=None, extended_components=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.use_case = _cast(None, use_case)
        self.use_case_nsprefix_ = None
        self.scap_version = _cast(None, scap_version)
        self.scap_version_nsprefix_ = None
        if isinstance(timestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.dictionaries = dictionaries
        self.dictionaries_nsprefix_ = "ds"
        self.checklists = checklists
        self.checklists_nsprefix_ = "ds"
        self.checks = checks
        self.checks_nsprefix_ = "ds"
        self.extended_components = extended_components
        self.extended_components_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, data_stream)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if data_stream.subclass:
            return data_stream.subclass(*args_, **kwargs_)
        else:
            return data_stream(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dictionaries(self):
        return self.dictionaries
    def set_dictionaries(self, dictionaries):
        self.dictionaries = dictionaries
    def get_checklists(self):
        return self.checklists
    def set_checklists(self, checklists):
        self.checklists = checklists
    def get_checks(self):
        return self.checks
    def set_checks(self, checks):
        self.checks = checks
    def get_extended_components(self):
        return self.extended_components
    def set_extended_components(self, extended_components):
        self.extended_components = extended_components
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_use_case(self):
        return self.use_case
    def set_use_case(self, use_case):
        self.use_case = use_case
    def get_scap_version(self):
        return self.scap_version
    def set_scap_version(self, scap_version):
        self.scap_version = scap_version
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def validate_idType40(self, value):
        # Validate type idType40, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idType40_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idType40_patterns_, ))
    validate_idType40_patterns_ = [['^(scap_[^_]+_datastream_.+)$']]
    def validate_use_caseType(self, value):
        # Validate type use-caseType, a restriction on None.
        pass
    def validate_scap_versionType(self, value):
        # Validate type scap-versionType, a restriction on None.
        pass
    def has__content(self):
        if (
            self.dictionaries is not None or
            self.checklists is not None or
            self.checks is not None or
            self.extended_components is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='data-stream', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('data-stream')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'data-stream':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='data-stream')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='data-stream', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='data-stream'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.use_case is not None and 'use_case' not in already_processed:
            already_processed.add('use_case')
            outfile.write(' use-case=%s' % (quote_attrib(self.use_case), ))
        if self.scap_version is not None and 'scap_version' not in already_processed:
            already_processed.add('scap_version')
            outfile.write(' scap-version=%s' % (quote_attrib(self.scap_version), ))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='data-stream', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dictionaries is not None:
            namespaceprefix_ = self.dictionaries_nsprefix_ + ':' if (UseCapturedNS_ and self.dictionaries_nsprefix_) else ''
            self.dictionaries.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dictionaries', pretty_print=pretty_print)
        if self.checklists is not None:
            namespaceprefix_ = self.checklists_nsprefix_ + ':' if (UseCapturedNS_ and self.checklists_nsprefix_) else ''
            self.checklists.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checklists', pretty_print=pretty_print)
        if self.checks is not None:
            namespaceprefix_ = self.checks_nsprefix_ + ':' if (UseCapturedNS_ and self.checks_nsprefix_) else ''
            self.checks.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checks', pretty_print=pretty_print)
        if self.extended_components is not None:
            namespaceprefix_ = self.extended_components_nsprefix_ + ':' if (UseCapturedNS_ and self.extended_components_nsprefix_) else ''
            self.extended_components.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extended-components', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_idType40(self.id)    # validate type idType40
        value = find_attr_value_('use-case', node)
        if value is not None and 'use-case' not in already_processed:
            already_processed.add('use-case')
            self.use_case = value
            self.validate_use_caseType(self.use_case)    # validate type use-caseType
        value = find_attr_value_('scap-version', node)
        if value is not None and 'scap-version' not in already_processed:
            already_processed.add('scap-version')
            self.scap_version = value
            self.validate_scap_versionType(self.scap_version)    # validate type scap-versionType
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dictionaries':
            obj_ = refListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dictionaries = obj_
            obj_.original_tagname_ = 'dictionaries'
        elif nodeName_ == 'checklists':
            obj_ = refListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checklists = obj_
            obj_.original_tagname_ = 'checklists'
        elif nodeName_ == 'checks':
            obj_ = refListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checks = obj_
            obj_.original_tagname_ = 'checks'
        elif nodeName_ == 'extended-components':
            obj_ = refListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extended_components = obj_
            obj_.original_tagname_ = 'extended-components'
# end class data_stream


class component(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, timestamp=None, Benchmark=None, oval_definitions=None, ocil=None, cpe_list=None, Tailoring=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if isinstance(timestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.Benchmark = Benchmark
        self.Benchmark_nsprefix_ = "xccdf"
        self.oval_definitions = oval_definitions
        self.oval_definitions_nsprefix_ = "oval"
        self.ocil = ocil
        self.ocil_nsprefix_ = "ocil"
        self.cpe_list = cpe_list
        self.cpe_list_nsprefix_ = "cpe-dict"
        self.Tailoring = Tailoring
        self.Tailoring_nsprefix_ = "xccdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, component)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if component.subclass:
            return component.subclass(*args_, **kwargs_)
        else:
            return component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Benchmark(self):
        return self.Benchmark
    def set_Benchmark(self, Benchmark):
        self.Benchmark = Benchmark
    def get_oval_definitions(self):
        return self.oval_definitions
    def set_oval_definitions(self, oval_definitions):
        self.oval_definitions = oval_definitions
    def get_ocil(self):
        return self.ocil
    def set_ocil(self, ocil):
        self.ocil = ocil
    def get_cpe_list(self):
        return self.cpe_list
    def set_cpe_list(self, cpe_list):
        self.cpe_list = cpe_list
    def get_Tailoring(self):
        return self.Tailoring
    def set_Tailoring(self, Tailoring):
        self.Tailoring = Tailoring
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def validate_idType41(self, value):
        # Validate type idType41, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idType41_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idType41_patterns_, ))
    validate_idType41_patterns_ = [['^(scap_[^_]+_comp_.+)$']]
    def has__content(self):
        if (
            self.Benchmark is not None or
            self.oval_definitions is not None or
            self.ocil is not None or
            self.cpe_list is not None or
            self.Tailoring is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5"  xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0"  xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" ', name_='component', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('component')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'component':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='component')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='component', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='component'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5"  xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0"  xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" ', name_='component', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Benchmark is not None:
            namespaceprefix_ = self.Benchmark_nsprefix_ + ':' if (UseCapturedNS_ and self.Benchmark_nsprefix_) else ''
            self.Benchmark.export(outfile, level, namespaceprefix_='xccdf:', namespacedef_='', name_='Benchmark', pretty_print=pretty_print)
        if self.oval_definitions is not None:
            namespaceprefix_ = self.oval_definitions_nsprefix_ + ':' if (UseCapturedNS_ and self.oval_definitions_nsprefix_) else ''
            self.oval_definitions.export(outfile, level, namespaceprefix_='oval:', namespacedef_='', name_='oval_definitions', pretty_print=pretty_print)
        if self.ocil is not None:
            namespaceprefix_ = self.ocil_nsprefix_ + ':' if (UseCapturedNS_ and self.ocil_nsprefix_) else ''
            self.ocil.export(outfile, level, namespaceprefix_='ocil:', namespacedef_='', name_='ocil', pretty_print=pretty_print)
        if self.cpe_list is not None:
            namespaceprefix_ = self.cpe_list_nsprefix_ + ':' if (UseCapturedNS_ and self.cpe_list_nsprefix_) else ''
            self.cpe_list.export(outfile, level, namespaceprefix_='cpe-dict:', namespacedef_='', name_='cpe-list', pretty_print=pretty_print)
        if self.Tailoring is not None:
            namespaceprefix_ = self.Tailoring_nsprefix_ + ':' if (UseCapturedNS_ and self.Tailoring_nsprefix_) else ''
            self.Tailoring.export(outfile, level, namespaceprefix_='xccdf:', namespacedef_='', name_='Tailoring', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_idType41(self.id)    # validate type idType41
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Benchmark':
            obj_ = Benchmark.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Benchmark = obj_
            obj_.original_tagname_ = 'Benchmark'
        elif nodeName_ == 'oval_definitions':
            obj_ = oval_definitions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.oval_definitions = obj_
            obj_.original_tagname_ = 'oval_definitions'
        elif nodeName_ == 'ocil':
            obj_ = OCILType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ocil = obj_
            obj_.original_tagname_ = 'ocil'
        elif nodeName_ == 'cpe-list':
            obj_ = ListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cpe_list = obj_
            obj_.original_tagname_ = 'cpe-list'
        elif nodeName_ == 'Tailoring':
            obj_ = tailoringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tailoring = obj_
            obj_.original_tagname_ = 'Tailoring'
# end class component


class extended_component(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, timestamp=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if isinstance(timestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extended_component)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extended_component.subclass:
            return extended_component.subclass(*args_, **kwargs_)
        else:
            return extended_component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def validate_idType42(self, value):
        # Validate type idType42, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idType42_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idType42_patterns_, ))
    validate_idType42_patterns_ = [['^(scap_[^_]+_ecomp_.+)$']]
    def has__content(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='extended-component', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extended-component')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extended-component':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extended-component')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extended-component', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extended-component'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='extended-component', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_idType42(self.id)    # validate type idType42
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'extended-component')
        self.set_anytypeobjs_(content_)
# end class extended_component


class component_ref(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, type_='simple', href=None, catalog=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.catalog = catalog
        self.catalog_nsprefix_ = "cat"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, component_ref)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if component_ref.subclass:
            return component_ref.subclass(*args_, **kwargs_)
        else:
            return component_ref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalog(self):
        return self.catalog
    def set_catalog(self, catalog):
        self.catalog = catalog
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def validate_idType43(self, value):
        # Validate type idType43, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idType43_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idType43_patterns_, ))
    validate_idType43_patterns_ = [['^(scap_[^_]+_cref_.+)$']]
    def validate_typeType(self, value):
        # Validate type xlink:typeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simple', 'extended', 'title', 'resource', 'locator', 'arc']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_hrefType(self, value):
        # Validate type xlink:hrefType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.catalog is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" ', name_='component-ref', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('component-ref')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'component-ref':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='component-ref')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='component-ref', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='component-ref'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' xlink:href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" ', name_='component-ref', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.catalog is not None:
            namespaceprefix_ = self.catalog_nsprefix_ + ':' if (UseCapturedNS_ and self.catalog_nsprefix_) else ''
            self.catalog.export(outfile, level, namespaceprefix_='cat:', namespacedef_='', name_='catalog', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_idType43(self.id)    # validate type idType43
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
            self.validate_hrefType(self.href)    # validate type hrefType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'catalog':
            obj_ = catalog.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalog = obj_
            obj_.original_tagname_ = 'catalog'
# end class component_ref


class contentSourceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contentSourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contentSourceType.subclass:
            return contentSourceType.subclass(*args_, **kwargs_)
        else:
            return contentSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='contentSourceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('contentSourceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'contentSourceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='contentSourceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='contentSourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='contentSourceType'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='contentSourceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class contentSourceType


class refListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, component_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        if component_ref is None:
            self.component_ref = []
        else:
            self.component_ref = component_ref
        self.component_ref_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refListType.subclass:
            return refListType.subclass(*args_, **kwargs_)
        else:
            return refListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_component_ref(self):
        return self.component_ref
    def set_component_ref(self, component_ref):
        self.component_ref = component_ref
    def add_component_ref(self, value):
        self.component_ref.append(value)
    def insert_component_ref_at(self, index, value):
        self.component_ref.insert(index, value)
    def replace_component_ref_at(self, index, value):
        self.component_ref[index] = value
    def has__content(self):
        if (
            self.component_ref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='refListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'refListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='refListType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='refListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='refListType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='refListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for component_ref_ in self.component_ref:
            namespaceprefix_ = self.component_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.component_ref_nsprefix_) else ''
            component_ref_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='component-ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'component-ref':
            obj_ = component_ref.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.component_ref.append(obj_)
            obj_.original_tagname_ = 'component-ref'
# end class refListType


class Benchmark(GeneratedsSuper):
    """status -- Status of the
    <
    xccdf:Benchmark
    >
    indicating its level of maturity or consensus. If more than one
    <
    xccdf:status
    >
    element appears, the element's @date attribute
    should be included.
    dc-status -- Holds additional status information using
    the Dublin Core format.
    title -- Title of the
    <
    xccdf:Benchmark
    >
    ; an
    <
    xccdf:Benchmark
    >
    should have an
    <
    xccdf:title
    >
    .
    description -- Text that describes the
    <
    xccdf:Benchmark
    >
    ; an
    <
    xccdf:Benchmark
    >
    should have an
    <
    xccdf:description
    >
    .
    notice -- Legal notices (licensing information, terms
    of use, etc.), copyright statements, warnings, and other advisory
    notices about this
    <
    xccdf:Benchmark
    >
    and its
    use.
    front-matter -- Introductory matter for the beginning of
    the
    <
    xccdf:Benchmark
    >
    document; intended for use during Document
    Generation.
    rear-matter -- Concluding material for the end of the
    <
    xccdf:Benchmark
    >
    document; intended for use during Document
    Generation.
    reference -- Supporting references for the
    <
    xccdf:Benchmark
    >
    document.
    plain-text -- Definitions for reusable text blocks, each
    with a unique identifier.
    platform-specification -- A list of identifiers for complex platform
    definitions, written in CPE applicability language format. Authors may
    define complex platforms within this element, and then use their locally
    unique identifiers anywhere in the
    <
    xccdf:Benchmark
    >
    element in
    place of a CPE name.
    platform -- Applicable platforms for this
    <
    xccdf:Benchmark
    >
    . Authors should use the element to identify the
    systems or products to which the
    <
    xccdf:Benchmark
    >
    applies.
    version -- Version number of the
    <
    xccdf:Benchmark
    >
    .
    metadata -- XML metadata for the
    <
    xccdf:Benchmark
    >
    . Metadata allows many additional pieces of
    information, including authorship, publisher, support, and other similar
    details, to be embedded in an
    <
    xccdf:Benchmark
    >
    .
    model -- URIs of suggested scoring models to be used
    when computing a score for this
    <
    xccdf:Benchmark
    >
    . A suggested
    list of scoring models and their URIs is provided in the XCCDF
    specification.
    Profile -- <
    xccdf:Profile
    >
    elements that
    reference and customize sets of items in the
    <
    xccdf:Benchmark
    >
    .
    Value -- Parameter
    <
    xccdf:Value
    >
    elements that
    support
    <
    xccdf:Rule
    >
    elements and descriptions in the
    <
    xccdf:Benchmark
    >
    .
    Group -- <
    xccdf:Group
    >
    elements that
    comprise the
    <
    xccdf:Benchmark
    >
    ; each may contain additional
    <
    xccdf:Value
    >
    ,
    <
    xccdf:Rule
    >
    , and other
    <
    xccdf:Group
    >
    elements.
    Rule -- <
    xccdf:Rule
    >
    elements that
    comprise the
    <
    xccdf:Benchmark
    >
    .
    TestResult -- <
    xccdf:Benchmark
    >
    test result records
    (one per
    <
    xccdf:Benchmark
    >
    run).
    signature -- A digital signature asserting authorship
    and allowing verification of the integrity of the
    <
    xccdf:Benchmark
    >
    .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, Id=None, resolved='false', style=None, style_href=None, lang=None, status=None, dc_status=None, title=None, description=None, notice=None, front_matter=None, rear_matter=None, reference=None, plain_text=None, platform_specification=None, platform=None, version=None, metadata=None, model=None, Profile=None, Value=None, Group=None, Rule=None, TestResult=None, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.resolved = _cast(None, resolved)
        self.resolved_nsprefix_ = None
        self.style = _cast(None, style)
        self.style_nsprefix_ = None
        self.style_href = _cast(None, style_href)
        self.style_href_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if status is None:
            self.status = []
        else:
            self.status = status
        self.status_nsprefix_ = "cdf"
        if dc_status is None:
            self.dc_status = []
        else:
            self.dc_status = dc_status
        self.dc_status_nsprefix_ = "cdf"
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = "cdf"
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = "cdf"
        if notice is None:
            self.notice = []
        else:
            self.notice = notice
        self.notice_nsprefix_ = "cdf"
        if front_matter is None:
            self.front_matter = []
        else:
            self.front_matter = front_matter
        self.front_matter_nsprefix_ = "cdf"
        if rear_matter is None:
            self.rear_matter = []
        else:
            self.rear_matter = rear_matter
        self.rear_matter_nsprefix_ = "cdf"
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = "cdf"
        if plain_text is None:
            self.plain_text = []
        else:
            self.plain_text = plain_text
        self.plain_text_nsprefix_ = "cdf"
        self.platform_specification = platform_specification
        self.platform_specification_nsprefix_ = "cpe2"
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = "cdf"
        self.version = version
        self.version_nsprefix_ = "cdf"
        if metadata is None:
            self.metadata = []
        else:
            self.metadata = metadata
        self.metadata_nsprefix_ = "cdf"
        if model is None:
            self.model = []
        else:
            self.model = model
        self.model_nsprefix_ = "cdf"
        if Profile is None:
            self.Profile = []
        else:
            self.Profile = Profile
        self.Profile_nsprefix_ = "cdf"
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.Value_nsprefix_ = "cdf"
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
        self.Group_nsprefix_ = "cdf"
        if Rule is None:
            self.Rule = []
        else:
            self.Rule = Rule
        self.Rule_nsprefix_ = "cdf"
        if TestResult is None:
            self.TestResult = []
        else:
            self.TestResult = TestResult
        self.TestResult_nsprefix_ = "cdf"
        self.signature = signature
        self.signature_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Benchmark)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Benchmark.subclass:
            return Benchmark.subclass(*args_, **kwargs_)
        else:
            return Benchmark(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def add_status(self, value):
        self.status.append(value)
    def insert_status_at(self, index, value):
        self.status.insert(index, value)
    def replace_status_at(self, index, value):
        self.status[index] = value
    def get_dc_status(self):
        return self.dc_status
    def set_dc_status(self, dc_status):
        self.dc_status = dc_status
    def add_dc_status(self, value):
        self.dc_status.append(value)
    def insert_dc_status_at(self, index, value):
        self.dc_status.insert(index, value)
    def replace_dc_status_at(self, index, value):
        self.dc_status[index] = value
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_notice(self):
        return self.notice
    def set_notice(self, notice):
        self.notice = notice
    def add_notice(self, value):
        self.notice.append(value)
    def insert_notice_at(self, index, value):
        self.notice.insert(index, value)
    def replace_notice_at(self, index, value):
        self.notice[index] = value
    def get_front_matter(self):
        return self.front_matter
    def set_front_matter(self, front_matter):
        self.front_matter = front_matter
    def add_front_matter(self, value):
        self.front_matter.append(value)
    def insert_front_matter_at(self, index, value):
        self.front_matter.insert(index, value)
    def replace_front_matter_at(self, index, value):
        self.front_matter[index] = value
    def get_rear_matter(self):
        return self.rear_matter
    def set_rear_matter(self, rear_matter):
        self.rear_matter = rear_matter
    def add_rear_matter(self, value):
        self.rear_matter.append(value)
    def insert_rear_matter_at(self, index, value):
        self.rear_matter.insert(index, value)
    def replace_rear_matter_at(self, index, value):
        self.rear_matter[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_plain_text(self):
        return self.plain_text
    def set_plain_text(self, plain_text):
        self.plain_text = plain_text
    def add_plain_text(self, value):
        self.plain_text.append(value)
    def insert_plain_text_at(self, index, value):
        self.plain_text.insert(index, value)
    def replace_plain_text_at(self, index, value):
        self.plain_text[index] = value
    def get_platform_specification(self):
        return self.platform_specification
    def set_platform_specification(self, platform_specification):
        self.platform_specification = platform_specification
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def add_platform(self, value):
        self.platform.append(value)
    def insert_platform_at(self, index, value):
        self.platform.insert(index, value)
    def replace_platform_at(self, index, value):
        self.platform[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def add_metadata(self, value):
        self.metadata.append(value)
    def insert_metadata_at(self, index, value):
        self.metadata.insert(index, value)
    def replace_metadata_at(self, index, value):
        self.metadata[index] = value
    def get_model(self):
        return self.model
    def set_model(self, model):
        self.model = model
    def add_model(self, value):
        self.model.append(value)
    def insert_model_at(self, index, value):
        self.model.insert(index, value)
    def replace_model_at(self, index, value):
        self.model[index] = value
    def get_Profile(self):
        return self.Profile
    def set_Profile(self, Profile):
        self.Profile = Profile
    def add_Profile(self, value):
        self.Profile.append(value)
    def insert_Profile_at(self, index, value):
        self.Profile.insert(index, value)
    def replace_Profile_at(self, index, value):
        self.Profile[index] = value
    def get_Value(self):
        return self.Value
    def set_Value(self, Value):
        self.Value = Value
    def add_Value(self, value):
        self.Value.append(value)
    def insert_Value_at(self, index, value):
        self.Value.insert(index, value)
    def replace_Value_at(self, index, value):
        self.Value[index] = value
    def get_Group(self):
        return self.Group
    def set_Group(self, Group):
        self.Group = Group
    def add_Group(self, value):
        self.Group.append(value)
    def insert_Group_at(self, index, value):
        self.Group.insert(index, value)
    def replace_Group_at(self, index, value):
        self.Group[index] = value
    def get_Rule(self):
        return self.Rule
    def set_Rule(self, Rule):
        self.Rule = Rule
    def add_Rule(self, value):
        self.Rule.append(value)
    def insert_Rule_at(self, index, value):
        self.Rule.insert(index, value)
    def replace_Rule_at(self, index, value):
        self.Rule[index] = value
    def get_TestResult(self):
        return self.TestResult
    def set_TestResult(self, TestResult):
        self.TestResult = TestResult
    def add_TestResult(self, value):
        self.TestResult.append(value)
    def insert_TestResult_at(self, index, value):
        self.TestResult.insert(index, value)
    def replace_TestResult_at(self, index, value):
        self.TestResult[index] = value
    def get_signature(self):
        return self.signature
    def set_signature(self, signature):
        self.signature = signature
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_resolved(self):
        return self.resolved
    def set_resolved(self, resolved):
        self.resolved = resolved
    def get_style(self):
        return self.style
    def set_style(self, style):
        self.style = style
    def get_style_href(self):
        return self.style_href
    def set_style_href(self, style_href):
        self.style_href = style_href
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def validate_benchmarkIdType(self, value):
        # Validate type cdf:benchmarkIdType, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_benchmarkIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_benchmarkIdType_patterns_, ))
    validate_benchmarkIdType_patterns_ = [['^(xccdf_[^_]+_benchmark_.+)$']]
    def has__content(self):
        if (
            self.status or
            self.dc_status or
            self.title or
            self.description or
            self.notice or
            self.front_matter or
            self.rear_matter or
            self.reference or
            self.plain_text or
            self.platform_specification is not None or
            self.platform or
            self.version is not None or
            self.metadata or
            self.model or
            self.Profile or
            self.Value or
            self.Group or
            self.Rule or
            self.TestResult or
            self.signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:cpe2="http://cpe.mitre.org/language/2.0" ', name_='Benchmark', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Benchmark')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Benchmark':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Benchmark')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Benchmark', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='Benchmark'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.resolved != "false" and 'resolved' not in already_processed:
            already_processed.add('resolved')
            outfile.write(' resolved=%s' % (quote_attrib(self.resolved), ))
        if self.style is not None and 'style' not in already_processed:
            already_processed.add('style')
            outfile.write(' style=%s' % (quote_attrib(self.style), ))
        if self.style_href is not None and 'style_href' not in already_processed:
            already_processed.add('style_href')
            outfile.write(' style-href=%s' % (quote_attrib(self.style_href), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:cpe2="http://cpe.mitre.org/language/2.0" ', name_='Benchmark', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for status_ in self.status:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            status_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='status', pretty_print=pretty_print)
        for dc_status_ in self.dc_status:
            namespaceprefix_ = self.dc_status_nsprefix_ + ':' if (UseCapturedNS_ and self.dc_status_nsprefix_) else ''
            dc_status_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dc-status', pretty_print=pretty_print)
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for notice_ in self.notice:
            namespaceprefix_ = self.notice_nsprefix_ + ':' if (UseCapturedNS_ and self.notice_nsprefix_) else ''
            notice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='notice', pretty_print=pretty_print)
        for front_matter_ in self.front_matter:
            namespaceprefix_ = self.front_matter_nsprefix_ + ':' if (UseCapturedNS_ and self.front_matter_nsprefix_) else ''
            front_matter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='front-matter', pretty_print=pretty_print)
        for rear_matter_ in self.rear_matter:
            namespaceprefix_ = self.rear_matter_nsprefix_ + ':' if (UseCapturedNS_ and self.rear_matter_nsprefix_) else ''
            rear_matter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rear-matter', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for plain_text_ in self.plain_text:
            namespaceprefix_ = self.plain_text_nsprefix_ + ':' if (UseCapturedNS_ and self.plain_text_nsprefix_) else ''
            plain_text_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plain-text', pretty_print=pretty_print)
        if self.platform_specification is not None:
            namespaceprefix_ = self.platform_specification_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_specification_nsprefix_) else ''
            self.platform_specification.export(outfile, level, namespaceprefix_='cpe2:', namespacedef_='', name_='platform-specification', pretty_print=pretty_print)
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            platform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='platform', pretty_print=pretty_print)
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
        for metadata_ in self.metadata:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            metadata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
        for model_ in self.model:
            namespaceprefix_ = self.model_nsprefix_ + ':' if (UseCapturedNS_ and self.model_nsprefix_) else ''
            model_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='model', pretty_print=pretty_print)
        for Profile_ in self.Profile:
            namespaceprefix_ = self.Profile_nsprefix_ + ':' if (UseCapturedNS_ and self.Profile_nsprefix_) else ''
            Profile_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='Profile', pretty_print=pretty_print)
        for Value_ in self.Value:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            Value_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='Value', pretty_print=pretty_print)
        for Group_ in self.Group:
            namespaceprefix_ = self.Group_nsprefix_ + ':' if (UseCapturedNS_ and self.Group_nsprefix_) else ''
            Group_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='Group', pretty_print=pretty_print)
        for Rule_ in self.Rule:
            namespaceprefix_ = self.Rule_nsprefix_ + ':' if (UseCapturedNS_ and self.Rule_nsprefix_) else ''
            Rule_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='Rule', pretty_print=pretty_print)
        for TestResult_ in self.TestResult:
            namespaceprefix_ = self.TestResult_nsprefix_ + ':' if (UseCapturedNS_ and self.TestResult_nsprefix_) else ''
            TestResult_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='TestResult', pretty_print=pretty_print)
        if self.signature is not None:
            namespaceprefix_ = self.signature_nsprefix_ + ':' if (UseCapturedNS_ and self.signature_nsprefix_) else ''
            self.signature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_benchmarkIdType(self.id)    # validate type benchmarkIdType
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('resolved', node)
        if value is not None and 'resolved' not in already_processed:
            already_processed.add('resolved')
            self.resolved = value
        value = find_attr_value_('style', node)
        if value is not None and 'style' not in already_processed:
            already_processed.add('style')
            self.style = value
        value = find_attr_value_('style-href', node)
        if value is not None and 'style-href' not in already_processed:
            already_processed.add('style-href')
            self.style_href = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'status':
            obj_ = status.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.status.append(obj_)
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'dc-status':
            obj_ = dc_statusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dc_status.append(obj_)
            obj_.original_tagname_ = 'dc-status'
        elif nodeName_ == 'title':
            obj_ = textType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, htmlTextWithSubType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'notice':
            obj_ = noticeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notice.append(obj_)
            obj_.original_tagname_ = 'notice'
        elif nodeName_ == 'front-matter':
            class_obj_ = self.get_class_obj_(child_, htmlTextWithSubType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.front_matter.append(obj_)
            obj_.original_tagname_ = 'front-matter'
        elif nodeName_ == 'rear-matter':
            class_obj_ = self.get_class_obj_(child_, htmlTextWithSubType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rear_matter.append(obj_)
            obj_.original_tagname_ = 'rear-matter'
        elif nodeName_ == 'reference':
            obj_ = referenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'plain-text':
            obj_ = plainTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.plain_text.append(obj_)
            obj_.original_tagname_ = 'plain-text'
        elif nodeName_ == 'platform-specification':
            obj_ = platformSpecificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platform_specification = obj_
            obj_.original_tagname_ = 'platform-specification'
        elif nodeName_ == 'platform':
            class_obj_ = self.get_class_obj_(child_, CPE2idrefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
        elif nodeName_ == 'version':
            obj_ = versionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'metadata':
            obj_ = metadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata.append(obj_)
            obj_.original_tagname_ = 'metadata'
        elif nodeName_ == 'model':
            obj_ = model.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.model.append(obj_)
            obj_.original_tagname_ = 'model'
        elif nodeName_ == 'Profile':
            obj_ = profileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Profile.append(obj_)
            obj_.original_tagname_ = 'Profile'
        elif nodeName_ == 'Value':
            obj_ = valueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'Group':
            obj_ = groupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Group.append(obj_)
            obj_.original_tagname_ = 'Group'
        elif nodeName_ == 'Rule':
            obj_ = ruleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Rule.append(obj_)
            obj_.original_tagname_ = 'Rule'
        elif nodeName_ == 'TestResult':
            obj_ = testResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TestResult.append(obj_)
            obj_.original_tagname_ = 'TestResult'
        elif nodeName_ == 'signature':
            obj_ = signatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature = obj_
            obj_.original_tagname_ = 'signature'
# end class Benchmark


class noticeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, base=None, lang=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.base = _cast(None, base)
        self.base_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noticeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noticeType.subclass:
            return noticeType.subclass(*args_, **kwargs_)
        else:
            return noticeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_base(self):
        return self.base
    def set_base(self, base):
        self.base = base
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='noticeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('noticeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'noticeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='noticeType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='noticeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.add('base')
            outfile.write(' xml:base=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.base), input_name='base')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='noticeType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.add('base')
            self.base = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class noticeType


class dc_statusType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dc_statusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dc_statusType.subclass:
            return dc_statusType.subclass(*args_, **kwargs_)
        else:
            return dc_statusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='dc-statusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dc-statusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dc-statusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dc-statusType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dc-statusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='dc-statusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='dc-statusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'dc-statusType')
        self.anytypeobjs_.append(content_)
# end class dc_statusType


class plainTextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, plainTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if plainTextType.subclass:
            return plainTextType.subclass(*args_, **kwargs_)
        else:
            return plainTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='plainTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('plainTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'plainTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='plainTextType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='plainTextType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='plainTextType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class plainTextType


class referenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, override=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.override = _cast(None, override)
        self.override_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referenceType.subclass:
            return referenceType.subclass(*args_, **kwargs_)
        else:
            return referenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_override(self):
        return self.override
    def set_override(self, override):
        self.override = override
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='referenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referenceType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='referenceType'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.override is not None and 'override' not in already_processed:
            already_processed.add('override')
            outfile.write(' override=%s' % (quote_attrib(self.override), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='referenceType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('override', node)
        if value is not None and 'override' not in already_processed:
            already_processed.add('override')
            self.override = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class referenceType


class signatureType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signatureType.subclass:
            return signatureType.subclass(*args_, **kwargs_)
        else:
            return signatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='signatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signatureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signatureType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='signatureType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='signatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'signatureType')
        self.set_anytypeobjs_(content_)
# end class signatureType


class metadataType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metadataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metadataType.subclass:
            return metadataType.subclass(*args_, **kwargs_)
        else:
            return metadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='metadataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('metadataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'metadataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='metadataType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='metadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='metadataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='metadataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'metadataType')
        self.anytypeobjs_.append(content_)
# end class metadataType


class status(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, date=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, status)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_statusType(self, value):
        result = True
        # Validate type statusType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['accepted', 'deprecated', 'draft', 'incomplete', 'interim']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on statusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='status', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('status')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'status':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='status')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='status'):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (quote_attrib(self.date), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='status', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class status


class model(GeneratedsSuper):
    """param -- Parameters provided as input to the
    designated scoring model.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, system=None, param=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        if param is None:
            self.param = []
        else:
            self.param = param
        self.param_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, model)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if model.subclass:
            return model.subclass(*args_, **kwargs_)
        else:
            return model(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_param(self):
        return self.param
    def set_param(self, param):
        self.param = param
    def add_param(self, value):
        self.param.append(value)
    def insert_param_at(self, index, value):
        self.param.insert(index, value)
    def replace_param_at(self, index, value):
        self.param[index] = value
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def has__content(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='model', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('model')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'model':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='model')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='model', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='model'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='model', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            namespaceprefix_ = self.param_nsprefix_ + ':' if (UseCapturedNS_ and self.param_nsprefix_) else ''
            param_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='param', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'param':
            obj_ = paramType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class model


class paramType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paramType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paramType.subclass:
            return paramType.subclass(*args_, **kwargs_)
        else:
            return paramType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='paramType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('paramType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'paramType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='paramType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='paramType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='paramType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class paramType


class versionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, time=None, update=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.time = _cast(None, time)
        self.time_nsprefix_ = None
        self.update = _cast(None, update)
        self.update_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, versionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if versionType.subclass:
            return versionType.subclass(*args_, **kwargs_)
        else:
            return versionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='versionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('versionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'versionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='versionType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='versionType'):
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (quote_attrib(self.time), ))
        if self.update is not None and 'update' not in already_processed:
            already_processed.add('update')
            outfile.write(' update=%s' % (quote_attrib(self.update), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='versionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            self.time = value
        value = find_attr_value_('update', node)
        if value is not None and 'update' not in already_processed:
            already_processed.add('update')
            self.update = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class versionType


class textType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, override='0', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.override = _cast(None, override)
        self.override_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, textType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if textType.subclass:
            return textType.subclass(*args_, **kwargs_)
        else:
            return textType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_override(self):
        return self.override
    def set_override(self, override):
        self.override = override
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='textType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('textType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'textType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='textType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='textType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.override != "0" and 'override' not in already_processed:
            already_processed.add('override')
            outfile.write(' override=%s' % (quote_attrib(self.override), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='textType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('override', node)
        if value is not None and 'override' not in already_processed:
            already_processed.add('override')
            self.override = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class textType


class htmlTextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, override='0', anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.override = _cast(None, override)
        self.override_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, htmlTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if htmlTextType.subclass:
            return htmlTextType.subclass(*args_, **kwargs_)
        else:
            return htmlTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_override(self):
        return self.override
    def set_override(self, override):
        self.override = override
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='htmlTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('htmlTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'htmlTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='htmlTextType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='htmlTextType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.override != "0" and 'override' not in already_processed:
            already_processed.add('override')
            outfile.write(' override=%s' % (quote_attrib(self.override), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='htmlTextType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('override', node)
        if value is not None and 'override' not in already_processed:
            already_processed.add('override')
            self.override = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class htmlTextType


class htmlTextWithSubType(GeneratedsSuper):
    """sub -- Specifies an
    <
    xccdf:Value
    >
    or
    <
    xccdf:plain-text
    >
    element to be used for text
    substitution
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, override='0', sub=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.override = _cast(None, override)
        self.override_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = "cdf"
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, htmlTextWithSubType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if htmlTextWithSubType.subclass:
            return htmlTextWithSubType.subclass(*args_, **kwargs_)
        else:
            return htmlTextWithSubType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_override(self):
        return self.override
    def set_override(self, override):
        self.override = override
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.sub or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='htmlTextWithSubType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('htmlTextWithSubType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'htmlTextWithSubType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='htmlTextWithSubType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='htmlTextWithSubType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.override != "0" and 'override' not in already_processed:
            already_processed.add('override')
            outfile.write(' override=%s' % (quote_attrib(self.override), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='htmlTextWithSubType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('override', node)
        if value is not None and 'override' not in already_processed:
            already_processed.add('override')
            self.override = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sub':
            obj_ = subType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class htmlTextWithSubType


class profileNoteType(GeneratedsSuper):
    """sub -- Specifies an
    <
    xccdf:Value
    >
    or
    <
    xccdf:plain-text
    >
    element to be used for text
    substitution
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, tag=None, sub=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = "cdf"
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, profileNoteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if profileNoteType.subclass:
            return profileNoteType.subclass(*args_, **kwargs_)
        else:
            return profileNoteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.sub or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='profileNoteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('profileNoteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'profileNoteType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profileNoteType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='profileNoteType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (quote_attrib(self.tag), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='profileNoteType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sub':
            obj_ = subType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class profileNoteType


class textWithSubType(GeneratedsSuper):
    """sub -- Specifies an
    <
    xccdf:Value
    >
    or
    <
    xccdf:plain-text
    >
    element to be used for text substitution.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, override='0', sub=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.override = _cast(None, override)
        self.override_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = "cdf"
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, textWithSubType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if textWithSubType.subclass:
            return textWithSubType.subclass(*args_, **kwargs_)
        else:
            return textWithSubType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_override(self):
        return self.override
    def set_override(self, override):
        self.override = override
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.sub or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='textWithSubType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('textWithSubType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'textWithSubType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='textWithSubType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='textWithSubType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.override != "0" and 'override' not in already_processed:
            already_processed.add('override')
            outfile.write(' override=%s' % (quote_attrib(self.override), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='textWithSubType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('override', node)
        if value is not None and 'override' not in already_processed:
            already_processed.add('override')
            self.override = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sub':
            obj_ = subType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class textWithSubType


class idrefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idrefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idrefType.subclass:
            return idrefType.subclass(*args_, **kwargs_)
        else:
            return idrefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='idrefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idrefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'idrefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='idrefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='idrefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='idrefType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='idrefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class idrefType


class idrefListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idrefListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idrefListType.subclass:
            return idrefListType.subclass(*args_, **kwargs_)
        else:
            return idrefListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='idrefListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idrefListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'idrefListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='idrefListType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='idrefListType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='idrefListType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='idrefListType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class idrefListType


class CPE2idrefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CPE2idrefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CPE2idrefType.subclass:
            return CPE2idrefType.subclass(*args_, **kwargs_)
        else:
            return CPE2idrefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='CPE2idrefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CPE2idrefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CPE2idrefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CPE2idrefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CPE2idrefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='CPE2idrefType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='CPE2idrefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CPE2idrefType


class overrideableCPE2idrefType(CPE2idrefType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CPE2idrefType
    def __init__(self, idref=None, override='0', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        super(globals().get("overrideableCPE2idrefType"), self).__init__(idref,  **kwargs_)
        self.override = _cast(None, override)
        self.override_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, overrideableCPE2idrefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if overrideableCPE2idrefType.subclass:
            return overrideableCPE2idrefType.subclass(*args_, **kwargs_)
        else:
            return overrideableCPE2idrefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_override(self):
        return self.override
    def set_override(self, override):
        self.override = override
    def has__content(self):
        if (
            super(overrideableCPE2idrefType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='overrideableCPE2idrefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('overrideableCPE2idrefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'overrideableCPE2idrefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='overrideableCPE2idrefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='overrideableCPE2idrefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='overrideableCPE2idrefType'):
        super(overrideableCPE2idrefType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='overrideableCPE2idrefType')
        if self.override != "0" and 'override' not in already_processed:
            already_processed.add('override')
            outfile.write(' override=%s' % (quote_attrib(self.override), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='overrideableCPE2idrefType', fromsubclass_=False, pretty_print=True):
        super(overrideableCPE2idrefType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('override', node)
        if value is not None and 'override' not in already_processed:
            already_processed.add('override')
            self.override = value
        super(overrideableCPE2idrefType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(overrideableCPE2idrefType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class overrideableCPE2idrefType


class itemType(GeneratedsSuper):
    """status -- Status of the item and date at which it
    attained that status.
    <
    xccdf:Benchmark
    >
    authors may use this element
    to record the maturity or consensus level for elements in the
    <
    xccdf:Benchmark
    >
    . If an item does not have an explicit
    <
    xccdf:status
    >
    given, then its status is that of its
    parent.
    dc-status -- Holds additional status information using the
    Dublin Core format.
    version -- Version information about this item.
      
    * title -- Title of the item. Every item should have an
      <
      xccdf:title
      >
      , because this helps people understand the purpose of the
      item.
    * description -- Text that describes the item.
      
    * warning -- A note or caveat about the item intended to
      convey important cautionary information for the
      <
      xccdf:Benchmark
      >
      user
      (e.g.,
      
      Complying with this rule will cause the system to reject all IP
      packets
      
      ). If multiple
      <
      xccdf:warning
      >
      elements appear, benchmark
      consumers should concatenate them for generating reports or documents.
      Benchmark consumers may present this information in a special manner in
      generated documents.
    * question -- Interrogative text to present to the user
      during tailoring. It may also be included into a generated document. For
      <
      xccdf:Rule
      >
      and
      <
      xccdf:Group
      >
      elements, the
      <
      xccdf:question
      >
      text should be a simple binary (yes/no) question
      because it is supporting the selection aspect of tailoring. For
      <
      xccdf:Value
      >
      elements, the
      <
      xccdf:question
      >
      should solicit the
      user to provide a specific value. Tools may also display constraints on
      values and any defaults as specified by the other
      <
      xccdf:Value
      >
      properties.
    * reference -- References where the user can learn more about
      the subject of this item.
    * metadata -- XML metadata associated with this item, such as
      sources, special information, or other details.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, abstract='false', cluster_id=None, extends=None, hidden='false', prohibitChanges='false', lang=None, base=None, Id=None, status=None, dc_status=None, version=None, title=None, description=None, warning=None, question=None, reference=None, metadata=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.abstract = _cast(None, abstract)
        self.abstract_nsprefix_ = None
        self.cluster_id = _cast(None, cluster_id)
        self.cluster_id_nsprefix_ = None
        self.extends = _cast(None, extends)
        self.extends_nsprefix_ = None
        self.hidden = _cast(None, hidden)
        self.hidden_nsprefix_ = None
        self.prohibitChanges = _cast(None, prohibitChanges)
        self.prohibitChanges_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.base = _cast(None, base)
        self.base_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        if status is None:
            self.status = []
        else:
            self.status = status
        self.status_nsprefix_ = "cdf"
        if dc_status is None:
            self.dc_status = []
        else:
            self.dc_status = dc_status
        self.dc_status_nsprefix_ = "cdf"
        self.version = version
        self.version_nsprefix_ = "cdf"
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = "cdf"
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = "cdf"
        if warning is None:
            self.warning = []
        else:
            self.warning = warning
        self.warning_nsprefix_ = "cdf"
        if question is None:
            self.question = []
        else:
            self.question = question
        self.question_nsprefix_ = "cdf"
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = "cdf"
        if metadata is None:
            self.metadata = []
        else:
            self.metadata = metadata
        self.metadata_nsprefix_ = "cdf"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, itemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if itemType.subclass:
            return itemType.subclass(*args_, **kwargs_)
        else:
            return itemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def add_status(self, value):
        self.status.append(value)
    def insert_status_at(self, index, value):
        self.status.insert(index, value)
    def replace_status_at(self, index, value):
        self.status[index] = value
    def get_dc_status(self):
        return self.dc_status
    def set_dc_status(self, dc_status):
        self.dc_status = dc_status
    def add_dc_status(self, value):
        self.dc_status.append(value)
    def insert_dc_status_at(self, index, value):
        self.dc_status.insert(index, value)
    def replace_dc_status_at(self, index, value):
        self.dc_status[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_warning(self):
        return self.warning
    def set_warning(self, warning):
        self.warning = warning
    def add_warning(self, value):
        self.warning.append(value)
    def insert_warning_at(self, index, value):
        self.warning.insert(index, value)
    def replace_warning_at(self, index, value):
        self.warning[index] = value
    def get_question(self):
        return self.question
    def set_question(self, question):
        self.question = question
    def add_question(self, value):
        self.question.append(value)
    def insert_question_at(self, index, value):
        self.question.insert(index, value)
    def replace_question_at(self, index, value):
        self.question[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def add_metadata(self, value):
        self.metadata.append(value)
    def insert_metadata_at(self, index, value):
        self.metadata.insert(index, value)
    def replace_metadata_at(self, index, value):
        self.metadata[index] = value
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def get_cluster_id(self):
        return self.cluster_id
    def set_cluster_id(self, cluster_id):
        self.cluster_id = cluster_id
    def get_extends(self):
        return self.extends
    def set_extends(self, extends):
        self.extends = extends
    def get_hidden(self):
        return self.hidden
    def set_hidden(self, hidden):
        self.hidden = hidden
    def get_prohibitChanges(self):
        return self.prohibitChanges
    def set_prohibitChanges(self, prohibitChanges):
        self.prohibitChanges = prohibitChanges
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_base(self):
        return self.base
    def set_base(self, base):
        self.base = base
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.status or
            self.dc_status or
            self.version is not None or
            self.title or
            self.description or
            self.warning or
            self.question or
            self.reference or
            self.metadata
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='itemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('itemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'itemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='itemType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='itemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='itemType'):
        if self.abstract != "false" and 'abstract' not in already_processed:
            already_processed.add('abstract')
            outfile.write(' abstract=%s' % (quote_attrib(self.abstract), ))
        if self.cluster_id is not None and 'cluster_id' not in already_processed:
            already_processed.add('cluster_id')
            outfile.write(' cluster-id=%s' % (quote_attrib(self.cluster_id), ))
        if self.extends is not None and 'extends' not in already_processed:
            already_processed.add('extends')
            outfile.write(' extends=%s' % (quote_attrib(self.extends), ))
        if self.hidden != "false" and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden=%s' % (quote_attrib(self.hidden), ))
        if self.prohibitChanges != "false" and 'prohibitChanges' not in already_processed:
            already_processed.add('prohibitChanges')
            outfile.write(' prohibitChanges=%s' % (quote_attrib(self.prohibitChanges), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.add('base')
            outfile.write(' xml:base=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.base), input_name='base')), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='itemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for status_ in self.status:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            status_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='status', pretty_print=pretty_print)
        for dc_status_ in self.dc_status:
            namespaceprefix_ = self.dc_status_nsprefix_ + ':' if (UseCapturedNS_ and self.dc_status_nsprefix_) else ''
            dc_status_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dc-status', pretty_print=pretty_print)
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for warning_ in self.warning:
            namespaceprefix_ = self.warning_nsprefix_ + ':' if (UseCapturedNS_ and self.warning_nsprefix_) else ''
            warning_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='warning', pretty_print=pretty_print)
        for question_ in self.question:
            namespaceprefix_ = self.question_nsprefix_ + ':' if (UseCapturedNS_ and self.question_nsprefix_) else ''
            question_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='question', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for metadata_ in self.metadata:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            metadata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('abstract', node)
        if value is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            self.abstract = value
        value = find_attr_value_('cluster-id', node)
        if value is not None and 'cluster-id' not in already_processed:
            already_processed.add('cluster-id')
            self.cluster_id = value
        value = find_attr_value_('extends', node)
        if value is not None and 'extends' not in already_processed:
            already_processed.add('extends')
            self.extends = value
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            self.hidden = value
        value = find_attr_value_('prohibitChanges', node)
        if value is not None and 'prohibitChanges' not in already_processed:
            already_processed.add('prohibitChanges')
            self.prohibitChanges = value
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.add('base')
            self.base = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'status':
            obj_ = status.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.status.append(obj_)
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'dc-status':
            obj_ = dc_statusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dc_status.append(obj_)
            obj_.original_tagname_ = 'dc-status'
        elif nodeName_ == 'version':
            obj_ = versionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'title':
            obj_ = textWithSubType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, htmlTextWithSubType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'warning':
            obj_ = warningType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.warning.append(obj_)
            obj_.original_tagname_ = 'warning'
        elif nodeName_ == 'question':
            obj_ = textType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'question'
        elif nodeName_ == 'boolean_question':
            obj_ = BooleanQuestionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'boolean_question'
        elif nodeName_ == 'choice_question':
            obj_ = ChoiceQuestionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'choice_question'
        elif nodeName_ == 'numeric_question':
            obj_ = NumericQuestionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'numeric_question'
        elif nodeName_ == 'string_question':
            obj_ = StringQuestionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'string_question'
        elif nodeName_ == 'reference':
            obj_ = referenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'metadata':
            obj_ = metadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata.append(obj_)
            obj_.original_tagname_ = 'metadata'
# end class itemType


class selectableItemType(itemType):
    """rationale -- Descriptive text giving rationale or
    motivations for abiding by this
    <
    xccdf:Group
    >
    /
    <
    xccdf:Rule
    >
    (i.e., why it is important to
    the security of the target platform).
    platform -- Platforms to which this
    <
    xccdf:Group
    >
    /
    <
    xccdf:Rule
    >
    applies.
    requires -- The identifiers of other
    <
    xccdf:Group
    >
    or
    <
    xccdf:Rule
    >
    elements that must be
    selected for this
    <
    xccdf:Group
    >
    /
    <
    xccdf:Rule
    >
    to be
    evaluated and scored properly. Each
    <
    xccdf:requires
    >
    element
    specifies a list of one or more required items by their identifiers.
    If at least one of the specified
    <
    xccdf:Group
    >
    or
    <
    xccdf:Rule
    >
    elements is selected, the requirement is met.
      
    * conflicts -- The identifier of another
      <
      xccdf:Group
      >
      or
      <
      xccdf:Rule
      >
      that must be unselected
      for this
      <
      xccdf:Group
      >
      /
      <
      xccdf:Rule
      >
      to be evaluated and
      scored properly. Each
      <
      xccdf:conflicts
      >
      element specifies a
      single conflicting item using its idref attribute. If the specified
      <
      xccdf:Group
      >
      or
      <
      xccdf:Rule
      >
      element is not selected,
      the requirement is met.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = itemType
    def __init__(self, abstract='false', cluster_id=None, extends=None, hidden='false', prohibitChanges='false', lang=None, base=None, Id=None, status=None, dc_status=None, version=None, title=None, description=None, warning=None, question=None, reference=None, metadata=None, selected='true', weight='1.0', rationale=None, platform=None, requires=None, conflicts=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        super(globals().get("selectableItemType"), self).__init__(abstract, cluster_id, extends, hidden, prohibitChanges, lang, base, Id, status, dc_status, version, title, description, warning, question, reference, metadata, extensiontype_,  **kwargs_)
        self.selected = _cast(None, selected)
        self.selected_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        if rationale is None:
            self.rationale = []
        else:
            self.rationale = rationale
        self.rationale_nsprefix_ = "cdf"
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = "cdf"
        if requires is None:
            self.requires = []
        else:
            self.requires = requires
        self.requires_nsprefix_ = "cdf"
        if conflicts is None:
            self.conflicts = []
        else:
            self.conflicts = conflicts
        self.conflicts_nsprefix_ = "cdf"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, selectableItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if selectableItemType.subclass:
            return selectableItemType.subclass(*args_, **kwargs_)
        else:
            return selectableItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rationale(self):
        return self.rationale
    def set_rationale(self, rationale):
        self.rationale = rationale
    def add_rationale(self, value):
        self.rationale.append(value)
    def insert_rationale_at(self, index, value):
        self.rationale.insert(index, value)
    def replace_rationale_at(self, index, value):
        self.rationale[index] = value
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def add_platform(self, value):
        self.platform.append(value)
    def insert_platform_at(self, index, value):
        self.platform.insert(index, value)
    def replace_platform_at(self, index, value):
        self.platform[index] = value
    def get_requires(self):
        return self.requires
    def set_requires(self, requires):
        self.requires = requires
    def add_requires(self, value):
        self.requires.append(value)
    def insert_requires_at(self, index, value):
        self.requires.insert(index, value)
    def replace_requires_at(self, index, value):
        self.requires[index] = value
    def get_conflicts(self):
        return self.conflicts
    def set_conflicts(self, conflicts):
        self.conflicts = conflicts
    def add_conflicts(self, value):
        self.conflicts.append(value)
    def insert_conflicts_at(self, index, value):
        self.conflicts.insert(index, value)
    def replace_conflicts_at(self, index, value):
        self.conflicts[index] = value
    def get_selected(self):
        return self.selected
    def set_selected(self, selected):
        self.selected = selected
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_weightType(self, value):
        # Validate type cdf:weightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on weightType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on weightType' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.rationale or
            self.platform or
            self.requires or
            self.conflicts or
            super(selectableItemType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='selectableItemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('selectableItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'selectableItemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selectableItemType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='selectableItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='selectableItemType'):
        super(selectableItemType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selectableItemType')
        if self.selected != "true" and 'selected' not in already_processed:
            already_processed.add('selected')
            outfile.write(' selected=%s' % (quote_attrib(self.selected), ))
        if self.weight != "1.0" and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (quote_attrib(self.weight), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='selectableItemType', fromsubclass_=False, pretty_print=True):
        super(selectableItemType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rationale_ in self.rationale:
            namespaceprefix_ = self.rationale_nsprefix_ + ':' if (UseCapturedNS_ and self.rationale_nsprefix_) else ''
            rationale_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rationale', pretty_print=pretty_print)
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            platform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='platform', pretty_print=pretty_print)
        for requires_ in self.requires:
            namespaceprefix_ = self.requires_nsprefix_ + ':' if (UseCapturedNS_ and self.requires_nsprefix_) else ''
            requires_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='requires', pretty_print=pretty_print)
        for conflicts_ in self.conflicts:
            namespaceprefix_ = self.conflicts_nsprefix_ + ':' if (UseCapturedNS_ and self.conflicts_nsprefix_) else ''
            conflicts_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conflicts', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('selected', node)
        if value is not None and 'selected' not in already_processed:
            already_processed.add('selected')
            self.selected = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_weightType(self.weight)    # validate type weightType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(selectableItemType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rationale':
            class_obj_ = self.get_class_obj_(child_, htmlTextWithSubType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rationale.append(obj_)
            obj_.original_tagname_ = 'rationale'
        elif nodeName_ == 'platform':
            obj_ = overrideableCPE2idrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
        elif nodeName_ == 'requires':
            obj_ = idrefListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requires.append(obj_)
            obj_.original_tagname_ = 'requires'
        elif nodeName_ == 'conflicts':
            class_obj_ = self.get_class_obj_(child_, idrefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conflicts.append(obj_)
            obj_.original_tagname_ = 'conflicts'
        super(selectableItemType, self)._buildChildren(child_, node, nodeName_, True)
# end class selectableItemType


class groupType(selectableItemType):
    """Value -- <
    xccdf:Value
    >
    elements that
    belong to this
    <
    xccdf:Group
    >
    .
    Group -- Sub-
    <
    xccdf:Groups
    >
    under this
    <
    xccdf:Group
    >
    .
    Rule -- <
    xccdf:Rule
    >
    elements that
    belong to this
    <
    xccdf:Group
    >
    .
    signature -- A digital signature asserting
    authorship and allowing verification of the integrity of the
    <
    xccdf:Group
    >
    .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = selectableItemType
    def __init__(self, abstract='false', cluster_id=None, extends=None, hidden='false', prohibitChanges='false', lang=None, base=None, Id=None, status=None, dc_status=None, version=None, title=None, description=None, warning=None, question=None, reference=None, metadata=None, selected='true', weight='1.0', rationale=None, platform=None, requires=None, conflicts=None, id=None, Value=None, Group=None, Rule=None, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        super(globals().get("groupType"), self).__init__(abstract, cluster_id, extends, hidden, prohibitChanges, lang, base, Id, status, dc_status, version, title, description, warning, question, reference, metadata, selected, weight, rationale, platform, requires, conflicts,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.Value_nsprefix_ = "cdf"
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
        self.Group_nsprefix_ = "cdf"
        if Rule is None:
            self.Rule = []
        else:
            self.Rule = Rule
        self.Rule_nsprefix_ = "cdf"
        self.signature = signature
        self.signature_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType.subclass:
            return groupType.subclass(*args_, **kwargs_)
        else:
            return groupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Value(self):
        return self.Value
    def set_Value(self, Value):
        self.Value = Value
    def add_Value(self, value):
        self.Value.append(value)
    def insert_Value_at(self, index, value):
        self.Value.insert(index, value)
    def replace_Value_at(self, index, value):
        self.Value[index] = value
    def get_Group(self):
        return self.Group
    def set_Group(self, Group):
        self.Group = Group
    def add_Group(self, value):
        self.Group.append(value)
    def insert_Group_at(self, index, value):
        self.Group.insert(index, value)
    def replace_Group_at(self, index, value):
        self.Group[index] = value
    def get_Rule(self):
        return self.Rule
    def set_Rule(self, Rule):
        self.Rule = Rule
    def add_Rule(self, value):
        self.Rule.append(value)
    def insert_Rule_at(self, index, value):
        self.Rule.insert(index, value)
    def replace_Rule_at(self, index, value):
        self.Rule[index] = value
    def get_signature(self):
        return self.signature
    def set_signature(self, signature):
        self.signature = signature
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_groupIdType(self, value):
        # Validate type cdf:groupIdType, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_groupIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_groupIdType_patterns_, ))
    validate_groupIdType_patterns_ = [['^(xccdf_[^_]+_group_.+)$']]
    def has__content(self):
        if (
            self.Value or
            self.Group or
            self.Rule or
            self.signature is not None or
            super(groupType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='groupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'groupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='groupType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='groupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='groupType'):
        super(groupType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='groupType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='groupType', fromsubclass_=False, pretty_print=True):
        super(groupType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Value_ in self.Value:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            Value_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='Value', pretty_print=pretty_print)
        for Group_ in self.Group:
            namespaceprefix_ = self.Group_nsprefix_ + ':' if (UseCapturedNS_ and self.Group_nsprefix_) else ''
            Group_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='Group', pretty_print=pretty_print)
        for Rule_ in self.Rule:
            namespaceprefix_ = self.Rule_nsprefix_ + ':' if (UseCapturedNS_ and self.Rule_nsprefix_) else ''
            Rule_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='Rule', pretty_print=pretty_print)
        if self.signature is not None:
            namespaceprefix_ = self.signature_nsprefix_ + ':' if (UseCapturedNS_ and self.signature_nsprefix_) else ''
            self.signature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_groupIdType(self.id)    # validate type groupIdType
        super(groupType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Value':
            obj_ = valueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'Group':
            obj_ = groupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Group.append(obj_)
            obj_.original_tagname_ = 'Group'
        elif nodeName_ == 'Rule':
            obj_ = ruleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Rule.append(obj_)
            obj_.original_tagname_ = 'Rule'
        elif nodeName_ == 'signature':
            obj_ = signatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature = obj_
            obj_.original_tagname_ = 'signature'
        super(groupType, self)._buildChildren(child_, node, nodeName_, True)
# end class groupType


class ruleType(selectableItemType):
    """ident -- A globally meaningful identifier for
    this
    <
    xccdf:Rule
    >
    . This may be the name or identifier of a
    security configuration issue or vulnerability that the
    <
    xccdf:Rule
    >
    assesses.
    impact-metric -- The potential impact of failure to
    conform to the
    <
    xccdf:Rule
    >
    , expressed as a CVSS 2.0 base
    vector.
    profile-note -- Text that describes special aspects of
    the
    <
    xccdf:Rule
    >
    related to one or more
    <
    xccdf:Profile
    >
    elements. This allows an author to document things within
    <
    xccdf:Rule
    >
    elements that are specific to a given
    <
    xccdf:Profile
    >
    , and then select the appropriate text based on
    the selected
    <
    xccdf:Profile
    >
    and display it to the
    reader.
    fixtext -- Data that describes how to bring a
    target system into compliance with this
    <
    xccdf:Rule
    >
    .
    fix -- A command string, script, or other
    system modification statement that, if executed on the target
    system, can bring it into full, or at least better, compliance with
    this
    <
    xccdf:Rule
    >
    .
    check -- The definition of, or a reference
    to, the target system check needed to test compliance with this
    <
    xccdf:Rule
    >
    . Sibling
    <
    xccdf:check
    >
    elements must
    have different values for the combination of their @selector and
    @system attributes, and must have different values for their @id
    attribute (if any).
    complex-check -- A boolean expression composed of
    operators (and, or, not) and individual
    checks.
    signature -- A digital signature asserting
    authorship and allowing verification of the integrity of the
    <
    xccdf:Rule
    >
    .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = selectableItemType
    def __init__(self, abstract='false', cluster_id=None, extends=None, hidden='false', prohibitChanges='false', lang=None, base=None, Id=None, status=None, dc_status=None, version=None, title=None, description=None, warning=None, question=None, reference=None, metadata=None, selected='true', weight='1.0', rationale=None, platform=None, requires=None, conflicts=None, id=None, role='full', severity='unknown', multiple='false', ident=None, impact_metric=None, profile_note=None, fixtext=None, fix=None, check=None, complex_check=None, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ruleType"), self).__init__(abstract, cluster_id, extends, hidden, prohibitChanges, lang, base, Id, status, dc_status, version, title, description, warning, question, reference, metadata, selected, weight, rationale, platform, requires, conflicts,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.severity = _cast(None, severity)
        self.severity_nsprefix_ = None
        self.multiple = _cast(None, multiple)
        self.multiple_nsprefix_ = None
        if ident is None:
            self.ident = []
        else:
            self.ident = ident
        self.ident_nsprefix_ = "cdf"
        self.impact_metric = impact_metric
        self.impact_metric_nsprefix_ = None
        if profile_note is None:
            self.profile_note = []
        else:
            self.profile_note = profile_note
        self.profile_note_nsprefix_ = "cdf"
        if fixtext is None:
            self.fixtext = []
        else:
            self.fixtext = fixtext
        self.fixtext_nsprefix_ = "cdf"
        if fix is None:
            self.fix = []
        else:
            self.fix = fix
        self.fix_nsprefix_ = "cdf"
        if check is None:
            self.check = []
        else:
            self.check = check
        self.check_nsprefix_ = "cdf"
        self.complex_check = complex_check
        self.complex_check_nsprefix_ = "cdf"
        self.signature = signature
        self.signature_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ruleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ruleType.subclass:
            return ruleType.subclass(*args_, **kwargs_)
        else:
            return ruleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ident(self):
        return self.ident
    def set_ident(self, ident):
        self.ident = ident
    def add_ident(self, value):
        self.ident.append(value)
    def insert_ident_at(self, index, value):
        self.ident.insert(index, value)
    def replace_ident_at(self, index, value):
        self.ident[index] = value
    def get_impact_metric(self):
        return self.impact_metric
    def set_impact_metric(self, impact_metric):
        self.impact_metric = impact_metric
    def get_profile_note(self):
        return self.profile_note
    def set_profile_note(self, profile_note):
        self.profile_note = profile_note
    def add_profile_note(self, value):
        self.profile_note.append(value)
    def insert_profile_note_at(self, index, value):
        self.profile_note.insert(index, value)
    def replace_profile_note_at(self, index, value):
        self.profile_note[index] = value
    def get_fixtext(self):
        return self.fixtext
    def set_fixtext(self, fixtext):
        self.fixtext = fixtext
    def add_fixtext(self, value):
        self.fixtext.append(value)
    def insert_fixtext_at(self, index, value):
        self.fixtext.insert(index, value)
    def replace_fixtext_at(self, index, value):
        self.fixtext[index] = value
    def get_fix(self):
        return self.fix
    def set_fix(self, fix):
        self.fix = fix
    def add_fix(self, value):
        self.fix.append(value)
    def insert_fix_at(self, index, value):
        self.fix.insert(index, value)
    def replace_fix_at(self, index, value):
        self.fix[index] = value
    def get_check(self):
        return self.check
    def set_check(self, check):
        self.check = check
    def add_check(self, value):
        self.check.append(value)
    def insert_check_at(self, index, value):
        self.check.insert(index, value)
    def replace_check_at(self, index, value):
        self.check[index] = value
    def get_complex_check(self):
        return self.complex_check
    def set_complex_check(self, complex_check):
        self.complex_check = complex_check
    def get_signature(self):
        return self.signature
    def set_signature(self, signature):
        self.signature = signature
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_severity(self):
        return self.severity
    def set_severity(self, severity):
        self.severity = severity
    def get_multiple(self):
        return self.multiple
    def set_multiple(self, multiple):
        self.multiple = multiple
    def validate_ruleIdType(self, value):
        # Validate type cdf:ruleIdType, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ruleIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ruleIdType_patterns_, ))
    validate_ruleIdType_patterns_ = [['^(xccdf_[^_]+_rule_.+)$']]
    def validate_roleEnumType(self, value):
        # Validate type cdf:roleEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['full', 'unscored', 'unchecked']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on roleEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_severityEnumType(self, value):
        # Validate type cdf:severityEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['unknown', 'info', 'low', 'medium', 'high']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on severityEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.ident or
            self.impact_metric is not None or
            self.profile_note or
            self.fixtext or
            self.fix or
            self.check or
            self.complex_check is not None or
            self.signature is not None or
            super(ruleType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ruleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ruleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ruleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ruleType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ruleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='ruleType'):
        super(ruleType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ruleType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.role != "full" and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.severity != "unknown" and 'severity' not in already_processed:
            already_processed.add('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
        if self.multiple != "false" and 'multiple' not in already_processed:
            already_processed.add('multiple')
            outfile.write(' multiple=%s' % (quote_attrib(self.multiple), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ruleType', fromsubclass_=False, pretty_print=True):
        super(ruleType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ident_ in self.ident:
            namespaceprefix_ = self.ident_nsprefix_ + ':' if (UseCapturedNS_ and self.ident_nsprefix_) else ''
            ident_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ident', pretty_print=pretty_print)
        if self.impact_metric is not None:
            namespaceprefix_ = self.impact_metric_nsprefix_ + ':' if (UseCapturedNS_ and self.impact_metric_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simpact-metric>%s</%simpact-metric>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.impact_metric), input_name='impact-metric')), namespaceprefix_ , eol_))
        for profile_note_ in self.profile_note:
            namespaceprefix_ = self.profile_note_nsprefix_ + ':' if (UseCapturedNS_ and self.profile_note_nsprefix_) else ''
            profile_note_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='profile-note', pretty_print=pretty_print)
        for fixtext_ in self.fixtext:
            namespaceprefix_ = self.fixtext_nsprefix_ + ':' if (UseCapturedNS_ and self.fixtext_nsprefix_) else ''
            fixtext_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fixtext', pretty_print=pretty_print)
        for fix_ in self.fix:
            namespaceprefix_ = self.fix_nsprefix_ + ':' if (UseCapturedNS_ and self.fix_nsprefix_) else ''
            fix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fix', pretty_print=pretty_print)
        for check_ in self.check:
            namespaceprefix_ = self.check_nsprefix_ + ':' if (UseCapturedNS_ and self.check_nsprefix_) else ''
            check_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='check', pretty_print=pretty_print)
        if self.complex_check is not None:
            namespaceprefix_ = self.complex_check_nsprefix_ + ':' if (UseCapturedNS_ and self.complex_check_nsprefix_) else ''
            self.complex_check.export(outfile, level, namespaceprefix_, namespacedef_='', name_='complex-check', pretty_print=pretty_print)
        if self.signature is not None:
            namespaceprefix_ = self.signature_nsprefix_ + ':' if (UseCapturedNS_ and self.signature_nsprefix_) else ''
            self.signature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ruleIdType(self.id)    # validate type ruleIdType
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.validate_roleEnumType(self.role)    # validate type roleEnumType
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            self.severity = value
            self.validate_severityEnumType(self.severity)    # validate type severityEnumType
        value = find_attr_value_('multiple', node)
        if value is not None and 'multiple' not in already_processed:
            already_processed.add('multiple')
            self.multiple = value
        super(ruleType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ident':
            obj_ = identType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ident.append(obj_)
            obj_.original_tagname_ = 'ident'
        elif nodeName_ == 'impact-metric':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'impact_metric')
            value_ = self.gds_validate_string(value_, node, 'impact_metric')
            self.impact_metric = value_
            self.impact_metric_nsprefix_ = child_.prefix
        elif nodeName_ == 'profile-note':
            obj_ = profileNoteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.profile_note.append(obj_)
            obj_.original_tagname_ = 'profile-note'
        elif nodeName_ == 'fixtext':
            obj_ = fixTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fixtext.append(obj_)
            obj_.original_tagname_ = 'fixtext'
        elif nodeName_ == 'fix':
            obj_ = fixType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fix.append(obj_)
            obj_.original_tagname_ = 'fix'
        elif nodeName_ == 'check':
            obj_ = checkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check.append(obj_)
            obj_.original_tagname_ = 'check'
        elif nodeName_ == 'complex-check':
            obj_ = complexCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.complex_check = obj_
            obj_.original_tagname_ = 'complex-check'
        elif nodeName_ == 'signature':
            obj_ = signatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature = obj_
            obj_.original_tagname_ = 'signature'
        super(ruleType, self)._buildChildren(child_, node, nodeName_, True)
# end class ruleType


class identType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, system=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, identType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if identType.subclass:
            return identType.subclass(*args_, **kwargs_)
        else:
            return identType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='identType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('identType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'identType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='identType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='identType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='identType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class identType


class warningType(htmlTextWithSubType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = htmlTextWithSubType
    def __init__(self, lang=None, override='0', sub=None, anytypeobjs_=None, category='general', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        super(globals().get("warningType"), self).__init__(lang, override, sub, anytypeobjs_, valueOf_, mixedclass_, content_,  **kwargs_)
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, warningType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if warningType.subclass:
            return warningType.subclass(*args_, **kwargs_)
        else:
            return warningType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_warningCategoryEnumType(self, value):
        # Validate type cdf:warningCategoryEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['general', 'functionality', 'performance', 'hardware', 'legal', 'regulatory', 'management', 'audit', 'dependency']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on warningCategoryEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(warningType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='warningType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('warningType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'warningType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='warningType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='warningType'):
        super(warningType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='warningType')
        if self.category != "general" and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (quote_attrib(self.category), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='warningType', fromsubclass_=False, pretty_print=True):
        super(warningType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_warningCategoryEnumType(self.category)    # validate type warningCategoryEnumType
        super(warningType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(warningType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class warningType


class fixTextType(htmlTextWithSubType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = htmlTextWithSubType
    def __init__(self, lang=None, override='0', sub=None, anytypeobjs_=None, fixref=None, reboot='0', strategy='unknown', disruption='unknown', complexity='unknown', valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        super(globals().get("fixTextType"), self).__init__(lang, override, sub, anytypeobjs_, valueOf_, mixedclass_, content_,  **kwargs_)
        self.fixref = _cast(None, fixref)
        self.fixref_nsprefix_ = None
        self.reboot = _cast(None, reboot)
        self.reboot_nsprefix_ = None
        self.strategy = _cast(None, strategy)
        self.strategy_nsprefix_ = None
        self.disruption = _cast(None, disruption)
        self.disruption_nsprefix_ = None
        self.complexity = _cast(None, complexity)
        self.complexity_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fixTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fixTextType.subclass:
            return fixTextType.subclass(*args_, **kwargs_)
        else:
            return fixTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fixref(self):
        return self.fixref
    def set_fixref(self, fixref):
        self.fixref = fixref
    def get_reboot(self):
        return self.reboot
    def set_reboot(self, reboot):
        self.reboot = reboot
    def get_strategy(self):
        return self.strategy
    def set_strategy(self, strategy):
        self.strategy = strategy
    def get_disruption(self):
        return self.disruption
    def set_disruption(self, disruption):
        self.disruption = disruption
    def get_complexity(self):
        return self.complexity
    def set_complexity(self, complexity):
        self.complexity = complexity
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_fixStrategyEnumType(self, value):
        # Validate type cdf:fixStrategyEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['unknown', 'configure', 'combination', 'disable', 'enable', 'patch', 'policy', 'restrict', 'update']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on fixStrategyEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ratingEnumType(self, value):
        # Validate type cdf:ratingEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['unknown', 'low', 'medium', 'high']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ratingEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(fixTextType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='fixTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fixTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fixTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fixTextType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='fixTextType'):
        super(fixTextType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fixTextType')
        if self.fixref is not None and 'fixref' not in already_processed:
            already_processed.add('fixref')
            outfile.write(' fixref=%s' % (quote_attrib(self.fixref), ))
        if self.reboot != "0" and 'reboot' not in already_processed:
            already_processed.add('reboot')
            outfile.write(' reboot=%s' % (quote_attrib(self.reboot), ))
        if self.strategy != "unknown" and 'strategy' not in already_processed:
            already_processed.add('strategy')
            outfile.write(' strategy=%s' % (quote_attrib(self.strategy), ))
        if self.disruption != "unknown" and 'disruption' not in already_processed:
            already_processed.add('disruption')
            outfile.write(' disruption=%s' % (quote_attrib(self.disruption), ))
        if self.complexity != "unknown" and 'complexity' not in already_processed:
            already_processed.add('complexity')
            outfile.write(' complexity=%s' % (quote_attrib(self.complexity), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='fixTextType', fromsubclass_=False, pretty_print=True):
        super(fixTextType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fixref', node)
        if value is not None and 'fixref' not in already_processed:
            already_processed.add('fixref')
            self.fixref = value
        value = find_attr_value_('reboot', node)
        if value is not None and 'reboot' not in already_processed:
            already_processed.add('reboot')
            self.reboot = value
        value = find_attr_value_('strategy', node)
        if value is not None and 'strategy' not in already_processed:
            already_processed.add('strategy')
            self.strategy = value
            self.validate_fixStrategyEnumType(self.strategy)    # validate type fixStrategyEnumType
        value = find_attr_value_('disruption', node)
        if value is not None and 'disruption' not in already_processed:
            already_processed.add('disruption')
            self.disruption = value
            self.validate_ratingEnumType(self.disruption)    # validate type ratingEnumType
        value = find_attr_value_('complexity', node)
        if value is not None and 'complexity' not in already_processed:
            already_processed.add('complexity')
            self.complexity = value
            self.validate_ratingEnumType(self.complexity)    # validate type ratingEnumType
        super(fixTextType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(fixTextType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class fixTextType


class fixType(GeneratedsSuper):
    """sub -- Specifies an
    <
    xccdf:Value
    >
    or
    <
    xccdf:plain-text
    >
    element to be used for text substitution
      
    * instance -- Designates a spot where the name of the
      instance should be substituted into the fix template to generate the final
      fix data. If the @context attribute is omitted, the value of the @context
      defaults to
      
      undefined
      
      .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, reboot='0', strategy='unknown', disruption='unknown', complexity='unknown', system=None, platform=None, sub=None, instance=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.reboot = _cast(None, reboot)
        self.reboot_nsprefix_ = None
        self.strategy = _cast(None, strategy)
        self.strategy_nsprefix_ = None
        self.disruption = _cast(None, disruption)
        self.disruption_nsprefix_ = None
        self.complexity = _cast(None, complexity)
        self.complexity_nsprefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.platform = _cast(None, platform)
        self.platform_nsprefix_ = None
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = "cdf"
        if instance is None:
            self.instance = []
        else:
            self.instance = instance
        self.instance_nsprefix_ = "cdf"
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fixType.subclass:
            return fixType.subclass(*args_, **kwargs_)
        else:
            return fixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_instance(self):
        return self.instance
    def set_instance(self, instance):
        self.instance = instance
    def add_instance(self, value):
        self.instance.append(value)
    def insert_instance_at(self, index, value):
        self.instance.insert(index, value)
    def replace_instance_at(self, index, value):
        self.instance[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_reboot(self):
        return self.reboot
    def set_reboot(self, reboot):
        self.reboot = reboot
    def get_strategy(self):
        return self.strategy
    def set_strategy(self, strategy):
        self.strategy = strategy
    def get_disruption(self):
        return self.disruption
    def set_disruption(self, disruption):
        self.disruption = disruption
    def get_complexity(self):
        return self.complexity
    def set_complexity(self, complexity):
        self.complexity = complexity
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_fixStrategyEnumType(self, value):
        # Validate type cdf:fixStrategyEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['unknown', 'configure', 'combination', 'disable', 'enable', 'patch', 'policy', 'restrict', 'update']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on fixStrategyEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ratingEnumType(self, value):
        # Validate type cdf:ratingEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['unknown', 'low', 'medium', 'high']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ratingEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.sub or
            self.instance or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='fixType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fixType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fixType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fixType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='fixType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.reboot != "0" and 'reboot' not in already_processed:
            already_processed.add('reboot')
            outfile.write(' reboot=%s' % (quote_attrib(self.reboot), ))
        if self.strategy != "unknown" and 'strategy' not in already_processed:
            already_processed.add('strategy')
            outfile.write(' strategy=%s' % (quote_attrib(self.strategy), ))
        if self.disruption != "unknown" and 'disruption' not in already_processed:
            already_processed.add('disruption')
            outfile.write(' disruption=%s' % (quote_attrib(self.disruption), ))
        if self.complexity != "unknown" and 'complexity' not in already_processed:
            already_processed.add('complexity')
            outfile.write(' complexity=%s' % (quote_attrib(self.complexity), ))
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.platform is not None and 'platform' not in already_processed:
            already_processed.add('platform')
            outfile.write(' platform=%s' % (quote_attrib(self.platform), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='fixType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
        for instance_ in self.instance:
            namespaceprefix_ = self.instance_nsprefix_ + ':' if (UseCapturedNS_ and self.instance_nsprefix_) else ''
            instance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('reboot', node)
        if value is not None and 'reboot' not in already_processed:
            already_processed.add('reboot')
            self.reboot = value
        value = find_attr_value_('strategy', node)
        if value is not None and 'strategy' not in already_processed:
            already_processed.add('strategy')
            self.strategy = value
            self.validate_fixStrategyEnumType(self.strategy)    # validate type fixStrategyEnumType
        value = find_attr_value_('disruption', node)
        if value is not None and 'disruption' not in already_processed:
            already_processed.add('disruption')
            self.disruption = value
            self.validate_ratingEnumType(self.disruption)    # validate type ratingEnumType
        value = find_attr_value_('complexity', node)
        if value is not None and 'complexity' not in already_processed:
            already_processed.add('complexity')
            self.complexity = value
            self.validate_ratingEnumType(self.complexity)    # validate type ratingEnumType
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        value = find_attr_value_('platform', node)
        if value is not None and 'platform' not in already_processed:
            already_processed.add('platform')
            self.platform = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sub':
            obj_ = subType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        elif nodeName_ == 'instance':
            obj_ = instanceFixType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'instance', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_instance'):
              self.add_instance(obj_.value)
            elif hasattr(self, 'set_instance'):
              self.set_instance(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class fixType


class instanceFixType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, context='undefined', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.context = _cast(None, context)
        self.context_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instanceFixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instanceFixType.subclass:
            return instanceFixType.subclass(*args_, **kwargs_)
        else:
            return instanceFixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_context(self):
        return self.context
    def set_context(self, context):
        self.context = context
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='instanceFixType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instanceFixType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instanceFixType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instanceFixType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instanceFixType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='instanceFixType'):
        if self.context != "undefined" and 'context' not in already_processed:
            already_processed.add('context')
            outfile.write(' context=%s' % (quote_attrib(self.context), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='instanceFixType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('context', node)
        if value is not None and 'context' not in already_processed:
            already_processed.add('context')
            self.context = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class instanceFixType


class complexCheckType(GeneratedsSuper):
    """check -- Instructions for a single
    test.
    complex-check -- A child
    <
    xccdf:complex-check
    >
    , allowing
    another level of logic in combining component checks.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, operator=None, negate='0', check=None, complex_check=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.negate = _cast(None, negate)
        self.negate_nsprefix_ = None
        if check is None:
            self.check = []
        else:
            self.check = check
        self.check_nsprefix_ = "cdf"
        if complex_check is None:
            self.complex_check = []
        else:
            self.complex_check = complex_check
        self.complex_check_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexCheckType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexCheckType.subclass:
            return complexCheckType.subclass(*args_, **kwargs_)
        else:
            return complexCheckType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_check(self):
        return self.check
    def set_check(self, check):
        self.check = check
    def add_check(self, value):
        self.check.append(value)
    def insert_check_at(self, index, value):
        self.check.insert(index, value)
    def replace_check_at(self, index, value):
        self.check[index] = value
    def get_complex_check(self):
        return self.complex_check
    def set_complex_check(self, complex_check):
        self.complex_check = complex_check
    def add_complex_check(self, value):
        self.complex_check.append(value)
    def insert_complex_check_at(self, index, value):
        self.complex_check.insert(index, value)
    def replace_complex_check_at(self, index, value):
        self.complex_check[index] = value
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_negate(self):
        return self.negate
    def set_negate(self, negate):
        self.negate = negate
    def validate_ccOperatorEnumType(self, value):
        # Validate type cdf:ccOperatorEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['OR', 'AND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ccOperatorEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.check or
            self.complex_check
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='complexCheckType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexCheckType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complexCheckType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complexCheckType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complexCheckType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='complexCheckType'):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.negate != "0" and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='complexCheckType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for check_ in self.check:
            namespaceprefix_ = self.check_nsprefix_ + ':' if (UseCapturedNS_ and self.check_nsprefix_) else ''
            check_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='check', pretty_print=pretty_print)
        for complex_check_ in self.complex_check:
            namespaceprefix_ = self.complex_check_nsprefix_ + ':' if (UseCapturedNS_ and self.complex_check_nsprefix_) else ''
            complex_check_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='complex-check', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_ccOperatorEnumType(self.operator)    # validate type ccOperatorEnumType
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'check':
            obj_ = checkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check.append(obj_)
            obj_.original_tagname_ = 'check'
        elif nodeName_ == 'complex-check':
            obj_ = complexCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.complex_check.append(obj_)
            obj_.original_tagname_ = 'complex-check'
# end class complexCheckType


class checkType(GeneratedsSuper):
    """check-import -- Identifies a value to be retrieved from the
    checking system during testing of a target system. This element's body must
    be empty within an
    <
    xccdf:check
    >
    . After the associated check results
    have been collected, the result structure returned by the checking engine is
    processed to collect the named information. This information is then
    recorded in the check-import element in the corresponding
    <
    xccdf:rule-result
    >
    .
    check-export -- A mapping from an
    <
    xccdf:Value
    >
    element
    to a checking system variable (i.e., external name or id for use by the
    checking system). This supports export of tailoring values from the XCCDF
    processing environment to the checking system.
    check-content-ref -- Points to code for a detached check in another
    location that uses the language or system specified by the
    <
    xccdf:check
    >
    element
    
    s @system attribute. If multiple
    <
    xccdf:check-content-ref
    >
    elements appear, they represent alternative
    locations from which a benchmark consumer may obtain the check content.
    Benchmark consumers should process the alternatives in the order in which
    they appear in the XML. The first
    <
    xccdf:check-content-ref
    >
    from which
    content can be successfully retrieved should be used.
    check-content -- Holds the actual code of a check, in the
    language or system specified by the
    <
    xccdf:check
    >
    element
    
    s @system
    attribute. If both
    <
    xccdf:check-content-ref
    >
    and
    <
    xccdf:check-content
    >
    elements appear in a single
    <
    xccdf:check
    >
    element, benchmark consumers should use the
    <
    xccdf:check-content
    >
    element only if none of the references can be resolved to provide
    content.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, system=None, negate='false', id=None, selector='', multi_check='false', base=None, check_import=None, check_export=None, check_content_ref=None, check_content=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.negate = _cast(None, negate)
        self.negate_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.selector = _cast(None, selector)
        self.selector_nsprefix_ = None
        self.multi_check = _cast(None, multi_check)
        self.multi_check_nsprefix_ = None
        self.base = _cast(None, base)
        self.base_nsprefix_ = None
        if check_import is None:
            self.check_import = []
        else:
            self.check_import = check_import
        self.check_import_nsprefix_ = "cdf"
        if check_export is None:
            self.check_export = []
        else:
            self.check_export = check_export
        self.check_export_nsprefix_ = "cdf"
        if check_content_ref is None:
            self.check_content_ref = []
        else:
            self.check_content_ref = check_content_ref
        self.check_content_ref_nsprefix_ = "cdf"
        self.check_content = check_content
        self.check_content_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, checkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if checkType.subclass:
            return checkType.subclass(*args_, **kwargs_)
        else:
            return checkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_check_import(self):
        return self.check_import
    def set_check_import(self, check_import):
        self.check_import = check_import
    def add_check_import(self, value):
        self.check_import.append(value)
    def insert_check_import_at(self, index, value):
        self.check_import.insert(index, value)
    def replace_check_import_at(self, index, value):
        self.check_import[index] = value
    def get_check_export(self):
        return self.check_export
    def set_check_export(self, check_export):
        self.check_export = check_export
    def add_check_export(self, value):
        self.check_export.append(value)
    def insert_check_export_at(self, index, value):
        self.check_export.insert(index, value)
    def replace_check_export_at(self, index, value):
        self.check_export[index] = value
    def get_check_content_ref(self):
        return self.check_content_ref
    def set_check_content_ref(self, check_content_ref):
        self.check_content_ref = check_content_ref
    def add_check_content_ref(self, value):
        self.check_content_ref.append(value)
    def insert_check_content_ref_at(self, index, value):
        self.check_content_ref.insert(index, value)
    def replace_check_content_ref_at(self, index, value):
        self.check_content_ref[index] = value
    def get_check_content(self):
        return self.check_content
    def set_check_content(self, check_content):
        self.check_content = check_content
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_negate(self):
        return self.negate
    def set_negate(self, negate):
        self.negate = negate
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_selector(self):
        return self.selector
    def set_selector(self, selector):
        self.selector = selector
    def get_multi_check(self):
        return self.multi_check
    def set_multi_check(self, multi_check):
        self.multi_check = multi_check
    def get_base(self):
        return self.base
    def set_base(self, base):
        self.base = base
    def has__content(self):
        if (
            self.check_import or
            self.check_export or
            self.check_content_ref or
            self.check_content is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='checkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('checkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'checkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='checkType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='checkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='checkType'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.negate != "false" and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.selector != "" and 'selector' not in already_processed:
            already_processed.add('selector')
            outfile.write(' selector=%s' % (quote_attrib(self.selector), ))
        if self.multi_check != "false" and 'multi_check' not in already_processed:
            already_processed.add('multi_check')
            outfile.write(' multi-check=%s' % (quote_attrib(self.multi_check), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.add('base')
            outfile.write(' xml:base=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.base), input_name='base')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='checkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for check_import_ in self.check_import:
            namespaceprefix_ = self.check_import_nsprefix_ + ':' if (UseCapturedNS_ and self.check_import_nsprefix_) else ''
            check_import_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='check-import', pretty_print=pretty_print)
        for check_export_ in self.check_export:
            namespaceprefix_ = self.check_export_nsprefix_ + ':' if (UseCapturedNS_ and self.check_export_nsprefix_) else ''
            check_export_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='check-export', pretty_print=pretty_print)
        for check_content_ref_ in self.check_content_ref:
            namespaceprefix_ = self.check_content_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.check_content_ref_nsprefix_) else ''
            check_content_ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='check-content-ref', pretty_print=pretty_print)
        if self.check_content is not None:
            namespaceprefix_ = self.check_content_nsprefix_ + ':' if (UseCapturedNS_ and self.check_content_nsprefix_) else ''
            self.check_content.export(outfile, level, namespaceprefix_, namespacedef_='', name_='check-content', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('selector', node)
        if value is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            self.selector = value
        value = find_attr_value_('multi-check', node)
        if value is not None and 'multi-check' not in already_processed:
            already_processed.add('multi-check')
            self.multi_check = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.add('base')
            self.base = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'check-import':
            obj_ = checkImportType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check_import.append(obj_)
            obj_.original_tagname_ = 'check-import'
        elif nodeName_ == 'check-export':
            obj_ = checkExportType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check_export.append(obj_)
            obj_.original_tagname_ = 'check-export'
        elif nodeName_ == 'check-content-ref':
            obj_ = checkContentRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check_content_ref.append(obj_)
            obj_.original_tagname_ = 'check-content-ref'
        elif nodeName_ == 'check-content':
            obj_ = checkContentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check_content = obj_
            obj_.original_tagname_ = 'check-content'
# end class checkType


class checkImportType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, import_name=None, import_xpath=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.import_name = _cast(None, import_name)
        self.import_name_nsprefix_ = None
        self.import_xpath = _cast(None, import_xpath)
        self.import_xpath_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, checkImportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if checkImportType.subclass:
            return checkImportType.subclass(*args_, **kwargs_)
        else:
            return checkImportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_import_name(self):
        return self.import_name
    def set_import_name(self, import_name):
        self.import_name = import_name
    def get_import_xpath(self):
        return self.import_xpath
    def set_import_xpath(self, import_xpath):
        self.import_xpath = import_xpath
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='checkImportType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('checkImportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'checkImportType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='checkImportType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='checkImportType'):
        if self.import_name is not None and 'import_name' not in already_processed:
            already_processed.add('import_name')
            outfile.write(' import-name=%s' % (quote_attrib(self.import_name), ))
        if self.import_xpath is not None and 'import_xpath' not in already_processed:
            already_processed.add('import_xpath')
            outfile.write(' import-xpath=%s' % (quote_attrib(self.import_xpath), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='checkImportType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('import-name', node)
        if value is not None and 'import-name' not in already_processed:
            already_processed.add('import-name')
            self.import_name = value
        value = find_attr_value_('import-xpath', node)
        if value is not None and 'import-xpath' not in already_processed:
            already_processed.add('import-xpath')
            self.import_xpath = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class checkImportType


class checkExportType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value_id=None, export_name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.value_id = _cast(None, value_id)
        self.value_id_nsprefix_ = None
        self.export_name = _cast(None, export_name)
        self.export_name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, checkExportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if checkExportType.subclass:
            return checkExportType.subclass(*args_, **kwargs_)
        else:
            return checkExportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value_id(self):
        return self.value_id
    def set_value_id(self, value_id):
        self.value_id = value_id
    def get_export_name(self):
        return self.export_name
    def set_export_name(self, export_name):
        self.export_name = export_name
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='checkExportType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('checkExportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'checkExportType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='checkExportType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='checkExportType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='checkExportType'):
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (quote_attrib(self.value_id), ))
        if self.export_name is not None and 'export_name' not in already_processed:
            already_processed.add('export_name')
            outfile.write(' export-name=%s' % (quote_attrib(self.export_name), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='checkExportType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
        value = find_attr_value_('export-name', node)
        if value is not None and 'export-name' not in already_processed:
            already_processed.add('export-name')
            self.export_name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class checkExportType


class checkContentRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, checkContentRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if checkContentRefType.subclass:
            return checkContentRefType.subclass(*args_, **kwargs_)
        else:
            return checkContentRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='checkContentRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('checkContentRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'checkContentRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='checkContentRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='checkContentRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='checkContentRefType'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='checkContentRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class checkContentRefType


class checkContentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, checkContentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if checkContentType.subclass:
            return checkContentType.subclass(*args_, **kwargs_)
        else:
            return checkContentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='checkContentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('checkContentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'checkContentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='checkContentType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='checkContentType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='checkContentType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class checkContentType


class valueType(itemType):
    """value -- A simple (number, string, or
    boolean) value associated with this
    <
    xccdf:Value
    >
    . At any
    time an
    <
    xccdf:Value
    >
    has one active (simple or complex)
    value. If a selector value has been provided under
    <
    xccdf:Profile
    >
    selection or tailoring then the active
    <
    xccdf:value
    >
    /
    <
    xccdf:complex-value
    >
    is the one with
    a matching @selector. If there is no provided selector or if the
    provided selector does not match the @selector attribute of any
    <
    xccdf:value
    >
    or
    <
    xccdf:complex-value
    >
    , the active
    <
    xccdf:value
    >
    /
    <
    xccdf:complex-value
    >
    is the one with
    an empty or absent @selector or, failing that, the first
    <
    xccdf:value
    >
    or
    <
    xccdf:complex-value
    >
    in the XML.
    When an
    <
    xccdf:Value
    >
    is exported or used in text
    substitution, it is the currently active
    <
    xccdf:value
    >
    or
    <
    xccdf:complex-value
    >
    that is actually used. If there are
    multiple
    <
    xccdf:value
    >
    and/or
    <
    xccdf:complex-value
    >
    elements, only one may omit a @selector attribute and no two may
    have the same @selector value.
    complex-value -- A complex (list) value associated
    with this
    <
    xccdf:Value
    >
    . See the description of the
    <
    xccdf:value
    >
    property for
    <
    xccdf:Rule
    >
    elements
    regarding activation of an
    <
    xccdf:complex-value
    >
    .
      
    * default -- The default value displayed to the
      user as a suggestion by benchmark producers during tailoring of
      this
      <
      xccdf:Value
      >
      element. (This is not the default value
      of an
      <
      xccdf:Value
      >
      ; it is just the default display.) If
      there are multiple
      <
      xccdf:default
      >
      and/or
      <
      xccdf:complex-default
      >
      elements, only one may omit a
      @selector attribute and no two may have the same @selector
      value.
    * complex-default -- The default
      <
      xccdf:complex-value
      >
      displayed to the user as a
      suggestion by benchmark producers during tailoring of this
      <
      xccdf:Value
      >
      element. (This is not the default value of
      an
      <
      xccdf:Value
      >
      ; it is just the default display.) If
      there are multiple
      <
      xccdf:default
      >
      and
      <
      xccdf:complex-default
      >
      elements, only one may omit a
      @selector attribute and no two may have the same @selector
      value.
    * match -- A Perl Compatible Regular Expression
      that a benchmark producer may apply during tailoring to validate a
      user
      
      s input for the
      <
      xccdf:Value
      >
      . It uses implicit
      anchoring. It applies only when the @type property is
      
      string
      
      or
      
      number
      
      or a list of strings and/or numbers.
    * lower-bound -- Minimum legal value for this
      <
      xccdf:Value
      >
      . It is used to constrain value input during
      tailoring, when the @type property is
      
      number
      
      . Values supplied by
      the user for tailoring the
      <
      xccdf:Benchmark
      >
      must be equal to
      or greater than this number.
    * upper-bound -- Maximum legal value for this
      <
      xccdf:Value
      >
      . It is used to constrain value input during
      tailoring, when the @type is
      
      number
      
      . Values supplied by the user
      for tailoring the
      <
      xccdf:Benchmark
      >
      must be less than or equal
      to than this number.
    * choices -- A list of legal or suggested choices
      (values) for an
      <
      xccdf:Value
      >
      element, to be used during
      tailoring and document generation.
    * source -- URI indicating where the tool may
      acquire values, value bounds, or value choices for this
      <
      xccdf:Value
      >
      element. XCCDF does not attach any meaning to
      the URI; it may be an arbitrary community or tool-specific value, or
      a pointer directly to a resource. If several instances of the
      <
      xccdf:source
      >
      property appear, then they represent
      alternative means or locations for obtaining the value in descending
      order of preference (i.e., most preferred first).
      
    * signature -- A digital signature asserting
      authorship and allowing verification of the integrity of the
      <
      xccdf:Value
      >
      .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = itemType
    def __init__(self, abstract='false', cluster_id=None, extends=None, hidden='false', prohibitChanges='false', lang=None, base=None, Id=None, status=None, dc_status=None, version=None, title=None, description=None, warning=None, question=None, reference=None, metadata=None, id=None, type_='string', operator='equals', interactive='0', interfaceHint=None, value=None, complex_value=None, default=None, complex_default=None, match=None, lower_bound=None, upper_bound=None, choices=None, source=None, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        super(globals().get("valueType"), self).__init__(abstract, cluster_id, extends, hidden, prohibitChanges, lang, base, Id, status, dc_status, version, title, description, warning, question, reference, metadata,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.interactive = _cast(None, interactive)
        self.interactive_nsprefix_ = None
        self.interfaceHint = _cast(None, interfaceHint)
        self.interfaceHint_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = "cdf"
        if complex_value is None:
            self.complex_value = []
        else:
            self.complex_value = complex_value
        self.complex_value_nsprefix_ = "cdf"
        if default is None:
            self.default = []
        else:
            self.default = default
        self.default_nsprefix_ = "cdf"
        if complex_default is None:
            self.complex_default = []
        else:
            self.complex_default = complex_default
        self.complex_default_nsprefix_ = "cdf"
        if match is None:
            self.match = []
        else:
            self.match = match
        self.match_nsprefix_ = "cdf"
        if lower_bound is None:
            self.lower_bound = []
        else:
            self.lower_bound = lower_bound
        self.lower_bound_nsprefix_ = "cdf"
        if upper_bound is None:
            self.upper_bound = []
        else:
            self.upper_bound = upper_bound
        self.upper_bound_nsprefix_ = "cdf"
        if choices is None:
            self.choices = []
        else:
            self.choices = choices
        self.choices_nsprefix_ = "cdf"
        if source is None:
            self.source = []
        else:
            self.source = source
        self.source_nsprefix_ = "cdf"
        self.signature = signature
        self.signature_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, valueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if valueType.subclass:
            return valueType.subclass(*args_, **kwargs_)
        else:
            return valueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_complex_value(self):
        return self.complex_value
    def set_complex_value(self, complex_value):
        self.complex_value = complex_value
    def add_complex_value(self, value):
        self.complex_value.append(value)
    def insert_complex_value_at(self, index, value):
        self.complex_value.insert(index, value)
    def replace_complex_value_at(self, index, value):
        self.complex_value[index] = value
    def get_default(self):
        return self.default
    def set_default(self, default):
        self.default = default
    def add_default(self, value):
        self.default.append(value)
    def insert_default_at(self, index, value):
        self.default.insert(index, value)
    def replace_default_at(self, index, value):
        self.default[index] = value
    def get_complex_default(self):
        return self.complex_default
    def set_complex_default(self, complex_default):
        self.complex_default = complex_default
    def add_complex_default(self, value):
        self.complex_default.append(value)
    def insert_complex_default_at(self, index, value):
        self.complex_default.insert(index, value)
    def replace_complex_default_at(self, index, value):
        self.complex_default[index] = value
    def get_match(self):
        return self.match
    def set_match(self, match):
        self.match = match
    def add_match(self, value):
        self.match.append(value)
    def insert_match_at(self, index, value):
        self.match.insert(index, value)
    def replace_match_at(self, index, value):
        self.match[index] = value
    def get_lower_bound(self):
        return self.lower_bound
    def set_lower_bound(self, lower_bound):
        self.lower_bound = lower_bound
    def add_lower_bound(self, value):
        self.lower_bound.append(value)
    def insert_lower_bound_at(self, index, value):
        self.lower_bound.insert(index, value)
    def replace_lower_bound_at(self, index, value):
        self.lower_bound[index] = value
    def get_upper_bound(self):
        return self.upper_bound
    def set_upper_bound(self, upper_bound):
        self.upper_bound = upper_bound
    def add_upper_bound(self, value):
        self.upper_bound.append(value)
    def insert_upper_bound_at(self, index, value):
        self.upper_bound.insert(index, value)
    def replace_upper_bound_at(self, index, value):
        self.upper_bound[index] = value
    def get_choices(self):
        return self.choices
    def set_choices(self, choices):
        self.choices = choices
    def add_choices(self, value):
        self.choices.append(value)
    def insert_choices_at(self, index, value):
        self.choices.insert(index, value)
    def replace_choices_at(self, index, value):
        self.choices[index] = value
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def add_source(self, value):
        self.source.append(value)
    def insert_source_at(self, index, value):
        self.source.insert(index, value)
    def replace_source_at(self, index, value):
        self.source[index] = value
    def get_signature(self):
        return self.signature
    def set_signature(self, signature):
        self.signature = signature
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_interactive(self):
        return self.interactive
    def set_interactive(self, interactive):
        self.interactive = interactive
    def get_interfaceHint(self):
        return self.interfaceHint
    def set_interfaceHint(self, interfaceHint):
        self.interfaceHint = interfaceHint
    def validate_valueIdType(self, value):
        # Validate type cdf:valueIdType, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_valueIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_valueIdType_patterns_, ))
    validate_valueIdType_patterns_ = [['^(xccdf_[^_]+_value_.+)$']]
    def validate_valueTypeType(self, value):
        # Validate type cdf:valueTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['number', 'string', 'boolean']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valueTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_valueOperatorType(self, value):
        # Validate type cdf:valueOperatorType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['equals', 'not equal', 'greater than', 'less than', 'greater than or equal', 'less than or equal', 'pattern match']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valueOperatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_interfaceHintType(self, value):
        # Validate type cdf:interfaceHintType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['choice', 'textline', 'text', 'date', 'datetime']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on interfaceHintType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.value or
            self.complex_value or
            self.default or
            self.complex_default or
            self.match or
            self.lower_bound or
            self.upper_bound or
            self.choices or
            self.source or
            self.signature is not None or
            super(valueType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='valueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('valueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'valueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='valueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='valueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='valueType'):
        super(valueType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='valueType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.type_ != "string" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.operator != "equals" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.interactive != "0" and 'interactive' not in already_processed:
            already_processed.add('interactive')
            outfile.write(' interactive=%s' % (quote_attrib(self.interactive), ))
        if self.interfaceHint is not None and 'interfaceHint' not in already_processed:
            already_processed.add('interfaceHint')
            outfile.write(' interfaceHint=%s' % (quote_attrib(self.interfaceHint), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='valueType', fromsubclass_=False, pretty_print=True):
        super(valueType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        for complex_value_ in self.complex_value:
            namespaceprefix_ = self.complex_value_nsprefix_ + ':' if (UseCapturedNS_ and self.complex_value_nsprefix_) else ''
            complex_value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='complex-value', pretty_print=pretty_print)
        for default_ in self.default:
            namespaceprefix_ = self.default_nsprefix_ + ':' if (UseCapturedNS_ and self.default_nsprefix_) else ''
            default_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='default', pretty_print=pretty_print)
        for complex_default_ in self.complex_default:
            namespaceprefix_ = self.complex_default_nsprefix_ + ':' if (UseCapturedNS_ and self.complex_default_nsprefix_) else ''
            complex_default_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='complex-default', pretty_print=pretty_print)
        for match_ in self.match:
            namespaceprefix_ = self.match_nsprefix_ + ':' if (UseCapturedNS_ and self.match_nsprefix_) else ''
            match_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='match', pretty_print=pretty_print)
        for lower_bound_ in self.lower_bound:
            namespaceprefix_ = self.lower_bound_nsprefix_ + ':' if (UseCapturedNS_ and self.lower_bound_nsprefix_) else ''
            lower_bound_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lower-bound', pretty_print=pretty_print)
        for upper_bound_ in self.upper_bound:
            namespaceprefix_ = self.upper_bound_nsprefix_ + ':' if (UseCapturedNS_ and self.upper_bound_nsprefix_) else ''
            upper_bound_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='upper-bound', pretty_print=pretty_print)
        for choices_ in self.choices:
            namespaceprefix_ = self.choices_nsprefix_ + ':' if (UseCapturedNS_ and self.choices_nsprefix_) else ''
            choices_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='choices', pretty_print=pretty_print)
        for source_ in self.source:
            namespaceprefix_ = self.source_nsprefix_ + ':' if (UseCapturedNS_ and self.source_nsprefix_) else ''
            source_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='source', pretty_print=pretty_print)
        if self.signature is not None:
            namespaceprefix_ = self.signature_nsprefix_ + ':' if (UseCapturedNS_ and self.signature_nsprefix_) else ''
            self.signature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_valueIdType(self.id)    # validate type valueIdType
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_valueTypeType(self.type_)    # validate type valueTypeType
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_valueOperatorType(self.operator)    # validate type valueOperatorType
        value = find_attr_value_('interactive', node)
        if value is not None and 'interactive' not in already_processed:
            already_processed.add('interactive')
            self.interactive = value
        value = find_attr_value_('interfaceHint', node)
        if value is not None and 'interfaceHint' not in already_processed:
            already_processed.add('interfaceHint')
            self.interfaceHint = value
            self.validate_interfaceHintType(self.interfaceHint)    # validate type interfaceHintType
        super(valueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            obj_ = selStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'complex-value':
            obj_ = selComplexValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.complex_value.append(obj_)
            obj_.original_tagname_ = 'complex-value'
        elif nodeName_ == 'default':
            obj_ = selStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.default.append(obj_)
            obj_.original_tagname_ = 'default'
        elif nodeName_ == 'complex-default':
            obj_ = selComplexValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.complex_default.append(obj_)
            obj_.original_tagname_ = 'complex-default'
        elif nodeName_ == 'match':
            obj_ = selStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.match.append(obj_)
            obj_.original_tagname_ = 'match'
        elif nodeName_ == 'lower-bound':
            obj_ = selNumType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lower_bound.append(obj_)
            obj_.original_tagname_ = 'lower-bound'
        elif nodeName_ == 'upper-bound':
            obj_ = selNumType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.upper_bound.append(obj_)
            obj_.original_tagname_ = 'upper-bound'
        elif nodeName_ == 'choices':
            obj_ = selChoicesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.choices.append(obj_)
            obj_.original_tagname_ = 'choices'
        elif nodeName_ == 'source':
            obj_ = uriRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.source.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'signature':
            obj_ = signatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature = obj_
            obj_.original_tagname_ = 'signature'
        super(valueType, self)._buildChildren(child_, node, nodeName_, True)
# end class valueType


class complexValueType(GeneratedsSuper):
    """item -- A single item in the list of values.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, item=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexValueType.subclass:
            return complexValueType.subclass(*args_, **kwargs_)
        else:
            return complexValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def add_item(self, value):
        self.item.append(value)
    def insert_item_at(self, index, value):
        self.item.insert(index, value)
    def replace_item_at(self, index, value):
        self.item[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='complexValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complexValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complexValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complexValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='complexValueType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='complexValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for item_ in self.item:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sitem>%s</%sitem>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(item_), input_name='item')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'item')
            value_ = self.gds_validate_string(value_, node, 'item')
            self.item.append(value_)
            self.item_nsprefix_ = child_.prefix
# end class complexValueType


class selComplexValueType(complexValueType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = complexValueType
    def __init__(self, item=None, selector='', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        super(globals().get("selComplexValueType"), self).__init__(item,  **kwargs_)
        self.selector = _cast(None, selector)
        self.selector_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, selComplexValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if selComplexValueType.subclass:
            return selComplexValueType.subclass(*args_, **kwargs_)
        else:
            return selComplexValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_selector(self):
        return self.selector
    def set_selector(self, selector):
        self.selector = selector
    def has__content(self):
        if (
            super(selComplexValueType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='selComplexValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('selComplexValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'selComplexValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selComplexValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='selComplexValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='selComplexValueType'):
        super(selComplexValueType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selComplexValueType')
        if self.selector != "" and 'selector' not in already_processed:
            already_processed.add('selector')
            outfile.write(' selector=%s' % (quote_attrib(self.selector), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='selComplexValueType', fromsubclass_=False, pretty_print=True):
        super(selComplexValueType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('selector', node)
        if value is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            self.selector = value
        super(selComplexValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(selComplexValueType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class selComplexValueType


class selChoicesType(GeneratedsSuper):
    """choice -- A single choice holding a simple type. (I.e.,
    number, string, or boolean.)
    complex-choice -- A single choice holding a list of simple
    types.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, mustMatch=None, selector='', choice=None, complex_choice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mustMatch = _cast(None, mustMatch)
        self.mustMatch_nsprefix_ = None
        self.selector = _cast(None, selector)
        self.selector_nsprefix_ = None
        if choice is None:
            self.choice = []
        else:
            self.choice = choice
        self.choice_nsprefix_ = None
        if complex_choice is None:
            self.complex_choice = []
        else:
            self.complex_choice = complex_choice
        self.complex_choice_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, selChoicesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if selChoicesType.subclass:
            return selChoicesType.subclass(*args_, **kwargs_)
        else:
            return selChoicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_choice(self):
        return self.choice
    def set_choice(self, choice):
        self.choice = choice
    def add_choice(self, value):
        self.choice.append(value)
    def insert_choice_at(self, index, value):
        self.choice.insert(index, value)
    def replace_choice_at(self, index, value):
        self.choice[index] = value
    def get_complex_choice(self):
        return self.complex_choice
    def set_complex_choice(self, complex_choice):
        self.complex_choice = complex_choice
    def add_complex_choice(self, value):
        self.complex_choice.append(value)
    def insert_complex_choice_at(self, index, value):
        self.complex_choice.insert(index, value)
    def replace_complex_choice_at(self, index, value):
        self.complex_choice[index] = value
    def get_mustMatch(self):
        return self.mustMatch
    def set_mustMatch(self, mustMatch):
        self.mustMatch = mustMatch
    def get_selector(self):
        return self.selector
    def set_selector(self, selector):
        self.selector = selector
    def has__content(self):
        if (
            self.choice or
            self.complex_choice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='selChoicesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('selChoicesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'selChoicesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selChoicesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='selChoicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='selChoicesType'):
        if self.mustMatch is not None and 'mustMatch' not in already_processed:
            already_processed.add('mustMatch')
            outfile.write(' mustMatch=%s' % (quote_attrib(self.mustMatch), ))
        if self.selector != "" and 'selector' not in already_processed:
            already_processed.add('selector')
            outfile.write(' selector=%s' % (quote_attrib(self.selector), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='selChoicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for choice_ in self.choice:
            namespaceprefix_ = self.choice_nsprefix_ + ':' if (UseCapturedNS_ and self.choice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schoice>%s</%schoice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(choice_), input_name='choice')), namespaceprefix_ , eol_))
        for complex_choice_ in self.complex_choice:
            namespaceprefix_ = self.complex_choice_nsprefix_ + ':' if (UseCapturedNS_ and self.complex_choice_nsprefix_) else ''
            complex_choice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='complex-choice', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mustMatch', node)
        if value is not None and 'mustMatch' not in already_processed:
            already_processed.add('mustMatch')
            self.mustMatch = value
        value = find_attr_value_('selector', node)
        if value is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            self.selector = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'choice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'choice')
            value_ = self.gds_validate_string(value_, node, 'choice')
            self.choice.append(value_)
            self.choice_nsprefix_ = child_.prefix
        elif nodeName_ == 'complex-choice':
            class_obj_ = self.get_class_obj_(child_, complexValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.complex_choice.append(obj_)
            obj_.original_tagname_ = 'complex-choice'
# end class selChoicesType


class selStringType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, selector='', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.selector = _cast(None, selector)
        self.selector_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, selStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if selStringType.subclass:
            return selStringType.subclass(*args_, **kwargs_)
        else:
            return selStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_selector(self):
        return self.selector
    def set_selector(self, selector):
        self.selector = selector
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='selStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('selStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'selStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selStringType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='selStringType'):
        if self.selector != "" and 'selector' not in already_processed:
            already_processed.add('selector')
            outfile.write(' selector=%s' % (quote_attrib(self.selector), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='selStringType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('selector', node)
        if value is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            self.selector = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class selStringType


class selNumType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, selector='', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.selector = _cast(None, selector)
        self.selector_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, selNumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if selNumType.subclass:
            return selNumType.subclass(*args_, **kwargs_)
        else:
            return selNumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_selector(self):
        return self.selector
    def set_selector(self, selector):
        self.selector = selector
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='selNumType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('selNumType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'selNumType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selNumType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='selNumType'):
        if self.selector != "" and 'selector' not in already_processed:
            already_processed.add('selector')
            outfile.write(' selector=%s' % (quote_attrib(self.selector), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='selNumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('selector', node)
        if value is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            self.selector = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class selNumType


class uriRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.uri = _cast(None, uri)
        self.uri_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, uriRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if uriRefType.subclass:
            return uriRefType.subclass(*args_, **kwargs_)
        else:
            return uriRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='uriRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('uriRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'uriRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='uriRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='uriRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='uriRefType'):
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (quote_attrib(self.uri), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='uriRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class uriRefType


class profileType(GeneratedsSuper):
    """status -- Status of the
    <
    xccdf:Profile
    >
    and date at
    which it attained that status. Authors may use this element to record the
    maturity or consensus level of an
    <
    xccdf:Profile
    >
    . If the
    <
    xccdf:status
    >
    is not given explicitly, then the
    <
    xccdf:Profile
    >
    is taken to have the same status as its parent
    <
    xccdf:Benchmark
    >
    .
    dc-status -- Holds additional status information using the
    Dublin Core format.
    version -- Version information about this
    <
    xccdf:Profile
    >
    .
    title -- Title of the
    <
    xccdf:Profile
    >
    .
      
    * description -- Text that describes the
      <
      xccdf:Profile
      >
      .
      
    * reference -- A reference where the user can learn more about
      the subject of this
      <
      xccdf:Profile
      >
      .
    * platform -- A target platform for this
      <
      xccdf:Profile
      >
      .
    * select -- Select or deselect
      <
      xccdf:Group
      >
      and
      <
      xccdf:Rule
      >
      elements.
    * set-complex-value -- Set the value of an
      <
      xccdf:Value
      >
      to
      a list.
    * set-value -- Set the value of an
      <
      xccdf:Value
      >
      to
      a simple data value.
    * refine-value -- Customize the properties of an
      <
      xccdf:Value
      >
      .
    * refine-rule -- Customize the properties of an
      <
      xccdf:Rule
      >
      or
      <
      xccdf:Group
      >
      .
    * metadata -- Metadata associated with this
      <
      xccdf:Profile
      >
      .
    * signature -- A digital signature asserting authorship and
      allowing verification of the integrity of the
      <
      xccdf:Profile
      >
      .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, prohibitChanges='false', abstract='false', note_tag=None, extends=None, base=None, Id=None, status=None, dc_status=None, version=None, title=None, description=None, reference=None, platform=None, select=None, set_complex_value=None, set_value=None, refine_value=None, refine_rule=None, metadata=None, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.prohibitChanges = _cast(None, prohibitChanges)
        self.prohibitChanges_nsprefix_ = None
        self.abstract = _cast(None, abstract)
        self.abstract_nsprefix_ = None
        self.note_tag = _cast(None, note_tag)
        self.note_tag_nsprefix_ = None
        self.extends = _cast(None, extends)
        self.extends_nsprefix_ = None
        self.base = _cast(None, base)
        self.base_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        if status is None:
            self.status = []
        else:
            self.status = status
        self.status_nsprefix_ = "cdf"
        if dc_status is None:
            self.dc_status = []
        else:
            self.dc_status = dc_status
        self.dc_status_nsprefix_ = "cdf"
        self.version = version
        self.version_nsprefix_ = "cdf"
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = "cdf"
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = "cdf"
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = "cdf"
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = "cdf"
        if select is None:
            self.select = []
        else:
            self.select = select
        self.select_nsprefix_ = "cdf"
        if set_complex_value is None:
            self.set_complex_value = []
        else:
            self.set_complex_value = set_complex_value
        self.set_complex_value_nsprefix_ = "cdf"
        if set_value is None:
            self.set_value = []
        else:
            self.set_value = set_value
        self.set_value_nsprefix_ = "cdf"
        if refine_value is None:
            self.refine_value = []
        else:
            self.refine_value = refine_value
        self.refine_value_nsprefix_ = "cdf"
        if refine_rule is None:
            self.refine_rule = []
        else:
            self.refine_rule = refine_rule
        self.refine_rule_nsprefix_ = "cdf"
        if metadata is None:
            self.metadata = []
        else:
            self.metadata = metadata
        self.metadata_nsprefix_ = "cdf"
        self.signature = signature
        self.signature_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, profileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if profileType.subclass:
            return profileType.subclass(*args_, **kwargs_)
        else:
            return profileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def add_status(self, value):
        self.status.append(value)
    def insert_status_at(self, index, value):
        self.status.insert(index, value)
    def replace_status_at(self, index, value):
        self.status[index] = value
    def get_dc_status(self):
        return self.dc_status
    def set_dc_status(self, dc_status):
        self.dc_status = dc_status
    def add_dc_status(self, value):
        self.dc_status.append(value)
    def insert_dc_status_at(self, index, value):
        self.dc_status.insert(index, value)
    def replace_dc_status_at(self, index, value):
        self.dc_status[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def add_platform(self, value):
        self.platform.append(value)
    def insert_platform_at(self, index, value):
        self.platform.insert(index, value)
    def replace_platform_at(self, index, value):
        self.platform[index] = value
    def get_select(self):
        return self.select
    def set_select(self, select):
        self.select = select
    def add_select(self, value):
        self.select.append(value)
    def insert_select_at(self, index, value):
        self.select.insert(index, value)
    def replace_select_at(self, index, value):
        self.select[index] = value
    def get_set_complex_value(self):
        return self.set_complex_value
    def set_set_complex_value(self, set_complex_value):
        self.set_complex_value = set_complex_value
    def add_set_complex_value(self, value):
        self.set_complex_value.append(value)
    def insert_set_complex_value_at(self, index, value):
        self.set_complex_value.insert(index, value)
    def replace_set_complex_value_at(self, index, value):
        self.set_complex_value[index] = value
    def get_set_value(self):
        return self.set_value
    def set_set_value(self, set_value):
        self.set_value = set_value
    def add_set_value(self, value):
        self.set_value.append(value)
    def insert_set_value_at(self, index, value):
        self.set_value.insert(index, value)
    def replace_set_value_at(self, index, value):
        self.set_value[index] = value
    def get_refine_value(self):
        return self.refine_value
    def set_refine_value(self, refine_value):
        self.refine_value = refine_value
    def add_refine_value(self, value):
        self.refine_value.append(value)
    def insert_refine_value_at(self, index, value):
        self.refine_value.insert(index, value)
    def replace_refine_value_at(self, index, value):
        self.refine_value[index] = value
    def get_refine_rule(self):
        return self.refine_rule
    def set_refine_rule(self, refine_rule):
        self.refine_rule = refine_rule
    def add_refine_rule(self, value):
        self.refine_rule.append(value)
    def insert_refine_rule_at(self, index, value):
        self.refine_rule.insert(index, value)
    def replace_refine_rule_at(self, index, value):
        self.refine_rule[index] = value
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def add_metadata(self, value):
        self.metadata.append(value)
    def insert_metadata_at(self, index, value):
        self.metadata.insert(index, value)
    def replace_metadata_at(self, index, value):
        self.metadata[index] = value
    def get_signature(self):
        return self.signature
    def set_signature(self, signature):
        self.signature = signature
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_prohibitChanges(self):
        return self.prohibitChanges
    def set_prohibitChanges(self, prohibitChanges):
        self.prohibitChanges = prohibitChanges
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def get_note_tag(self):
        return self.note_tag
    def set_note_tag(self, note_tag):
        self.note_tag = note_tag
    def get_extends(self):
        return self.extends
    def set_extends(self, extends):
        self.extends = extends
    def get_base(self):
        return self.base
    def set_base(self, base):
        self.base = base
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_profileIdType(self, value):
        # Validate type cdf:profileIdType, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_profileIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_profileIdType_patterns_, ))
    validate_profileIdType_patterns_ = [['^(xccdf_[^_]+_profile_.+)$']]
    def has__content(self):
        if (
            self.status or
            self.dc_status or
            self.version is not None or
            self.title or
            self.description or
            self.reference or
            self.platform or
            self.select or
            self.set_complex_value or
            self.set_value or
            self.refine_value or
            self.refine_rule or
            self.metadata or
            self.signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='profileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('profileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'profileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profileType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='profileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='profileType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.prohibitChanges != "false" and 'prohibitChanges' not in already_processed:
            already_processed.add('prohibitChanges')
            outfile.write(' prohibitChanges=%s' % (quote_attrib(self.prohibitChanges), ))
        if self.abstract != "false" and 'abstract' not in already_processed:
            already_processed.add('abstract')
            outfile.write(' abstract=%s' % (quote_attrib(self.abstract), ))
        if self.note_tag is not None and 'note_tag' not in already_processed:
            already_processed.add('note_tag')
            outfile.write(' note-tag=%s' % (quote_attrib(self.note_tag), ))
        if self.extends is not None and 'extends' not in already_processed:
            already_processed.add('extends')
            outfile.write(' extends=%s' % (quote_attrib(self.extends), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.add('base')
            outfile.write(' xml:base=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.base), input_name='base')), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='profileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for status_ in self.status:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            status_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='status', pretty_print=pretty_print)
        for dc_status_ in self.dc_status:
            namespaceprefix_ = self.dc_status_nsprefix_ + ':' if (UseCapturedNS_ and self.dc_status_nsprefix_) else ''
            dc_status_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dc-status', pretty_print=pretty_print)
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            platform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='platform', pretty_print=pretty_print)
        for select_ in self.select:
            namespaceprefix_ = self.select_nsprefix_ + ':' if (UseCapturedNS_ and self.select_nsprefix_) else ''
            select_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='select', pretty_print=pretty_print)
        for set_complex_value_ in self.set_complex_value:
            namespaceprefix_ = self.set_complex_value_nsprefix_ + ':' if (UseCapturedNS_ and self.set_complex_value_nsprefix_) else ''
            set_complex_value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='set-complex-value', pretty_print=pretty_print)
        for set_value_ in self.set_value:
            namespaceprefix_ = self.set_value_nsprefix_ + ':' if (UseCapturedNS_ and self.set_value_nsprefix_) else ''
            set_value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='set-value', pretty_print=pretty_print)
        for refine_value_ in self.refine_value:
            namespaceprefix_ = self.refine_value_nsprefix_ + ':' if (UseCapturedNS_ and self.refine_value_nsprefix_) else ''
            refine_value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='refine-value', pretty_print=pretty_print)
        for refine_rule_ in self.refine_rule:
            namespaceprefix_ = self.refine_rule_nsprefix_ + ':' if (UseCapturedNS_ and self.refine_rule_nsprefix_) else ''
            refine_rule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='refine-rule', pretty_print=pretty_print)
        for metadata_ in self.metadata:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            metadata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
        if self.signature is not None:
            namespaceprefix_ = self.signature_nsprefix_ + ':' if (UseCapturedNS_ and self.signature_nsprefix_) else ''
            self.signature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_profileIdType(self.id)    # validate type profileIdType
        value = find_attr_value_('prohibitChanges', node)
        if value is not None and 'prohibitChanges' not in already_processed:
            already_processed.add('prohibitChanges')
            self.prohibitChanges = value
        value = find_attr_value_('abstract', node)
        if value is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            self.abstract = value
        value = find_attr_value_('note-tag', node)
        if value is not None and 'note-tag' not in already_processed:
            already_processed.add('note-tag')
            self.note_tag = value
        value = find_attr_value_('extends', node)
        if value is not None and 'extends' not in already_processed:
            already_processed.add('extends')
            self.extends = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.add('base')
            self.base = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'status':
            obj_ = status.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.status.append(obj_)
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'dc-status':
            obj_ = dc_statusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dc_status.append(obj_)
            obj_.original_tagname_ = 'dc-status'
        elif nodeName_ == 'version':
            obj_ = versionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'title':
            obj_ = textWithSubType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, htmlTextWithSubType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'reference':
            obj_ = referenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'platform':
            obj_ = overrideableCPE2idrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
        elif nodeName_ == 'select':
            obj_ = profileSelectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.select.append(obj_)
            obj_.original_tagname_ = 'select'
        elif nodeName_ == 'set-complex-value':
            obj_ = profileSetComplexValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.set_complex_value.append(obj_)
            obj_.original_tagname_ = 'set-complex-value'
        elif nodeName_ == 'set-value':
            obj_ = profileSetValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.set_value.append(obj_)
            obj_.original_tagname_ = 'set-value'
        elif nodeName_ == 'refine-value':
            obj_ = profileRefineValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.refine_value.append(obj_)
            obj_.original_tagname_ = 'refine-value'
        elif nodeName_ == 'refine-rule':
            obj_ = profileRefineRuleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.refine_rule.append(obj_)
            obj_.original_tagname_ = 'refine-rule'
        elif nodeName_ == 'metadata':
            obj_ = metadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata.append(obj_)
            obj_.original_tagname_ = 'metadata'
        elif nodeName_ == 'signature':
            obj_ = signatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature = obj_
            obj_.original_tagname_ = 'signature'
# end class profileType


class profileSelectType(GeneratedsSuper):
    """remark -- Explanatory material or other
    prose.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, selected=None, remark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
        self.selected = _cast(None, selected)
        self.selected_nsprefix_ = None
        if remark is None:
            self.remark = []
        else:
            self.remark = remark
        self.remark_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, profileSelectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if profileSelectType.subclass:
            return profileSelectType.subclass(*args_, **kwargs_)
        else:
            return profileSelectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_remark(self):
        return self.remark
    def set_remark(self, remark):
        self.remark = remark
    def add_remark(self, value):
        self.remark.append(value)
    def insert_remark_at(self, index, value):
        self.remark.insert(index, value)
    def replace_remark_at(self, index, value):
        self.remark[index] = value
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def get_selected(self):
        return self.selected
    def set_selected(self, selected):
        self.selected = selected
    def has__content(self):
        if (
            self.remark
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='profileSelectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('profileSelectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'profileSelectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profileSelectType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='profileSelectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='profileSelectType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.selected is not None and 'selected' not in already_processed:
            already_processed.add('selected')
            outfile.write(' selected=%s' % (quote_attrib(self.selected), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='profileSelectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remark_ in self.remark:
            namespaceprefix_ = self.remark_nsprefix_ + ':' if (UseCapturedNS_ and self.remark_nsprefix_) else ''
            remark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('selected', node)
        if value is not None and 'selected' not in already_processed:
            already_processed.add('selected')
            self.selected = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'remark':
            obj_ = textType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remark.append(obj_)
            obj_.original_tagname_ = 'remark'
# end class profileSelectType


class profileSetValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, profileSetValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if profileSetValueType.subclass:
            return profileSetValueType.subclass(*args_, **kwargs_)
        else:
            return profileSetValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='profileSetValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('profileSetValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'profileSetValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profileSetValueType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='profileSetValueType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='profileSetValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class profileSetValueType


class profileSetComplexValueType(complexValueType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = complexValueType
    def __init__(self, item=None, idref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        super(globals().get("profileSetComplexValueType"), self).__init__(item,  **kwargs_)
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, profileSetComplexValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if profileSetComplexValueType.subclass:
            return profileSetComplexValueType.subclass(*args_, **kwargs_)
        else:
            return profileSetComplexValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def has__content(self):
        if (
            super(profileSetComplexValueType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='profileSetComplexValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('profileSetComplexValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'profileSetComplexValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profileSetComplexValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='profileSetComplexValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='profileSetComplexValueType'):
        super(profileSetComplexValueType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profileSetComplexValueType')
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='profileSetComplexValueType', fromsubclass_=False, pretty_print=True):
        super(profileSetComplexValueType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        super(profileSetComplexValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(profileSetComplexValueType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class profileSetComplexValueType


class profileRefineValueType(GeneratedsSuper):
    """remark -- Explanatory material or other
    prose.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, selector=None, operator=None, remark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
        self.selector = _cast(None, selector)
        self.selector_nsprefix_ = None
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        if remark is None:
            self.remark = []
        else:
            self.remark = remark
        self.remark_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, profileRefineValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if profileRefineValueType.subclass:
            return profileRefineValueType.subclass(*args_, **kwargs_)
        else:
            return profileRefineValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_remark(self):
        return self.remark
    def set_remark(self, remark):
        self.remark = remark
    def add_remark(self, value):
        self.remark.append(value)
    def insert_remark_at(self, index, value):
        self.remark.insert(index, value)
    def replace_remark_at(self, index, value):
        self.remark[index] = value
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def get_selector(self):
        return self.selector
    def set_selector(self, selector):
        self.selector = selector
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def validate_valueOperatorType(self, value):
        # Validate type cdf:valueOperatorType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['equals', 'not equal', 'greater than', 'less than', 'greater than or equal', 'less than or equal', 'pattern match']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valueOperatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.remark
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='profileRefineValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('profileRefineValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'profileRefineValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profileRefineValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='profileRefineValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='profileRefineValueType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.selector is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            outfile.write(' selector=%s' % (quote_attrib(self.selector), ))
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='profileRefineValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remark_ in self.remark:
            namespaceprefix_ = self.remark_nsprefix_ + ':' if (UseCapturedNS_ and self.remark_nsprefix_) else ''
            remark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('selector', node)
        if value is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            self.selector = value
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_valueOperatorType(self.operator)    # validate type valueOperatorType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'remark':
            obj_ = textType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remark.append(obj_)
            obj_.original_tagname_ = 'remark'
# end class profileRefineValueType


class profileRefineRuleType(GeneratedsSuper):
    """remark -- Explanatory material or other
    prose.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, weight=None, selector=None, severity=None, role=None, remark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        self.selector = _cast(None, selector)
        self.selector_nsprefix_ = None
        self.severity = _cast(None, severity)
        self.severity_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        if remark is None:
            self.remark = []
        else:
            self.remark = remark
        self.remark_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, profileRefineRuleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if profileRefineRuleType.subclass:
            return profileRefineRuleType.subclass(*args_, **kwargs_)
        else:
            return profileRefineRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_remark(self):
        return self.remark
    def set_remark(self, remark):
        self.remark = remark
    def add_remark(self, value):
        self.remark.append(value)
    def insert_remark_at(self, index, value):
        self.remark.insert(index, value)
    def replace_remark_at(self, index, value):
        self.remark[index] = value
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def get_selector(self):
        return self.selector
    def set_selector(self, selector):
        self.selector = selector
    def get_severity(self):
        return self.severity
    def set_severity(self, severity):
        self.severity = severity
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def validate_weightType(self, value):
        # Validate type cdf:weightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on weightType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on weightType' % {"value": value, "lineno": lineno} )
                result = False
    def validate_severityEnumType(self, value):
        # Validate type cdf:severityEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['unknown', 'info', 'low', 'medium', 'high']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on severityEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_roleEnumType(self, value):
        # Validate type cdf:roleEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['full', 'unscored', 'unchecked']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on roleEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.remark
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='profileRefineRuleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('profileRefineRuleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'profileRefineRuleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profileRefineRuleType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='profileRefineRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='profileRefineRuleType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (quote_attrib(self.weight), ))
        if self.selector is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            outfile.write(' selector=%s' % (quote_attrib(self.selector), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='profileRefineRuleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remark_ in self.remark:
            namespaceprefix_ = self.remark_nsprefix_ + ':' if (UseCapturedNS_ and self.remark_nsprefix_) else ''
            remark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_weightType(self.weight)    # validate type weightType
        value = find_attr_value_('selector', node)
        if value is not None and 'selector' not in already_processed:
            already_processed.add('selector')
            self.selector = value
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            self.severity = value
            self.validate_severityEnumType(self.severity)    # validate type severityEnumType
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.validate_roleEnumType(self.role)    # validate type roleEnumType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'remark':
            obj_ = textType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remark.append(obj_)
            obj_.original_tagname_ = 'remark'
# end class profileRefineRuleType


class testResultType(GeneratedsSuper):
    """benchmark -- Reference to the
    <
    xccdf:Benchmark
    >
    for
    which the
    <
    xccdf:TestResult
    >
    records results. This property is
    required if this
    <
    xccdf:TestResult
    >
    element is the top-level element
    and optional otherwise.
    tailoring-file -- The tailoring file element contains attributes
    used to identify an
    <
    xccdf:Tailoring
    >
    element used to guide the
    assessment reported on in this
    <
    xccdf:TestResult
    >
    . The tailoring
    element is required in an
    <
    xccdf:TestResult
    >
    if and only if an
    <
    xccdf:Tailoring
    >
    element guided the assessment recorded in the
    <
    xccdf:TestResult
    >
    or if the
    <
    xccdf:Tailoring
    >
    element records
    manual tailoring actions applied to this assessment.
    title -- Title of the test.
    remark -- A remark about the test, possibly supplied by
    the person administering the
    <
    xccdf:Benchmark
    >
    assessment
    organization -- The name of the organization or other entity
    responsible for applying this
    <
    xccdf:Benchmark
    >
    and generating this
    result. When multiple
    <
    xccdf:organization
    >
    elements are used to
    indicate multiple organization names in a hierarchical organization, the
    highest-level organization should appear first.
    identity -- Information about the system identity or user
    employed during application of the
    <
    xccdf:Benchmark
    >
    . If used,
    specifies the name of the authenticated identity.
    profile -- The
    <
    xccdf:profile
    >
    element holds the
    value of the @id attribute value of the
    <
    xccdf:Profile
    >
    selected to be
    used in the assessment reported on by this
    <
    xccdf:TestResult
    >
    . This
    <
    xccdf:Profile
    >
    might be from the
    <
    xccdf:Benchmark
    >
    or from an
    <
    xccdf:Tailoring
    >
    file, if used. This element should appear if and
    only if an
    <
    xccdf:Profile
    >
    was selected to guide the
    assessment.
    target -- Name or description of the target system whose
    test results are recorded in the
    <
    xccdf:TestResult
    >
    element (the
    system to which an
    <
    xccdf:Benchmark
    >
    test was applied). Each
    appearance of the element supplies a name by which the target host or device
    was identified at the time the test was run. The name may be any string, but
    applications should include the fully qualified DNS name whenever possible.
      
    * target-address -- Network address of the target system to which
      an
      <
      xccdf:Benchmark
      >
      test was applied. Typical forms for the address
      include IP version 4 (IPv4), IP version 6 (IPv6), and Ethernet media access
      control (MAC).
    * target-facts -- A list of named facts about the target system
      or platform.
    * target-id-ref -- References to external structures with
      identifying information about the target of this
      assessment.
    * platform -- A platform on the target system. There should
      be one instance of this property for every platform that the target system
      was found to meet.
    * set-value -- Specific setting for a single
      <
      xccdf:Value
      >
      element used during the test.
    * set-complex-value -- Specific setting for a single
      <
      xccdf:Value
      >
      element used during the test when the given value is
      set to a complex type, such as a list.
    * rule-result -- The result of a single instance of an
      <
      xccdf:Rule
      >
      application against the target. The
      <
      xccdf:TestResult
      >
      must include at least one
      <
      xccdf:rule-result
      >
      record for each
      <
      xccdf:Rule
      >
      that was selected in the resolved
      <
      xccdf:Benchmark
      >
      .
    * score -- An overall score for this
      <
      xccdf:Benchmark
      >
      test.
    * metadata -- XML metadata associated with this
      <
      xccdf:TestResult
      >
      .
    * signature -- A digital signature asserting authorship and
      allowing verification of the integrity of the
      <
      xccdf:TestResult
      >
      .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, start_time=None, end_time=None, test_system=None, version=None, Id=None, benchmark=None, tailoring_file=None, title=None, remark=None, organization=None, identity=None, profile=None, target=None, target_address=None, target_facts=None, target_id_ref=None, anytypeobjs_=None, platform=None, set_value=None, set_complex_value=None, rule_result=None, score=None, metadata=None, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.start_time = _cast(None, start_time)
        self.start_time_nsprefix_ = None
        self.end_time = _cast(None, end_time)
        self.end_time_nsprefix_ = None
        self.test_system = _cast(None, test_system)
        self.test_system_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.benchmark = benchmark
        self.benchmark_nsprefix_ = "cdf"
        self.tailoring_file = tailoring_file
        self.tailoring_file_nsprefix_ = "cdf"
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = "cdf"
        if remark is None:
            self.remark = []
        else:
            self.remark = remark
        self.remark_nsprefix_ = "cdf"
        if organization is None:
            self.organization = []
        else:
            self.organization = organization
        self.organization_nsprefix_ = None
        self.identity = identity
        self.identity_nsprefix_ = "cdf"
        self.profile = profile
        self.profile_nsprefix_ = "cdf"
        if target is None:
            self.target = []
        else:
            self.target = target
        self.target_nsprefix_ = None
        if target_address is None:
            self.target_address = []
        else:
            self.target_address = target_address
        self.target_address_nsprefix_ = None
        self.target_facts = target_facts
        self.target_facts_nsprefix_ = "cdf"
        if target_id_ref is None:
            self.target_id_ref = []
        else:
            self.target_id_ref = target_id_ref
        self.target_id_ref_nsprefix_ = "cdf"
        self.anytypeobjs_ = anytypeobjs_
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = "cdf"
        if set_value is None:
            self.set_value = []
        else:
            self.set_value = set_value
        self.set_value_nsprefix_ = "cdf"
        if set_complex_value is None:
            self.set_complex_value = []
        else:
            self.set_complex_value = set_complex_value
        self.set_complex_value_nsprefix_ = "cdf"
        if rule_result is None:
            self.rule_result = []
        else:
            self.rule_result = rule_result
        self.rule_result_nsprefix_ = "cdf"
        if score is None:
            self.score = []
        else:
            self.score = score
        self.score_nsprefix_ = "cdf"
        if metadata is None:
            self.metadata = []
        else:
            self.metadata = metadata
        self.metadata_nsprefix_ = "cdf"
        self.signature = signature
        self.signature_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, testResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if testResultType.subclass:
            return testResultType.subclass(*args_, **kwargs_)
        else:
            return testResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_benchmark(self):
        return self.benchmark
    def set_benchmark(self, benchmark):
        self.benchmark = benchmark
    def get_tailoring_file(self):
        return self.tailoring_file
    def set_tailoring_file(self, tailoring_file):
        self.tailoring_file = tailoring_file
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_remark(self):
        return self.remark
    def set_remark(self, remark):
        self.remark = remark
    def add_remark(self, value):
        self.remark.append(value)
    def insert_remark_at(self, index, value):
        self.remark.insert(index, value)
    def replace_remark_at(self, index, value):
        self.remark[index] = value
    def get_organization(self):
        return self.organization
    def set_organization(self, organization):
        self.organization = organization
    def add_organization(self, value):
        self.organization.append(value)
    def insert_organization_at(self, index, value):
        self.organization.insert(index, value)
    def replace_organization_at(self, index, value):
        self.organization[index] = value
    def get_identity(self):
        return self.identity
    def set_identity(self, identity):
        self.identity = identity
    def get_profile(self):
        return self.profile
    def set_profile(self, profile):
        self.profile = profile
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def add_target(self, value):
        self.target.append(value)
    def insert_target_at(self, index, value):
        self.target.insert(index, value)
    def replace_target_at(self, index, value):
        self.target[index] = value
    def get_target_address(self):
        return self.target_address
    def set_target_address(self, target_address):
        self.target_address = target_address
    def add_target_address(self, value):
        self.target_address.append(value)
    def insert_target_address_at(self, index, value):
        self.target_address.insert(index, value)
    def replace_target_address_at(self, index, value):
        self.target_address[index] = value
    def get_target_facts(self):
        return self.target_facts
    def set_target_facts(self, target_facts):
        self.target_facts = target_facts
    def get_target_id_ref(self):
        return self.target_id_ref
    def set_target_id_ref(self, target_id_ref):
        self.target_id_ref = target_id_ref
    def add_target_id_ref(self, value):
        self.target_id_ref.append(value)
    def insert_target_id_ref_at(self, index, value):
        self.target_id_ref.insert(index, value)
    def replace_target_id_ref_at(self, index, value):
        self.target_id_ref[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def add_platform(self, value):
        self.platform.append(value)
    def insert_platform_at(self, index, value):
        self.platform.insert(index, value)
    def replace_platform_at(self, index, value):
        self.platform[index] = value
    def get_set_value(self):
        return self.set_value
    def set_set_value(self, set_value):
        self.set_value = set_value
    def add_set_value(self, value):
        self.set_value.append(value)
    def insert_set_value_at(self, index, value):
        self.set_value.insert(index, value)
    def replace_set_value_at(self, index, value):
        self.set_value[index] = value
    def get_set_complex_value(self):
        return self.set_complex_value
    def set_set_complex_value(self, set_complex_value):
        self.set_complex_value = set_complex_value
    def add_set_complex_value(self, value):
        self.set_complex_value.append(value)
    def insert_set_complex_value_at(self, index, value):
        self.set_complex_value.insert(index, value)
    def replace_set_complex_value_at(self, index, value):
        self.set_complex_value[index] = value
    def get_rule_result(self):
        return self.rule_result
    def set_rule_result(self, rule_result):
        self.rule_result = rule_result
    def add_rule_result(self, value):
        self.rule_result.append(value)
    def insert_rule_result_at(self, index, value):
        self.rule_result.insert(index, value)
    def replace_rule_result_at(self, index, value):
        self.rule_result[index] = value
    def get_score(self):
        return self.score
    def set_score(self, score):
        self.score = score
    def add_score(self, value):
        self.score.append(value)
    def insert_score_at(self, index, value):
        self.score.insert(index, value)
    def replace_score_at(self, index, value):
        self.score[index] = value
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def add_metadata(self, value):
        self.metadata.append(value)
    def insert_metadata_at(self, index, value):
        self.metadata.insert(index, value)
    def replace_metadata_at(self, index, value):
        self.metadata[index] = value
    def get_signature(self):
        return self.signature
    def set_signature(self, signature):
        self.signature = signature
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_start_time(self):
        return self.start_time
    def set_start_time(self, start_time):
        self.start_time = start_time
    def get_end_time(self):
        return self.end_time
    def set_end_time(self, end_time):
        self.end_time = end_time
    def get_test_system(self):
        return self.test_system
    def set_test_system(self, test_system):
        self.test_system = test_system
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_testresultIdType(self, value):
        # Validate type cdf:testresultIdType, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_testresultIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_testresultIdType_patterns_, ))
    validate_testresultIdType_patterns_ = [['^(xccdf_[^_]+_testresult_.+)$']]
    def has__content(self):
        if (
            self.benchmark is not None or
            self.tailoring_file is not None or
            self.title or
            self.remark or
            self.organization or
            self.identity is not None or
            self.profile is not None or
            self.target or
            self.target_address or
            self.target_facts is not None or
            self.target_id_ref or
            self.anytypeobjs_ is not None or
            self.platform or
            self.set_value or
            self.set_complex_value or
            self.rule_result or
            self.score or
            self.metadata or
            self.signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='testResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('testResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'testResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='testResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='testResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='testResultType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.start_time is not None and 'start_time' not in already_processed:
            already_processed.add('start_time')
            outfile.write(' start-time=%s' % (quote_attrib(self.start_time), ))
        if self.end_time is not None and 'end_time' not in already_processed:
            already_processed.add('end_time')
            outfile.write(' end-time=%s' % (quote_attrib(self.end_time), ))
        if self.test_system is not None and 'test_system' not in already_processed:
            already_processed.add('test_system')
            outfile.write(' test-system=%s' % (quote_attrib(self.test_system), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='testResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.benchmark is not None:
            namespaceprefix_ = self.benchmark_nsprefix_ + ':' if (UseCapturedNS_ and self.benchmark_nsprefix_) else ''
            self.benchmark.export(outfile, level, namespaceprefix_, namespacedef_='', name_='benchmark', pretty_print=pretty_print)
        if self.tailoring_file is not None:
            namespaceprefix_ = self.tailoring_file_nsprefix_ + ':' if (UseCapturedNS_ and self.tailoring_file_nsprefix_) else ''
            self.tailoring_file.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tailoring-file', pretty_print=pretty_print)
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for remark_ in self.remark:
            namespaceprefix_ = self.remark_nsprefix_ + ':' if (UseCapturedNS_ and self.remark_nsprefix_) else ''
            remark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remark', pretty_print=pretty_print)
        for organization_ in self.organization:
            namespaceprefix_ = self.organization_nsprefix_ + ':' if (UseCapturedNS_ and self.organization_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganization>%s</%sorganization>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(organization_), input_name='organization')), namespaceprefix_ , eol_))
        if self.identity is not None:
            namespaceprefix_ = self.identity_nsprefix_ + ':' if (UseCapturedNS_ and self.identity_nsprefix_) else ''
            self.identity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='identity', pretty_print=pretty_print)
        if self.profile is not None:
            namespaceprefix_ = self.profile_nsprefix_ + ':' if (UseCapturedNS_ and self.profile_nsprefix_) else ''
            self.profile.export(outfile, level, namespaceprefix_, namespacedef_='', name_='profile', pretty_print=pretty_print)
        for target_ in self.target:
            namespaceprefix_ = self.target_nsprefix_ + ':' if (UseCapturedNS_ and self.target_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget>%s</%starget>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(target_), input_name='target')), namespaceprefix_ , eol_))
        for target_address_ in self.target_address:
            namespaceprefix_ = self.target_address_nsprefix_ + ':' if (UseCapturedNS_ and self.target_address_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget-address>%s</%starget-address>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(target_address_), input_name='target-address')), namespaceprefix_ , eol_))
        if self.target_facts is not None:
            namespaceprefix_ = self.target_facts_nsprefix_ + ':' if (UseCapturedNS_ and self.target_facts_nsprefix_) else ''
            self.target_facts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='target-facts', pretty_print=pretty_print)
        for target_id_ref_ in self.target_id_ref:
            namespaceprefix_ = self.target_id_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.target_id_ref_nsprefix_) else ''
            target_id_ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='target-id-ref', pretty_print=pretty_print)
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            platform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='platform', pretty_print=pretty_print)
        for set_value_ in self.set_value:
            namespaceprefix_ = self.set_value_nsprefix_ + ':' if (UseCapturedNS_ and self.set_value_nsprefix_) else ''
            set_value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='set-value', pretty_print=pretty_print)
        for set_complex_value_ in self.set_complex_value:
            namespaceprefix_ = self.set_complex_value_nsprefix_ + ':' if (UseCapturedNS_ and self.set_complex_value_nsprefix_) else ''
            set_complex_value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='set-complex-value', pretty_print=pretty_print)
        for rule_result_ in self.rule_result:
            namespaceprefix_ = self.rule_result_nsprefix_ + ':' if (UseCapturedNS_ and self.rule_result_nsprefix_) else ''
            rule_result_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rule-result', pretty_print=pretty_print)
        for score_ in self.score:
            namespaceprefix_ = self.score_nsprefix_ + ':' if (UseCapturedNS_ and self.score_nsprefix_) else ''
            score_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='score', pretty_print=pretty_print)
        for metadata_ in self.metadata:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            metadata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
        if self.signature is not None:
            namespaceprefix_ = self.signature_nsprefix_ + ':' if (UseCapturedNS_ and self.signature_nsprefix_) else ''
            self.signature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signature', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_testresultIdType(self.id)    # validate type testresultIdType
        value = find_attr_value_('start-time', node)
        if value is not None and 'start-time' not in already_processed:
            already_processed.add('start-time')
            self.start_time = value
        value = find_attr_value_('end-time', node)
        if value is not None and 'end-time' not in already_processed:
            already_processed.add('end-time')
            self.end_time = value
        value = find_attr_value_('test-system', node)
        if value is not None and 'test-system' not in already_processed:
            already_processed.add('test-system')
            self.test_system = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'benchmark':
            class_obj_ = self.get_class_obj_(child_, benchmarkReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.benchmark = obj_
            obj_.original_tagname_ = 'benchmark'
        elif nodeName_ == 'tailoring-file':
            obj_ = tailoringReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tailoring_file = obj_
            obj_.original_tagname_ = 'tailoring-file'
        elif nodeName_ == 'title':
            obj_ = textType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'remark':
            obj_ = textType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remark.append(obj_)
            obj_.original_tagname_ = 'remark'
        elif nodeName_ == 'organization':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'organization')
            value_ = self.gds_validate_string(value_, node, 'organization')
            self.organization.append(value_)
            self.organization_nsprefix_ = child_.prefix
        elif nodeName_ == 'identity':
            obj_ = identityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.identity = obj_
            obj_.original_tagname_ = 'identity'
        elif nodeName_ == 'profile':
            class_obj_ = self.get_class_obj_(child_, idrefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.profile = obj_
            obj_.original_tagname_ = 'profile'
        elif nodeName_ == 'target':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'target')
            value_ = self.gds_validate_string(value_, node, 'target')
            self.target.append(value_)
            self.target_nsprefix_ = child_.prefix
        elif nodeName_ == 'user':
            obj_ = UserType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target.append(obj_)
            obj_.original_tagname_ = 'user'
        elif nodeName_ == 'system':
            obj_ = system.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target.append(obj_)
            obj_.original_tagname_ = 'system'
        elif nodeName_ == 'target-address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'target_address')
            value_ = self.gds_validate_string(value_, node, 'target_address')
            self.target_address.append(value_)
            self.target_address_nsprefix_ = child_.prefix
        elif nodeName_ == 'target-facts':
            obj_ = targetFactsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target_facts = obj_
            obj_.original_tagname_ = 'target-facts'
        elif nodeName_ == 'target-id-ref':
            obj_ = targetIdRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target_id_ref.append(obj_)
            obj_.original_tagname_ = 'target-id-ref'
        elif nodeName_ == 'platform':
            class_obj_ = self.get_class_obj_(child_, CPE2idrefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
        elif nodeName_ == 'set-value':
            obj_ = profileSetValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.set_value.append(obj_)
            obj_.original_tagname_ = 'set-value'
        elif nodeName_ == 'set-complex-value':
            obj_ = profileSetComplexValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.set_complex_value.append(obj_)
            obj_.original_tagname_ = 'set-complex-value'
        elif nodeName_ == 'rule-result':
            obj_ = ruleResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rule_result.append(obj_)
            obj_.original_tagname_ = 'rule-result'
        elif nodeName_ == 'score':
            obj_ = scoreType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.score.append(obj_)
            obj_.original_tagname_ = 'score'
        elif nodeName_ == 'metadata':
            obj_ = metadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata.append(obj_)
            obj_.original_tagname_ = 'metadata'
        elif nodeName_ == 'signature':
            obj_ = signatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature = obj_
            obj_.original_tagname_ = 'signature'
        else:
            content_ = self.gds_build_any(child_, 'testResultType')
            self.set_anytypeobjs_(content_)
# end class testResultType


class benchmarkReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, id=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, benchmarkReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if benchmarkReferenceType.subclass:
            return benchmarkReferenceType.subclass(*args_, **kwargs_)
        else:
            return benchmarkReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='benchmarkReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('benchmarkReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'benchmarkReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='benchmarkReferenceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='benchmarkReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='benchmarkReferenceType'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='benchmarkReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class benchmarkReferenceType


class scoreType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, system=None, maximum=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.maximum = _cast(None, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scoreType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scoreType.subclass:
            return scoreType.subclass(*args_, **kwargs_)
        else:
            return scoreType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='scoreType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scoreType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scoreType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scoreType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='scoreType'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum=%s' % (quote_attrib(self.maximum), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='scoreType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class scoreType


class targetFactsType(GeneratedsSuper):
    """fact -- A named fact about the target system or
    platform.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        if fact is None:
            self.fact = []
        else:
            self.fact = fact
        self.fact_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, targetFactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if targetFactsType.subclass:
            return targetFactsType.subclass(*args_, **kwargs_)
        else:
            return targetFactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fact(self):
        return self.fact
    def set_fact(self, fact):
        self.fact = fact
    def add_fact(self, value):
        self.fact.append(value)
    def insert_fact_at(self, index, value):
        self.fact.insert(index, value)
    def replace_fact_at(self, index, value):
        self.fact[index] = value
    def has__content(self):
        if (
            self.fact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='targetFactsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('targetFactsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'targetFactsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='targetFactsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='targetFactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='targetFactsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='targetFactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fact_ in self.fact:
            namespaceprefix_ = self.fact_nsprefix_ + ':' if (UseCapturedNS_ and self.fact_nsprefix_) else ''
            fact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fact':
            obj_ = factType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fact.append(obj_)
            obj_.original_tagname_ = 'fact'
# end class targetFactsType


class targetIdRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, system=None, href=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, targetIdRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if targetIdRefType.subclass:
            return targetIdRefType.subclass(*args_, **kwargs_)
        else:
            return targetIdRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='targetIdRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('targetIdRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'targetIdRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='targetIdRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='targetIdRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='targetIdRefType'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='targetIdRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class targetIdRefType


class identityType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, authenticated=None, privileged=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.authenticated = _cast(None, authenticated)
        self.authenticated_nsprefix_ = None
        self.privileged = _cast(None, privileged)
        self.privileged_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, identityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if identityType.subclass:
            return identityType.subclass(*args_, **kwargs_)
        else:
            return identityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_authenticated(self):
        return self.authenticated
    def set_authenticated(self, authenticated):
        self.authenticated = authenticated
    def get_privileged(self):
        return self.privileged
    def set_privileged(self, privileged):
        self.privileged = privileged
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='identityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('identityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'identityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='identityType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='identityType'):
        if self.authenticated is not None and 'authenticated' not in already_processed:
            already_processed.add('authenticated')
            outfile.write(' authenticated=%s' % (quote_attrib(self.authenticated), ))
        if self.privileged is not None and 'privileged' not in already_processed:
            already_processed.add('privileged')
            outfile.write(' privileged=%s' % (quote_attrib(self.privileged), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='identityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('authenticated', node)
        if value is not None and 'authenticated' not in already_processed:
            already_processed.add('authenticated')
            self.authenticated = value
        value = find_attr_value_('privileged', node)
        if value is not None and 'privileged' not in already_processed:
            already_processed.add('privileged')
            self.privileged = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class identityType


class factType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, type_='boolean', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, factType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if factType.subclass:
            return factType.subclass(*args_, **kwargs_)
        else:
            return factType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_valueTypeType(self, value):
        # Validate type cdf:valueTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['number', 'string', 'boolean']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on valueTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='factType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('factType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'factType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='factType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='factType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.type_ != "boolean" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='factType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_valueTypeType(self.type_)    # validate type valueTypeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class factType


class tailoringReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, id=None, version=None, time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.time = _cast(None, time)
        self.time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tailoringReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tailoringReferenceType.subclass:
            return tailoringReferenceType.subclass(*args_, **kwargs_)
        else:
            return tailoringReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='tailoringReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tailoringReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tailoringReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tailoringReferenceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tailoringReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='tailoringReferenceType'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (quote_attrib(self.time), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='tailoringReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            self.time = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tailoringReferenceType


class ruleResultType(GeneratedsSuper):
    """result -- Result of applying the referenced
    <
    xccdf:Rule
    >
    to a target or target component. (E.g., Pass, Fail, etc.)
      
    * override -- An XML block explaining how and why an auditor
      chose to override the result.
    * ident -- A long-term globally meaningful identifier for
      the issue, vulnerability, platform, etc. copied from the referenced
      <
      xccdf:Rule
      >
      .
    * metadata -- XML metadata associated with this
      <
      xccdf:rule-result
      >
      .
    * message -- Diagnostic messages from the checking engine.
      These elements do not affect scoring; they are present merely to convey
      diagnostic information from the checking engine.
    * instance -- Name of the target subsystem or component to
      which this result applies, for a multiply instantiated
      <
      xccdf:Rule
      >
      .
      The element is important for an
      <
      xccdf:Rule
      >
      that applies to
      components of the target system, especially when a target might have several
      such components, and where the @multiple attribute of the
      <
      xccdf:Rule
      >
      is set to true.
    * fix -- Fix script for this target platform, if
      available (would normally appear only for result values of
      
      fail
      
      ). It is
      assumed to have been
      
      instantiated
      
      by the testing tool and any
      substitutions or platform selections already made.
    * check -- Encapsulated or referenced results to
      detailed testing output from the checking engine (if
      any).
    * complex-check -- A copy of the
      <
      xccdf:Rule
      >
      element
      
      s
      <
      xccdf:complex-check
      >
      element where each component
      <
      xccdf:check
      >
      element of the
      <
      xccdf:complex-check
      >
      element
      is an encapsulated or referenced results to detailed testing output from
      the checking engine (if any) as described in the
      <
      xccdf:rule-result
      >
      <
      xccdf:check
      >
      property.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, role=None, severity=None, time=None, version=None, weight=None, result=None, override=None, ident=None, metadata=None, message=None, instance=None, fix=None, check=None, complex_check=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.severity = _cast(None, severity)
        self.severity_nsprefix_ = None
        self.time = _cast(None, time)
        self.time_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.weight = _cast(None, weight)
        self.weight_nsprefix_ = None
        self.result = result
        self.validate_resultEnumType(self.result)
        self.result_nsprefix_ = "cdf"
        if override is None:
            self.override = []
        else:
            self.override = override
        self.override_nsprefix_ = "cdf"
        if ident is None:
            self.ident = []
        else:
            self.ident = ident
        self.ident_nsprefix_ = "cdf"
        if metadata is None:
            self.metadata = []
        else:
            self.metadata = metadata
        self.metadata_nsprefix_ = "cdf"
        if message is None:
            self.message = []
        else:
            self.message = message
        self.message_nsprefix_ = "cdf"
        if instance is None:
            self.instance = []
        else:
            self.instance = instance
        self.instance_nsprefix_ = "cdf"
        if fix is None:
            self.fix = []
        else:
            self.fix = fix
        self.fix_nsprefix_ = "cdf"
        if check is None:
            self.check = []
        else:
            self.check = check
        self.check_nsprefix_ = "cdf"
        self.complex_check = complex_check
        self.complex_check_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ruleResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ruleResultType.subclass:
            return ruleResultType.subclass(*args_, **kwargs_)
        else:
            return ruleResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def get_override(self):
        return self.override
    def set_override(self, override):
        self.override = override
    def add_override(self, value):
        self.override.append(value)
    def insert_override_at(self, index, value):
        self.override.insert(index, value)
    def replace_override_at(self, index, value):
        self.override[index] = value
    def get_ident(self):
        return self.ident
    def set_ident(self, ident):
        self.ident = ident
    def add_ident(self, value):
        self.ident.append(value)
    def insert_ident_at(self, index, value):
        self.ident.insert(index, value)
    def replace_ident_at(self, index, value):
        self.ident[index] = value
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def add_metadata(self, value):
        self.metadata.append(value)
    def insert_metadata_at(self, index, value):
        self.metadata.insert(index, value)
    def replace_metadata_at(self, index, value):
        self.metadata[index] = value
    def get_message(self):
        return self.message
    def set_message(self, message):
        self.message = message
    def add_message(self, value):
        self.message.append(value)
    def insert_message_at(self, index, value):
        self.message.insert(index, value)
    def replace_message_at(self, index, value):
        self.message[index] = value
    def get_instance(self):
        return self.instance
    def set_instance(self, instance):
        self.instance = instance
    def add_instance(self, value):
        self.instance.append(value)
    def insert_instance_at(self, index, value):
        self.instance.insert(index, value)
    def replace_instance_at(self, index, value):
        self.instance[index] = value
    def get_fix(self):
        return self.fix
    def set_fix(self, fix):
        self.fix = fix
    def add_fix(self, value):
        self.fix.append(value)
    def insert_fix_at(self, index, value):
        self.fix.insert(index, value)
    def replace_fix_at(self, index, value):
        self.fix[index] = value
    def get_check(self):
        return self.check
    def set_check(self, check):
        self.check = check
    def add_check(self, value):
        self.check.append(value)
    def insert_check_at(self, index, value):
        self.check.insert(index, value)
    def replace_check_at(self, index, value):
        self.check[index] = value
    def get_complex_check(self):
        return self.complex_check
    def set_complex_check(self, complex_check):
        self.complex_check = complex_check
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_severity(self):
        return self.severity
    def set_severity(self, severity):
        self.severity = severity
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def validate_resultEnumType(self, value):
        result = True
        # Validate type resultEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['pass', 'fail', 'error', 'unknown', 'notapplicable', 'notchecked', 'notselected', 'informational', 'fixed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_roleEnumType(self, value):
        # Validate type cdf:roleEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['full', 'unscored', 'unchecked']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on roleEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_severityEnumType(self, value):
        # Validate type cdf:severityEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['unknown', 'info', 'low', 'medium', 'high']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on severityEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_weightType(self, value):
        # Validate type cdf:weightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on weightType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on weightType' % {"value": value, "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.result is not None or
            self.override or
            self.ident or
            self.metadata or
            self.message or
            self.instance or
            self.fix or
            self.check or
            self.complex_check is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='ruleResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ruleResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ruleResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ruleResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ruleResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='ruleResultType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (quote_attrib(self.role), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (quote_attrib(self.time), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (quote_attrib(self.weight), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='ruleResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.result is not None:
            namespaceprefix_ = self.result_nsprefix_ + ':' if (UseCapturedNS_ and self.result_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.result), input_name='result')), namespaceprefix_ , eol_))
        for override_ in self.override:
            namespaceprefix_ = self.override_nsprefix_ + ':' if (UseCapturedNS_ and self.override_nsprefix_) else ''
            override_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='override', pretty_print=pretty_print)
        for ident_ in self.ident:
            namespaceprefix_ = self.ident_nsprefix_ + ':' if (UseCapturedNS_ and self.ident_nsprefix_) else ''
            ident_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ident', pretty_print=pretty_print)
        for metadata_ in self.metadata:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            metadata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
        for message_ in self.message:
            namespaceprefix_ = self.message_nsprefix_ + ':' if (UseCapturedNS_ and self.message_nsprefix_) else ''
            message_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='message', pretty_print=pretty_print)
        for instance_ in self.instance:
            namespaceprefix_ = self.instance_nsprefix_ + ':' if (UseCapturedNS_ and self.instance_nsprefix_) else ''
            instance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instance', pretty_print=pretty_print)
        for fix_ in self.fix:
            namespaceprefix_ = self.fix_nsprefix_ + ':' if (UseCapturedNS_ and self.fix_nsprefix_) else ''
            fix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fix', pretty_print=pretty_print)
        for check_ in self.check:
            namespaceprefix_ = self.check_nsprefix_ + ':' if (UseCapturedNS_ and self.check_nsprefix_) else ''
            check_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='check', pretty_print=pretty_print)
        if self.complex_check is not None:
            namespaceprefix_ = self.complex_check_nsprefix_ + ':' if (UseCapturedNS_ and self.complex_check_nsprefix_) else ''
            self.complex_check.export(outfile, level, namespaceprefix_, namespacedef_='', name_='complex-check', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.validate_roleEnumType(self.role)    # validate type roleEnumType
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            self.severity = value
            self.validate_severityEnumType(self.severity)    # validate type severityEnumType
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            self.time = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            self.weight = value
            self.validate_weightType(self.weight)    # validate type weightType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'result')
            value_ = self.gds_validate_string(value_, node, 'result')
            self.result = value_
            self.result_nsprefix_ = child_.prefix
            # validate type resultEnumType
            self.validate_resultEnumType(self.result)
        elif nodeName_ == 'override':
            obj_ = overrideType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.override.append(obj_)
            obj_.original_tagname_ = 'override'
        elif nodeName_ == 'ident':
            obj_ = identType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ident.append(obj_)
            obj_.original_tagname_ = 'ident'
        elif nodeName_ == 'metadata':
            obj_ = metadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata.append(obj_)
            obj_.original_tagname_ = 'metadata'
        elif nodeName_ == 'message':
            obj_ = messageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.message.append(obj_)
            obj_.original_tagname_ = 'message'
        elif nodeName_ == 'instance':
            obj_ = instanceResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instance.append(obj_)
            obj_.original_tagname_ = 'instance'
        elif nodeName_ == 'fix':
            obj_ = fixType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fix.append(obj_)
            obj_.original_tagname_ = 'fix'
        elif nodeName_ == 'check':
            obj_ = checkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check.append(obj_)
            obj_.original_tagname_ = 'check'
        elif nodeName_ == 'complex-check':
            obj_ = complexCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.complex_check = obj_
            obj_.original_tagname_ = 'complex-check'
# end class ruleResultType


class instanceResultType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, context='undefined', parentContext=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.context = _cast(None, context)
        self.context_nsprefix_ = None
        self.parentContext = _cast(None, parentContext)
        self.parentContext_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instanceResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instanceResultType.subclass:
            return instanceResultType.subclass(*args_, **kwargs_)
        else:
            return instanceResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_context(self):
        return self.context
    def set_context(self, context):
        self.context = context
    def get_parentContext(self):
        return self.parentContext
    def set_parentContext(self, parentContext):
        self.parentContext = parentContext
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='instanceResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instanceResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instanceResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instanceResultType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='instanceResultType'):
        if self.context != "undefined" and 'context' not in already_processed:
            already_processed.add('context')
            outfile.write(' context=%s' % (quote_attrib(self.context), ))
        if self.parentContext is not None and 'parentContext' not in already_processed:
            already_processed.add('parentContext')
            outfile.write(' parentContext=%s' % (quote_attrib(self.parentContext), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='instanceResultType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('context', node)
        if value is not None and 'context' not in already_processed:
            already_processed.add('context')
            self.context = value
        value = find_attr_value_('parentContext', node)
        if value is not None and 'parentContext' not in already_processed:
            already_processed.add('parentContext')
            self.parentContext = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class instanceResultType


class overrideType(GeneratedsSuper):
    """old-result -- The
    <
    xccdf:rule-result
    >
    status before
    this override.
    new-result -- The new, override
    <
    xccdf:rule-result
    >
    status.
    remark -- Rationale or explanation text for why or how
    the override was applied.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, time=None, authority=None, old_result=None, new_result=None, remark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.time = _cast(None, time)
        self.time_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.old_result = old_result
        self.validate_resultEnumType(self.old_result)
        self.old_result_nsprefix_ = "cdf"
        self.new_result = new_result
        self.validate_resultEnumType(self.new_result)
        self.new_result_nsprefix_ = "cdf"
        self.remark = remark
        self.remark_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, overrideType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if overrideType.subclass:
            return overrideType.subclass(*args_, **kwargs_)
        else:
            return overrideType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_old_result(self):
        return self.old_result
    def set_old_result(self, old_result):
        self.old_result = old_result
    def get_new_result(self):
        return self.new_result
    def set_new_result(self, new_result):
        self.new_result = new_result
    def get_remark(self):
        return self.remark
    def set_remark(self, remark):
        self.remark = remark
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_authority(self):
        return self.authority
    def set_authority(self, authority):
        self.authority = authority
    def validate_resultEnumType(self, value):
        result = True
        # Validate type resultEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['pass', 'fail', 'error', 'unknown', 'notapplicable', 'notchecked', 'notselected', 'informational', 'fixed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def has__content(self):
        if (
            self.old_result is not None or
            self.new_result is not None or
            self.remark is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='overrideType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('overrideType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'overrideType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='overrideType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='overrideType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='overrideType'):
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (quote_attrib(self.time), ))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (quote_attrib(self.authority), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='overrideType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.old_result is not None:
            namespaceprefix_ = self.old_result_nsprefix_ + ':' if (UseCapturedNS_ and self.old_result_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sold-result>%s</%sold-result>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.old_result), input_name='old-result')), namespaceprefix_ , eol_))
        if self.new_result is not None:
            namespaceprefix_ = self.new_result_nsprefix_ + ':' if (UseCapturedNS_ and self.new_result_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snew-result>%s</%snew-result>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.new_result), input_name='new-result')), namespaceprefix_ , eol_))
        if self.remark is not None:
            namespaceprefix_ = self.remark_nsprefix_ + ':' if (UseCapturedNS_ and self.remark_nsprefix_) else ''
            self.remark.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            self.time = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'old-result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'old_result')
            value_ = self.gds_validate_string(value_, node, 'old_result')
            self.old_result = value_
            self.old_result_nsprefix_ = child_.prefix
            # validate type resultEnumType
            self.validate_resultEnumType(self.old_result)
        elif nodeName_ == 'new-result':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'new_result')
            value_ = self.gds_validate_string(value_, node, 'new_result')
            self.new_result = value_
            self.new_result_nsprefix_ = child_.prefix
            # validate type resultEnumType
            self.validate_resultEnumType(self.new_result)
        elif nodeName_ == 'remark':
            obj_ = textType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remark = obj_
            obj_.original_tagname_ = 'remark'
# end class overrideType


class messageType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, severity=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.severity = _cast(None, severity)
        self.severity_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, messageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if messageType.subclass:
            return messageType.subclass(*args_, **kwargs_)
        else:
            return messageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_severity(self):
        return self.severity
    def set_severity(self, severity):
        self.severity = severity
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_msgSevEnumType(self, value):
        # Validate type cdf:msgSevEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['error', 'warning', 'info']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on msgSevEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='messageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('messageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'messageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='messageType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='messageType'):
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='messageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            self.severity = value
            self.validate_msgSevEnumType(self.severity)    # validate type msgSevEnumType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class messageType


class tailoringType(GeneratedsSuper):
    """benchmark -- Identifies the
    <
    xccdf:Benchmark
    >
    to which
    this tailoring applies. A
    <
    xccdf:Tailoring
    >
    document is only
    applicable to a single
    <
    xccdf:Benchmark
    >
    . Note, however, that this is
    a purely informative field.
    status -- Status of the tailoring and date at which it
    attained that status. Authors may use this element to record the maturity or
    consensus level of an
    <
    xccdf:Tailoring
    >
    element.
    dc-status -- Holds additional status information using the
    Dublin Core format.
    version -- The version of this
    <
    xccdf:Tailoring
    >
    element, with a required @time attribute that records when the
    <
    xccdf:Tailoring
    >
    element was created. This timestamp is necessary
    because, under some circumstances, a copy of an
    <
    xccdf:Tailoring
    >
    document might be automatically generated. Without the version and
    timestamp, tracking of these automatically created
    <
    xccdf:Tailoring
    >
    documents could become problematic.
    metadata -- XML metadata for the
    <
    xccdf:Tailoring
    >
    element.
    Profile -- <
    xccdf:Profile
    >
    elements that reference
    and customize sets of items in an
    <
    xccdf:Benchmark
    >
    .
      
    * signature -- A digital signature asserting authorship and
      allowing verification of the integrity of the
      <
      xccdf:Tailoring
      >
      .
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, Id=None, benchmark=None, status=None, dc_status=None, version=None, metadata=None, Profile=None, signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cdf"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.benchmark = benchmark
        self.benchmark_nsprefix_ = "cdf"
        if status is None:
            self.status = []
        else:
            self.status = status
        self.status_nsprefix_ = "cdf"
        if dc_status is None:
            self.dc_status = []
        else:
            self.dc_status = dc_status
        self.dc_status_nsprefix_ = "cdf"
        self.version = version
        self.version_nsprefix_ = "cdf"
        if metadata is None:
            self.metadata = []
        else:
            self.metadata = metadata
        self.metadata_nsprefix_ = "cdf"
        if Profile is None:
            self.Profile = []
        else:
            self.Profile = Profile
        self.Profile_nsprefix_ = "cdf"
        self.signature = signature
        self.signature_nsprefix_ = "cdf"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tailoringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tailoringType.subclass:
            return tailoringType.subclass(*args_, **kwargs_)
        else:
            return tailoringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_benchmark(self):
        return self.benchmark
    def set_benchmark(self, benchmark):
        self.benchmark = benchmark
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def add_status(self, value):
        self.status.append(value)
    def insert_status_at(self, index, value):
        self.status.insert(index, value)
    def replace_status_at(self, index, value):
        self.status[index] = value
    def get_dc_status(self):
        return self.dc_status
    def set_dc_status(self, dc_status):
        self.dc_status = dc_status
    def add_dc_status(self, value):
        self.dc_status.append(value)
    def insert_dc_status_at(self, index, value):
        self.dc_status.insert(index, value)
    def replace_dc_status_at(self, index, value):
        self.dc_status[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def add_metadata(self, value):
        self.metadata.append(value)
    def insert_metadata_at(self, index, value):
        self.metadata.insert(index, value)
    def replace_metadata_at(self, index, value):
        self.metadata[index] = value
    def get_Profile(self):
        return self.Profile
    def set_Profile(self, Profile):
        self.Profile = Profile
    def add_Profile(self, value):
        self.Profile.append(value)
    def insert_Profile_at(self, index, value):
        self.Profile.insert(index, value)
    def replace_Profile_at(self, index, value):
        self.Profile[index] = value
    def get_signature(self):
        return self.signature
    def set_signature(self, signature):
        self.signature = signature
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_tailoringIdType(self, value):
        # Validate type cdf:tailoringIdType, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_tailoringIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_tailoringIdType_patterns_, ))
    validate_tailoringIdType_patterns_ = [['^(xccdf_[^_]+_tailoring_.+)$']]
    def has__content(self):
        if (
            self.benchmark is not None or
            self.status or
            self.dc_status or
            self.version is not None or
            self.metadata or
            self.Profile or
            self.signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='tailoringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tailoringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tailoringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tailoringType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tailoringType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='tailoringType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2" ', name_='tailoringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.benchmark is not None:
            namespaceprefix_ = self.benchmark_nsprefix_ + ':' if (UseCapturedNS_ and self.benchmark_nsprefix_) else ''
            self.benchmark.export(outfile, level, namespaceprefix_, namespacedef_='', name_='benchmark', pretty_print=pretty_print)
        for status_ in self.status:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            status_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='status', pretty_print=pretty_print)
        for dc_status_ in self.dc_status:
            namespaceprefix_ = self.dc_status_nsprefix_ + ':' if (UseCapturedNS_ and self.dc_status_nsprefix_) else ''
            dc_status_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dc-status', pretty_print=pretty_print)
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
        for metadata_ in self.metadata:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            metadata_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
        for Profile_ in self.Profile:
            namespaceprefix_ = self.Profile_nsprefix_ + ':' if (UseCapturedNS_ and self.Profile_nsprefix_) else ''
            Profile_.export(outfile, level, namespaceprefix_='cdf:', namespacedef_='', name_='Profile', pretty_print=pretty_print)
        if self.signature is not None:
            namespaceprefix_ = self.signature_nsprefix_ + ':' if (UseCapturedNS_ and self.signature_nsprefix_) else ''
            self.signature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_tailoringIdType(self.id)    # validate type tailoringIdType
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'benchmark':
            obj_ = tailoringBenchmarkReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.benchmark = obj_
            obj_.original_tagname_ = 'benchmark'
        elif nodeName_ == 'status':
            obj_ = status.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.status.append(obj_)
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'dc-status':
            obj_ = dc_statusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dc_status.append(obj_)
            obj_.original_tagname_ = 'dc-status'
        elif nodeName_ == 'version':
            obj_ = tailoringVersionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'metadata':
            obj_ = metadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata.append(obj_)
            obj_.original_tagname_ = 'metadata'
        elif nodeName_ == 'Profile':
            obj_ = profileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Profile.append(obj_)
            obj_.original_tagname_ = 'Profile'
        elif nodeName_ == 'signature':
            obj_ = signatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.signature = obj_
            obj_.original_tagname_ = 'signature'
# end class tailoringType


class tailoringBenchmarkReferenceType(benchmarkReferenceType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = benchmarkReferenceType
    def __init__(self, href=None, id=None, version=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        super(globals().get("tailoringBenchmarkReferenceType"), self).__init__(href, id,  **kwargs_)
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tailoringBenchmarkReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tailoringBenchmarkReferenceType.subclass:
            return tailoringBenchmarkReferenceType.subclass(*args_, **kwargs_)
        else:
            return tailoringBenchmarkReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def has__content(self):
        if (
            super(tailoringBenchmarkReferenceType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='tailoringBenchmarkReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tailoringBenchmarkReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tailoringBenchmarkReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tailoringBenchmarkReferenceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tailoringBenchmarkReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='tailoringBenchmarkReferenceType'):
        super(tailoringBenchmarkReferenceType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tailoringBenchmarkReferenceType')
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='tailoringBenchmarkReferenceType', fromsubclass_=False, pretty_print=True):
        super(tailoringBenchmarkReferenceType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        super(tailoringBenchmarkReferenceType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(tailoringBenchmarkReferenceType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class tailoringBenchmarkReferenceType


class tailoringVersionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, time=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        self.time = _cast(None, time)
        self.time_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tailoringVersionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tailoringVersionType.subclass:
            return tailoringVersionType.subclass(*args_, **kwargs_)
        else:
            return tailoringVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='tailoringVersionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tailoringVersionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tailoringVersionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tailoringVersionType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='tailoringVersionType'):
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (quote_attrib(self.time), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='tailoringVersionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            self.time = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tailoringVersionType


class platformSpecificationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, platform=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = "cpe"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, platformSpecificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if platformSpecificationType.subclass:
            return platformSpecificationType.subclass(*args_, **kwargs_)
        else:
            return platformSpecificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def add_platform(self, value):
        self.platform.append(value)
    def insert_platform_at(self, index, value):
        self.platform.insert(index, value)
    def replace_platform_at(self, index, value):
        self.platform[index] = value
    def has__content(self):
        if (
            self.platform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/naming/2.0" ', name_='platformSpecificationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('platformSpecificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'platformSpecificationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='platformSpecificationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='platformSpecificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe:', name_='platformSpecificationType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/naming/2.0" ', name_='platformSpecificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            platform_.export(outfile, level, namespaceprefix_='cpe:', namespacedef_='', name_='platform', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'platform':
            obj_ = PlatformType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
# end class platformSpecificationType


class PlatformBaseType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, remark=None, logical_test=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = "cpe"
        if remark is None:
            self.remark = []
        else:
            self.remark = remark
        self.remark_nsprefix_ = "cpe"
        self.logical_test = logical_test
        self.logical_test_nsprefix_ = "cpe"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlatformBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlatformBaseType.subclass:
            return PlatformBaseType.subclass(*args_, **kwargs_)
        else:
            return PlatformBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_remark(self):
        return self.remark
    def set_remark(self, remark):
        self.remark = remark
    def add_remark(self, value):
        self.remark.append(value)
    def insert_remark_at(self, index, value):
        self.remark.insert(index, value)
    def replace_remark_at(self, index, value):
        self.remark[index] = value
    def get_logical_test(self):
        return self.logical_test
    def set_logical_test(self, logical_test):
        self.logical_test = logical_test
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.title or
            self.remark or
            self.logical_test is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/naming/2.0" ', name_='PlatformBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlatformBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PlatformBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlatformBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlatformBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe:', name_='PlatformBaseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/naming/2.0" ', name_='PlatformBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for remark_ in self.remark:
            namespaceprefix_ = self.remark_nsprefix_ + ':' if (UseCapturedNS_ and self.remark_nsprefix_) else ''
            remark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remark', pretty_print=pretty_print)
        if self.logical_test is not None:
            namespaceprefix_ = self.logical_test_nsprefix_ + ':' if (UseCapturedNS_ and self.logical_test_nsprefix_) else ''
            self.logical_test.export(outfile, level, namespaceprefix_='cpe:', namespacedef_='', name_='logical-test', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'remark':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remark.append(obj_)
            obj_.original_tagname_ = 'remark'
        elif nodeName_ == 'logical-test':
            obj_ = LogicalTestType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.logical_test = obj_
            obj_.original_tagname_ = 'logical-test'
# end class PlatformBaseType


class PlatformType(PlatformBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PlatformBaseType
    def __init__(self, title=None, remark=None, logical_test=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PlatformType"), self).__init__(title, remark, logical_test,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlatformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlatformType.subclass:
            return PlatformType.subclass(*args_, **kwargs_)
        else:
            return PlatformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def has__content(self):
        if (
            super(PlatformType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='PlatformType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlatformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PlatformType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlatformType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe:', name_='PlatformType'):
        super(PlatformType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlatformType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='PlatformType', fromsubclass_=False, pretty_print=True):
        super(PlatformType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(PlatformType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PlatformType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PlatformType


class LogicalTestType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, operator=None, negate=None, logical_test=None, fact_ref=None, check_fact_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.negate = _cast(None, negate)
        self.negate_nsprefix_ = None
        if logical_test is None:
            self.logical_test = []
        else:
            self.logical_test = logical_test
        self.logical_test_nsprefix_ = "cpe"
        if fact_ref is None:
            self.fact_ref = []
        else:
            self.fact_ref = fact_ref
        self.fact_ref_nsprefix_ = "cpe"
        if check_fact_ref is None:
            self.check_fact_ref = []
        else:
            self.check_fact_ref = check_fact_ref
        self.check_fact_ref_nsprefix_ = "cpe"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalTestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalTestType.subclass:
            return LogicalTestType.subclass(*args_, **kwargs_)
        else:
            return LogicalTestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_logical_test(self):
        return self.logical_test
    def set_logical_test(self, logical_test):
        self.logical_test = logical_test
    def add_logical_test(self, value):
        self.logical_test.append(value)
    def insert_logical_test_at(self, index, value):
        self.logical_test.insert(index, value)
    def replace_logical_test_at(self, index, value):
        self.logical_test[index] = value
    def get_fact_ref(self):
        return self.fact_ref
    def set_fact_ref(self, fact_ref):
        self.fact_ref = fact_ref
    def add_fact_ref(self, value):
        self.fact_ref.append(value)
    def insert_fact_ref_at(self, index, value):
        self.fact_ref.insert(index, value)
    def replace_fact_ref_at(self, index, value):
        self.fact_ref[index] = value
    def get_check_fact_ref(self):
        return self.check_fact_ref
    def set_check_fact_ref(self, check_fact_ref):
        self.check_fact_ref = check_fact_ref
    def add_check_fact_ref(self, value):
        self.check_fact_ref.append(value)
    def insert_check_fact_ref_at(self, index, value):
        self.check_fact_ref.insert(index, value)
    def replace_check_fact_ref_at(self, index, value):
        self.check_fact_ref[index] = value
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_negate(self):
        return self.negate
    def set_negate(self, negate):
        self.negate = negate
    def validate_operatorEnumeration(self, value):
        # Validate type cpe:operatorEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['AND', 'OR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on operatorEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.logical_test or
            self.fact_ref or
            self.check_fact_ref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/naming/2.0" ', name_='LogicalTestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LogicalTestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LogicalTestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LogicalTestType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LogicalTestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe:', name_='LogicalTestType'):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/naming/2.0" ', name_='LogicalTestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for logical_test_ in self.logical_test:
            namespaceprefix_ = self.logical_test_nsprefix_ + ':' if (UseCapturedNS_ and self.logical_test_nsprefix_) else ''
            logical_test_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='logical-test', pretty_print=pretty_print)
        for fact_ref_ in self.fact_ref:
            namespaceprefix_ = self.fact_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.fact_ref_nsprefix_) else ''
            fact_ref_.export(outfile, level, namespaceprefix_='cpe:', namespacedef_='', name_='fact-ref', pretty_print=pretty_print)
        for check_fact_ref_ in self.check_fact_ref:
            namespaceprefix_ = self.check_fact_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.check_fact_ref_nsprefix_) else ''
            check_fact_ref_.export(outfile, level, namespaceprefix_='cpe:', namespacedef_='', name_='check-fact-ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_operatorEnumeration(self.operator)    # validate type operatorEnumeration
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'logical-test':
            obj_ = LogicalTestType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.logical_test.append(obj_)
            obj_.original_tagname_ = 'logical-test'
        elif nodeName_ == 'fact-ref':
            obj_ = CPEFactRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fact_ref.append(obj_)
            obj_.original_tagname_ = 'fact-ref'
        elif nodeName_ == 'check-fact-ref':
            obj_ = CheckFactRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check_fact_ref.append(obj_)
            obj_.original_tagname_ = 'check-fact-ref'
# end class LogicalTestType


class FactRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FactRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FactRefType.subclass:
            return FactRefType.subclass(*args_, **kwargs_)
        else:
            return FactRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='FactRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FactRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FactRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FactRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FactRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe:', name_='FactRefType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (quote_attrib(self.description), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='FactRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FactRefType


class CPEFactRefType(FactRefType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FactRefType
    def __init__(self, description=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CPEFactRefType"), self).__init__(description,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CPEFactRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CPEFactRefType.subclass:
            return CPEFactRefType.subclass(*args_, **kwargs_)
        else:
            return CPEFactRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def validate_namePattern(self, value):
        # Validate type cpe:namePattern, a restriction on None.
        pass
    def has__content(self):
        if (
            super(CPEFactRefType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='CPEFactRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CPEFactRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CPEFactRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CPEFactRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CPEFactRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe:', name_='CPEFactRefType'):
        super(CPEFactRefType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CPEFactRefType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='CPEFactRefType', fromsubclass_=False, pretty_print=True):
        super(CPEFactRefType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_namePattern(self.name)    # validate type namePattern
        super(CPEFactRefType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CPEFactRefType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CPEFactRefType


class CheckFactRefType(FactRefType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FactRefType
    def __init__(self, description=None, system=None, href=None, id_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CheckFactRefType"), self).__init__(description,  **kwargs_)
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.id_ref = _cast(None, id_ref)
        self.id_ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CheckFactRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CheckFactRefType.subclass:
            return CheckFactRefType.subclass(*args_, **kwargs_)
        else:
            return CheckFactRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_id_ref(self):
        return self.id_ref
    def set_id_ref(self, id_ref):
        self.id_ref = id_ref
    def has__content(self):
        if (
            super(CheckFactRefType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='CheckFactRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CheckFactRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CheckFactRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CheckFactRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CheckFactRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe:', name_='CheckFactRefType'):
        super(CheckFactRefType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CheckFactRefType')
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        if self.id_ref is not None and 'id_ref' not in already_processed:
            already_processed.add('id_ref')
            outfile.write(' id-ref=%s' % (quote_attrib(self.id_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='CheckFactRefType', fromsubclass_=False, pretty_print=True):
        super(CheckFactRefType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('id-ref', node)
        if value is not None and 'id-ref' not in already_processed:
            already_processed.add('id-ref')
            self.id_ref = value
        super(CheckFactRefType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CheckFactRefType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CheckFactRefType


class TextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextType.subclass:
            return TextType.subclass(*args_, **kwargs_)
        else:
            return TextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='TextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe:', name_='TextType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:cpe="http://cpe.mitre.org/language/2.0"', name_='TextType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class TextType


class oval_definitions(GeneratedsSuper):
    """generator -- The required generator section provides information about when the definition file was compiled and under what version.
    definitions -- The optional definitions section contains 1 or more definitions.
    tests -- The optional tests section contains 1 or more tests.
    objects -- The optional objects section contains 1 or more objects.
    states -- The optional states section contains 1 or more states.
    variables -- The optional variables section contains 1 or more variables.
    Signature -- The optional Signature element allows an XML Signature as defined by the W3C to be attached to the document. This allows authentication and data integrity to be provided to the user. Enveloped signatures are supported. More information about the official W3C Recommendation regarding XML digital signatures can be found at http://www.w3.org/TR/xmldsig-core/.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, generator=None, definitions=None, tests=None, objects=None, states=None, variables=None, Signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.generator = generator
        self.generator_nsprefix_ = "oval"
        self.definitions = definitions
        self.definitions_nsprefix_ = "oval-def"
        self.tests = tests
        self.tests_nsprefix_ = "oval-def"
        self.objects = objects
        self.objects_nsprefix_ = "oval-def"
        self.states = states
        self.states_nsprefix_ = "oval-def"
        self.variables = variables
        self.variables_nsprefix_ = "oval-def"
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, oval_definitions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if oval_definitions.subclass:
            return oval_definitions.subclass(*args_, **kwargs_)
        else:
            return oval_definitions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_generator(self):
        return self.generator
    def set_generator(self, generator):
        self.generator = generator
    def get_definitions(self):
        return self.definitions
    def set_definitions(self, definitions):
        self.definitions = definitions
    def get_tests(self):
        return self.tests
    def set_tests(self, tests):
        self.tests = tests
    def get_objects(self):
        return self.objects
    def set_objects(self, objects):
        self.objects = objects
    def get_states(self):
        return self.states
    def set_states(self, states):
        self.states = states
    def get_variables(self):
        return self.variables
    def set_variables(self, variables):
        self.variables = variables
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def has__content(self):
        if (
            self.generator is not None or
            self.definitions is not None or
            self.tests is not None or
            self.objects is not None or
            self.states is not None or
            self.variables is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"  xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='oval_definitions', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('oval_definitions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'oval_definitions':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='oval_definitions')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='oval_definitions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='oval_definitions'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"  xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='oval_definitions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.generator is not None:
            namespaceprefix_ = self.generator_nsprefix_ + ':' if (UseCapturedNS_ and self.generator_nsprefix_) else ''
            self.generator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generator', pretty_print=pretty_print)
        if self.definitions is not None:
            namespaceprefix_ = self.definitions_nsprefix_ + ':' if (UseCapturedNS_ and self.definitions_nsprefix_) else ''
            self.definitions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='definitions', pretty_print=pretty_print)
        if self.tests is not None:
            namespaceprefix_ = self.tests_nsprefix_ + ':' if (UseCapturedNS_ and self.tests_nsprefix_) else ''
            self.tests.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tests', pretty_print=pretty_print)
        if self.objects is not None:
            namespaceprefix_ = self.objects_nsprefix_ + ':' if (UseCapturedNS_ and self.objects_nsprefix_) else ''
            self.objects.export(outfile, level, namespaceprefix_, namespacedef_='', name_='objects', pretty_print=pretty_print)
        if self.states is not None:
            namespaceprefix_ = self.states_nsprefix_ + ':' if (UseCapturedNS_ and self.states_nsprefix_) else ''
            self.states.export(outfile, level, namespaceprefix_, namespacedef_='', name_='states', pretty_print=pretty_print)
        if self.variables is not None:
            namespaceprefix_ = self.variables_nsprefix_ + ':' if (UseCapturedNS_ and self.variables_nsprefix_) else ''
            self.variables.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variables', pretty_print=pretty_print)
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'generator':
            obj_ = GeneratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generator = obj_
            obj_.original_tagname_ = 'generator'
        elif nodeName_ == 'definitions':
            obj_ = DefinitionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.definitions = obj_
            obj_.original_tagname_ = 'definitions'
        elif nodeName_ == 'tests':
            obj_ = TestsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tests = obj_
            obj_.original_tagname_ = 'tests'
        elif nodeName_ == 'objects':
            obj_ = ObjectsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.objects = obj_
            obj_.original_tagname_ = 'objects'
        elif nodeName_ == 'states':
            obj_ = StatesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.states = obj_
            obj_.original_tagname_ = 'states'
        elif nodeName_ == 'variables':
            obj_ = VariablesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variables = obj_
            obj_.original_tagname_ = 'variables'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class oval_definitions


class DefinitionsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, definition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        if definition is None:
            self.definition = []
        else:
            self.definition = definition
        self.definition_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefinitionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefinitionsType.subclass:
            return DefinitionsType.subclass(*args_, **kwargs_)
        else:
            return DefinitionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_definition(self):
        return self.definition
    def set_definition(self, definition):
        self.definition = definition
    def add_definition(self, value):
        self.definition.append(value)
    def insert_definition_at(self, index, value):
        self.definition.insert(index, value)
    def replace_definition_at(self, index, value):
        self.definition[index] = value
    def has__content(self):
        if (
            self.definition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='DefinitionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DefinitionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DefinitionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefinitionsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DefinitionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='DefinitionsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='DefinitionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for definition_ in self.definition:
            namespaceprefix_ = self.definition_nsprefix_ + ':' if (UseCapturedNS_ and self.definition_nsprefix_) else ''
            definition_.export(outfile, level, namespaceprefix_='oval-def:', namespacedef_='', name_='definition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'definition':
            obj_ = DefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.definition.append(obj_)
            obj_.original_tagname_ = 'definition'
# end class DefinitionsType


class DefinitionType(GeneratedsSuper):
    """metadata -- Each affected element must have a unique family attribute value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, version=None, class_=None, deprecated='false', Signature=None, metadata=None, notes=None, criteria=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.class_ = _cast(None, class_)
        self.class__nsprefix_ = None
        self.deprecated = _cast(None, deprecated)
        self.deprecated_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
        self.metadata = metadata
        self.metadata_nsprefix_ = "oval-def"
        self.notes = notes
        self.notes_nsprefix_ = "oval"
        self.criteria = criteria
        self.criteria_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefinitionType.subclass:
            return DefinitionType.subclass(*args_, **kwargs_)
        else:
            return DefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_metadata(self):
        return self.metadata
    def set_metadata(self, metadata):
        self.metadata = metadata
    def get_notes(self):
        return self.notes
    def set_notes(self, notes):
        self.notes = notes
    def get_criteria(self):
        return self.criteria
    def set_criteria(self, criteria):
        self.criteria = criteria
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_class(self):
        return self.class_
    def set_class(self, class_):
        self.class_ = class_
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    def validate_DefinitionIDPattern(self, value):
        # Validate type oval:DefinitionIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_DefinitionIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DefinitionIDPattern_patterns_, ))
    validate_DefinitionIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:def:[1-9][0-9]*)$']]
    def validate_ClassEnumeration(self, value):
        # Validate type oval:ClassEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['compliance', 'inventory', 'miscellaneous', 'patch', 'vulnerability']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ClassEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.Signature is not None or
            self.metadata is not None or
            self.notes is not None or
            self.criteria is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='DefinitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DefinitionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefinitionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='DefinitionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (quote_attrib(self.class_), ))
        if self.deprecated != "false" and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated=%s' % (quote_attrib(self.deprecated), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='DefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
        if self.metadata is not None:
            namespaceprefix_ = self.metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.metadata_nsprefix_) else ''
            self.metadata.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metadata', pretty_print=pretty_print)
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            self.notes.export(outfile, level, namespaceprefix_='oval:', namespacedef_='', name_='notes', pretty_print=pretty_print)
        if self.criteria is not None:
            namespaceprefix_ = self.criteria_nsprefix_ + ':' if (UseCapturedNS_ and self.criteria_nsprefix_) else ''
            self.criteria.export(outfile, level, namespaceprefix_, namespacedef_='', name_='criteria', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_DefinitionIDPattern(self.id)    # validate type DefinitionIDPattern
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
            self.validate_ClassEnumeration(self.class_)    # validate type ClassEnumeration
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            self.deprecated = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'metadata':
            obj_ = MetadataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metadata = obj_
            obj_.original_tagname_ = 'metadata'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'criteria':
            obj_ = CriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criteria = obj_
            obj_.original_tagname_ = 'criteria'
# end class DefinitionType


class MetadataType(GeneratedsSuper):
    """affected -- Each affected platform element must have a unique value.
    Each affected product element must have a unique value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, affected=None, reference=None, description=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if affected is None:
            self.affected = []
        else:
            self.affected = affected
        self.affected_nsprefix_ = "oval-def"
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = "oval-def"
        self.description = description
        self.description_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetadataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetadataType.subclass:
            return MetadataType.subclass(*args_, **kwargs_)
        else:
            return MetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_affected(self):
        return self.affected
    def set_affected(self, affected):
        self.affected = affected
    def add_affected(self, value):
        self.affected.append(value)
    def insert_affected_at(self, index, value):
        self.affected.insert(index, value)
    def replace_affected_at(self, index, value):
        self.affected[index] = value
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.title is not None or
            self.affected or
            self.reference or
            self.description is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='MetadataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetadataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetadataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetadataType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='MetadataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='MetadataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        for affected_ in self.affected:
            namespaceprefix_ = self.affected_nsprefix_ + ':' if (UseCapturedNS_ and self.affected_nsprefix_) else ''
            affected_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='affected', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'affected':
            obj_ = AffectedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.affected.append(obj_)
            obj_.original_tagname_ = 'affected'
        elif nodeName_ == 'reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'MetadataType')
            self.anytypeobjs_.append(content_)
# end class MetadataType


class AffectedType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, family=None, platform=None, product=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.family = _cast(None, family)
        self.family_nsprefix_ = None
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        self.platform_nsprefix_ = None
        if product is None:
            self.product = []
        else:
            self.product = product
        self.product_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AffectedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AffectedType.subclass:
            return AffectedType.subclass(*args_, **kwargs_)
        else:
            return AffectedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def add_platform(self, value):
        self.platform.append(value)
    def insert_platform_at(self, index, value):
        self.platform.insert(index, value)
    def replace_platform_at(self, index, value):
        self.platform[index] = value
    def get_product(self):
        return self.product
    def set_product(self, product):
        self.product = product
    def add_product(self, value):
        self.product.append(value)
    def insert_product_at(self, index, value):
        self.product.insert(index, value)
    def replace_product_at(self, index, value):
        self.product[index] = value
    def get_family(self):
        return self.family
    def set_family(self, family):
        self.family = family
    def validate_FamilyEnumeration(self, value):
        # Validate type oval:FamilyEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['android', 'asa', 'apple_ios', 'catos', 'ios', 'iosxe', 'junos', 'macos', 'pixos', 'undefined', 'unix', 'vmware_infrastructure', 'windows']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FamilyEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.platform or
            self.product
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='AffectedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AffectedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AffectedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AffectedType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AffectedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='AffectedType'):
        if self.family is not None and 'family' not in already_processed:
            already_processed.add('family')
            outfile.write(' family=%s' % (quote_attrib(self.family), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='AffectedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for platform_ in self.platform:
            namespaceprefix_ = self.platform_nsprefix_ + ':' if (UseCapturedNS_ and self.platform_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splatform>%s</%splatform>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(platform_), input_name='platform')), namespaceprefix_ , eol_))
        for product_ in self.product:
            namespaceprefix_ = self.product_nsprefix_ + ':' if (UseCapturedNS_ and self.product_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct>%s</%sproduct>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(product_), input_name='product')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('family', node)
        if value is not None and 'family' not in already_processed:
            already_processed.add('family')
            self.family = value
            self.validate_FamilyEnumeration(self.family)    # validate type FamilyEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'platform':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'platform')
            value_ = self.gds_validate_string(value_, node, 'platform')
            self.platform.append(value_)
            self.platform_nsprefix_ = child_.prefix
        elif nodeName_ == 'product':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product')
            value_ = self.gds_validate_string(value_, node, 'product')
            self.product.append(value_)
            self.product_nsprefix_ = child_.prefix
# end class AffectedType


class ReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, source=None, ref_id=None, ref_url=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.ref_id = _cast(None, ref_id)
        self.ref_id_nsprefix_ = None
        self.ref_url = _cast(None, ref_url)
        self.ref_url_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_ref_id(self):
        return self.ref_id
    def set_ref_id(self, ref_id):
        self.ref_id = ref_id
    def get_ref_url(self):
        return self.ref_url
    def set_ref_url(self, ref_url):
        self.ref_url = ref_url
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ReferenceType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (quote_attrib(self.source), ))
        if self.ref_id is not None and 'ref_id' not in already_processed:
            already_processed.add('ref_id')
            outfile.write(' ref_id=%s' % (quote_attrib(self.ref_id), ))
        if self.ref_url is not None and 'ref_url' not in already_processed:
            already_processed.add('ref_url')
            outfile.write(' ref_url=%s' % (quote_attrib(self.ref_url), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('ref_id', node)
        if value is not None and 'ref_id' not in already_processed:
            already_processed.add('ref_id')
            self.ref_id = value
        value = find_attr_value_('ref_url', node)
        if value is not None and 'ref_url' not in already_processed:
            already_processed.add('ref_url')
            self.ref_url = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReferenceType


class CriteriaType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, applicability_check=None, operator='AND', negate='false', comment=None, criteria=None, criterion=None, extend_definition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.applicability_check = _cast(None, applicability_check)
        self.applicability_check_nsprefix_ = None
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.negate = _cast(None, negate)
        self.negate_nsprefix_ = None
        self.comment = _cast(None, comment)
        self.comment_nsprefix_ = None
        if criteria is None:
            self.criteria = []
        else:
            self.criteria = criteria
        self.criteria_nsprefix_ = "oval-def"
        if criterion is None:
            self.criterion = []
        else:
            self.criterion = criterion
        self.criterion_nsprefix_ = "oval-def"
        if extend_definition is None:
            self.extend_definition = []
        else:
            self.extend_definition = extend_definition
        self.extend_definition_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CriteriaType.subclass:
            return CriteriaType.subclass(*args_, **kwargs_)
        else:
            return CriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_criteria(self):
        return self.criteria
    def set_criteria(self, criteria):
        self.criteria = criteria
    def add_criteria(self, value):
        self.criteria.append(value)
    def insert_criteria_at(self, index, value):
        self.criteria.insert(index, value)
    def replace_criteria_at(self, index, value):
        self.criteria[index] = value
    def get_criterion(self):
        return self.criterion
    def set_criterion(self, criterion):
        self.criterion = criterion
    def add_criterion(self, value):
        self.criterion.append(value)
    def insert_criterion_at(self, index, value):
        self.criterion.insert(index, value)
    def replace_criterion_at(self, index, value):
        self.criterion[index] = value
    def get_extend_definition(self):
        return self.extend_definition
    def set_extend_definition(self, extend_definition):
        self.extend_definition = extend_definition
    def add_extend_definition(self, value):
        self.extend_definition.append(value)
    def insert_extend_definition_at(self, index, value):
        self.extend_definition.insert(index, value)
    def replace_extend_definition_at(self, index, value):
        self.extend_definition[index] = value
    def get_applicability_check(self):
        return self.applicability_check
    def set_applicability_check(self, applicability_check):
        self.applicability_check = applicability_check
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_negate(self):
        return self.negate
    def set_negate(self, negate):
        self.negate = negate
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def validate_OperatorEnumeration(self, value):
        # Validate type oval:OperatorEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['AND', 'ONE', 'OR', 'XOR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperatorEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NonEmptyStringType(self, value):
        # Validate type oval:NonEmptyStringType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.criteria or
            self.criterion or
            self.extend_definition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='CriteriaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CriteriaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CriteriaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CriteriaType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CriteriaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='CriteriaType'):
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            outfile.write(' applicability_check=%s' % (quote_attrib(self.applicability_check), ))
        if self.operator != "AND" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.negate != "false" and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='CriteriaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for criteria_ in self.criteria:
            namespaceprefix_ = self.criteria_nsprefix_ + ':' if (UseCapturedNS_ and self.criteria_nsprefix_) else ''
            criteria_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='criteria', pretty_print=pretty_print)
        for criterion_ in self.criterion:
            namespaceprefix_ = self.criterion_nsprefix_ + ':' if (UseCapturedNS_ and self.criterion_nsprefix_) else ''
            criterion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='criterion', pretty_print=pretty_print)
        for extend_definition_ in self.extend_definition:
            namespaceprefix_ = self.extend_definition_nsprefix_ + ':' if (UseCapturedNS_ and self.extend_definition_nsprefix_) else ''
            extend_definition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extend_definition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('applicability_check', node)
        if value is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            self.applicability_check = value
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_OperatorEnumeration(self.operator)    # validate type OperatorEnumeration
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
            self.validate_NonEmptyStringType(self.comment)    # validate type NonEmptyStringType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'criteria':
            obj_ = CriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criteria.append(obj_)
            obj_.original_tagname_ = 'criteria'
        elif nodeName_ == 'criterion':
            obj_ = CriterionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.criterion.append(obj_)
            obj_.original_tagname_ = 'criterion'
        elif nodeName_ == 'extend_definition':
            obj_ = ExtendDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extend_definition.append(obj_)
            obj_.original_tagname_ = 'extend_definition'
# end class CriteriaType


class CriterionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, applicability_check=None, test_ref=None, negate='false', comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.applicability_check = _cast(None, applicability_check)
        self.applicability_check_nsprefix_ = None
        self.test_ref = _cast(None, test_ref)
        self.test_ref_nsprefix_ = None
        self.negate = _cast(None, negate)
        self.negate_nsprefix_ = None
        self.comment = _cast(None, comment)
        self.comment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CriterionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CriterionType.subclass:
            return CriterionType.subclass(*args_, **kwargs_)
        else:
            return CriterionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_applicability_check(self):
        return self.applicability_check
    def set_applicability_check(self, applicability_check):
        self.applicability_check = applicability_check
    def get_test_ref(self):
        return self.test_ref
    def set_test_ref(self, test_ref):
        self.test_ref = test_ref
    def get_negate(self):
        return self.negate
    def set_negate(self, negate):
        self.negate = negate
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def validate_TestIDPattern(self, value):
        # Validate type oval:TestIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_TestIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TestIDPattern_patterns_, ))
    validate_TestIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:tst:[1-9][0-9]*)$']]
    def validate_NonEmptyStringType(self, value):
        # Validate type oval:NonEmptyStringType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='CriterionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CriterionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CriterionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CriterionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CriterionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='CriterionType'):
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            outfile.write(' applicability_check=%s' % (quote_attrib(self.applicability_check), ))
        if self.test_ref is not None and 'test_ref' not in already_processed:
            already_processed.add('test_ref')
            outfile.write(' test_ref=%s' % (quote_attrib(self.test_ref), ))
        if self.negate != "false" and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='CriterionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('applicability_check', node)
        if value is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            self.applicability_check = value
        value = find_attr_value_('test_ref', node)
        if value is not None and 'test_ref' not in already_processed:
            already_processed.add('test_ref')
            self.test_ref = value
            self.validate_TestIDPattern(self.test_ref)    # validate type TestIDPattern
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
            self.validate_NonEmptyStringType(self.comment)    # validate type NonEmptyStringType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CriterionType


class ExtendDefinitionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, applicability_check=None, definition_ref=None, negate='false', comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.applicability_check = _cast(None, applicability_check)
        self.applicability_check_nsprefix_ = None
        self.definition_ref = _cast(None, definition_ref)
        self.definition_ref_nsprefix_ = None
        self.negate = _cast(None, negate)
        self.negate_nsprefix_ = None
        self.comment = _cast(None, comment)
        self.comment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtendDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtendDefinitionType.subclass:
            return ExtendDefinitionType.subclass(*args_, **kwargs_)
        else:
            return ExtendDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_applicability_check(self):
        return self.applicability_check
    def set_applicability_check(self, applicability_check):
        self.applicability_check = applicability_check
    def get_definition_ref(self):
        return self.definition_ref
    def set_definition_ref(self, definition_ref):
        self.definition_ref = definition_ref
    def get_negate(self):
        return self.negate
    def set_negate(self, negate):
        self.negate = negate
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def validate_DefinitionIDPattern(self, value):
        # Validate type oval:DefinitionIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_DefinitionIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DefinitionIDPattern_patterns_, ))
    validate_DefinitionIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:def:[1-9][0-9]*)$']]
    def validate_NonEmptyStringType(self, value):
        # Validate type oval:NonEmptyStringType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ExtendDefinitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtendDefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExtendDefinitionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtendDefinitionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExtendDefinitionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ExtendDefinitionType'):
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            outfile.write(' applicability_check=%s' % (quote_attrib(self.applicability_check), ))
        if self.definition_ref is not None and 'definition_ref' not in already_processed:
            already_processed.add('definition_ref')
            outfile.write(' definition_ref=%s' % (quote_attrib(self.definition_ref), ))
        if self.negate != "false" and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ExtendDefinitionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('applicability_check', node)
        if value is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            self.applicability_check = value
        value = find_attr_value_('definition_ref', node)
        if value is not None and 'definition_ref' not in already_processed:
            already_processed.add('definition_ref')
            self.definition_ref = value
            self.validate_DefinitionIDPattern(self.definition_ref)    # validate type DefinitionIDPattern
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
            self.validate_NonEmptyStringType(self.comment)    # validate type NonEmptyStringType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ExtendDefinitionType


class TestsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, test=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        if test is None:
            self.test = []
        else:
            self.test = test
        self.test_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TestsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TestsType.subclass:
            return TestsType.subclass(*args_, **kwargs_)
        else:
            return TestsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_test(self):
        return self.test
    def set_test(self, test):
        self.test = test
    def add_test(self, value):
        self.test.append(value)
    def insert_test_at(self, index, value):
        self.test.insert(index, value)
    def replace_test_at(self, index, value):
        self.test[index] = value
    def has__content(self):
        if (
            self.test
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='TestsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TestsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TestsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TestsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TestsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='TestsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='TestsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for test_ in self.test:
            test_.export(outfile, level, namespaceprefix_, name_='test', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'test':
            obj_ = TestType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test.append(obj_)
            obj_.original_tagname_ = 'test'
# end class TestsType


class TestType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, version=None, check_existence='at_least_one_exists', check=None, state_operator='AND', comment=None, deprecated='false', Signature=None, notes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.check_existence = _cast(None, check_existence)
        self.check_existence_nsprefix_ = None
        self.check = _cast(None, check)
        self.check_nsprefix_ = None
        self.state_operator = _cast(None, state_operator)
        self.state_operator_nsprefix_ = None
        self.comment = _cast(None, comment)
        self.comment_nsprefix_ = None
        self.deprecated = _cast(None, deprecated)
        self.deprecated_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
        self.notes = notes
        self.notes_nsprefix_ = "oval"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TestType.subclass:
            return TestType.subclass(*args_, **kwargs_)
        else:
            return TestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_notes(self):
        return self.notes
    def set_notes(self, notes):
        self.notes = notes
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_check_existence(self):
        return self.check_existence
    def set_check_existence(self, check_existence):
        self.check_existence = check_existence
    def get_check(self):
        return self.check
    def set_check(self, check):
        self.check = check
    def get_state_operator(self):
        return self.state_operator
    def set_state_operator(self, state_operator):
        self.state_operator = state_operator
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    def validate_TestIDPattern(self, value):
        # Validate type oval:TestIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_TestIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TestIDPattern_patterns_, ))
    validate_TestIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:tst:[1-9][0-9]*)$']]
    def validate_ExistenceEnumeration(self, value):
        # Validate type oval:ExistenceEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all_exist', 'any_exist', 'at_least_one_exists', 'none_exist', 'only_one_exists']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ExistenceEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CheckEnumeration(self, value):
        # Validate type oval:CheckEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all', 'at least one', 'none exist', 'none satisfy', 'only one']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CheckEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_OperatorEnumeration(self, value):
        # Validate type oval:OperatorEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['AND', 'ONE', 'OR', 'XOR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperatorEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NonEmptyStringType(self, value):
        # Validate type oval:NonEmptyStringType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.Signature is not None or
            self.notes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='TestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TestType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='TestType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.check_existence != "at_least_one_exists" and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            outfile.write(' check_existence=%s' % (quote_attrib(self.check_existence), ))
        if self.check is not None and 'check' not in already_processed:
            already_processed.add('check')
            outfile.write(' check=%s' % (quote_attrib(self.check), ))
        if self.state_operator != "AND" and 'state_operator' not in already_processed:
            already_processed.add('state_operator')
            outfile.write(' state_operator=%s' % (quote_attrib(self.state_operator), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.deprecated != "false" and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated=%s' % (quote_attrib(self.deprecated), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='TestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            self.notes.export(outfile, level, namespaceprefix_='oval:', namespacedef_='', name_='notes', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_TestIDPattern(self.id)    # validate type TestIDPattern
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('check_existence', node)
        if value is not None and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            self.check_existence = value
            self.validate_ExistenceEnumeration(self.check_existence)    # validate type ExistenceEnumeration
        value = find_attr_value_('check', node)
        if value is not None and 'check' not in already_processed:
            already_processed.add('check')
            self.check = value
            self.validate_CheckEnumeration(self.check)    # validate type CheckEnumeration
        value = find_attr_value_('state_operator', node)
        if value is not None and 'state_operator' not in already_processed:
            already_processed.add('state_operator')
            self.state_operator = value
            self.validate_OperatorEnumeration(self.state_operator)    # validate type OperatorEnumeration
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
            self.validate_NonEmptyStringType(self.comment)    # validate type NonEmptyStringType
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            self.deprecated = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
# end class TestType


class ObjectRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, object_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.object_ref = _cast(None, object_ref)
        self.object_ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectRefType.subclass:
            return ObjectRefType.subclass(*args_, **kwargs_)
        else:
            return ObjectRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_ref(self):
        return self.object_ref
    def set_object_ref(self, object_ref):
        self.object_ref = object_ref
    def validate_ObjectIDPattern(self, value):
        # Validate type oval:ObjectIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ObjectIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ObjectIDPattern_patterns_, ))
    validate_ObjectIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*)$']]
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ObjectRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjectRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObjectRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ObjectRefType'):
        if self.object_ref is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            outfile.write(' object_ref=%s' % (quote_attrib(self.object_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ObjectRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('object_ref', node)
        if value is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            self.object_ref = value
            self.validate_ObjectIDPattern(self.object_ref)    # validate type ObjectIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ObjectRefType


class StateRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, state_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.state_ref = _cast(None, state_ref)
        self.state_ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StateRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateRefType.subclass:
            return StateRefType.subclass(*args_, **kwargs_)
        else:
            return StateRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_state_ref(self):
        return self.state_ref
    def set_state_ref(self, state_ref):
        self.state_ref = state_ref
    def validate_StateIDPattern(self, value):
        # Validate type oval:StateIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_StateIDPattern_patterns_, ))
    validate_StateIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:ste:[1-9][0-9]*)$']]
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='StateRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StateRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StateRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StateRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StateRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='StateRefType'):
        if self.state_ref is not None and 'state_ref' not in already_processed:
            already_processed.add('state_ref')
            outfile.write(' state_ref=%s' % (quote_attrib(self.state_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='StateRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state_ref', node)
        if value is not None and 'state_ref' not in already_processed:
            already_processed.add('state_ref')
            self.state_ref = value
            self.validate_StateIDPattern(self.state_ref)    # validate type StateIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StateRefType


class ObjectsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, object=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        if object is None:
            self.object = []
        else:
            self.object = object
        self.object_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectsType.subclass:
            return ObjectsType.subclass(*args_, **kwargs_)
        else:
            return ObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object(self):
        return self.object
    def set_object(self, object):
        self.object = object
    def add_object(self, value):
        self.object.append(value)
    def insert_object_at(self, index, value):
        self.object.insert(index, value)
    def replace_object_at(self, index, value):
        self.object[index] = value
    def has__content(self):
        if (
            self.object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='ObjectsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjectsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObjectsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ObjectsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='ObjectsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_ in self.object:
            object_.export(outfile, level, namespaceprefix_, name_='object', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object':
            obj_ = ObjectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object.append(obj_)
            obj_.original_tagname_ = 'object'
# end class ObjectsType


class ObjectType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, version=None, comment=None, deprecated='false', Signature=None, notes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.comment = _cast(None, comment)
        self.comment_nsprefix_ = None
        self.deprecated = _cast(None, deprecated)
        self.deprecated_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
        self.notes = notes
        self.notes_nsprefix_ = "oval"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_notes(self):
        return self.notes
    def set_notes(self, notes):
        self.notes = notes
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    def validate_ObjectIDPattern(self, value):
        # Validate type oval:ObjectIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ObjectIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ObjectIDPattern_patterns_, ))
    validate_ObjectIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*)$']]
    def validate_NonEmptyStringType(self, value):
        # Validate type oval:NonEmptyStringType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.Signature is not None or
            self.notes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ObjectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ObjectType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.deprecated != "false" and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated=%s' % (quote_attrib(self.deprecated), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            self.notes.export(outfile, level, namespaceprefix_='oval:', namespacedef_='', name_='notes', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ObjectIDPattern(self.id)    # validate type ObjectIDPattern
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
            self.validate_NonEmptyStringType(self.comment)    # validate type NonEmptyStringType
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            self.deprecated = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
# end class ObjectType


class set_(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, set_operator='UNION', set__member=None, object_reference=None, filter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.set_operator = _cast(None, set_operator)
        self.set_operator_nsprefix_ = None
        if set__member is None:
            self.set_ = []
        else:
            self.set_ = set__member
        self.set__nsprefix_ = "oval-def"
        if object_reference is None:
            self.object_reference = []
        else:
            self.object_reference = object_reference
        self.object_reference_nsprefix_ = "oval"
        if filter is None:
            self.filter = []
        else:
            self.filter = filter
        self.filter_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, set_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if set_.subclass:
            return set_.subclass(*args_, **kwargs_)
        else:
            return set_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_set(self):
        return self.set_
    def set_set(self, set_):
        self.set_ = set_
    def add_set(self, value):
        self.set_.append(value)
    def insert_set_at(self, index, value):
        self.set_.insert(index, value)
    def replace_set_at(self, index, value):
        self.set_[index] = value
    def get_object_reference(self):
        return self.object_reference
    def set_object_reference(self, object_reference):
        self.object_reference = object_reference
    def add_object_reference(self, value):
        self.object_reference.append(value)
    def insert_object_reference_at(self, index, value):
        self.object_reference.insert(index, value)
    def replace_object_reference_at(self, index, value):
        self.object_reference[index] = value
    def get_filter(self):
        return self.filter
    def set_filter(self, filter):
        self.filter = filter
    def add_filter(self, value):
        self.filter.append(value)
    def insert_filter_at(self, index, value):
        self.filter.insert(index, value)
    def replace_filter_at(self, index, value):
        self.filter[index] = value
    def get_set_operator(self):
        return self.set_operator
    def set_set_operator(self, set_operator):
        self.set_operator = set_operator
    def validate_ObjectIDPattern(self, value):
        result = True
        # Validate type ObjectIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ObjectIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ObjectIDPattern_patterns_, ))
                result = False
        return result
    validate_ObjectIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*)$']]
    def validate_SetOperatorEnumeration(self, value):
        # Validate type oval-def:SetOperatorEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['COMPLEMENT', 'INTERSECTION', 'UNION']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SetOperatorEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.set_ or
            self.object_reference or
            self.filter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='set', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('set')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'set':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='set')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='set', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='set'):
        if self.set_operator != "UNION" and 'set_operator' not in already_processed:
            already_processed.add('set_operator')
            outfile.write(' set_operator=%s' % (quote_attrib(self.set_operator), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='set', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for set_ in self.set_:
            namespaceprefix_ = self.set__nsprefix_ + ':' if (UseCapturedNS_ and self.set__nsprefix_) else ''
            set_.export(outfile, level, namespaceprefix_='oval-def:', namespacedef_='', name_='set', pretty_print=pretty_print)
        for object_reference_ in self.object_reference:
            namespaceprefix_ = self.object_reference_nsprefix_ + ':' if (UseCapturedNS_ and self.object_reference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobject_reference>%s</%sobject_reference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(object_reference_), input_name='object_reference')), namespaceprefix_ , eol_))
        for filter_ in self.filter:
            namespaceprefix_ = self.filter_nsprefix_ + ':' if (UseCapturedNS_ and self.filter_nsprefix_) else ''
            filter_.export(outfile, level, namespaceprefix_='oval-def:', namespacedef_='', name_='filter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('set_operator', node)
        if value is not None and 'set_operator' not in already_processed:
            already_processed.add('set_operator')
            self.set_operator = value
            self.validate_SetOperatorEnumeration(self.set_operator)    # validate type SetOperatorEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'set':
            obj_ = set_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.set_.append(obj_)
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'object_reference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'object_reference')
            value_ = self.gds_validate_string(value_, node, 'object_reference')
            self.object_reference.append(value_)
            self.object_reference_nsprefix_ = child_.prefix
            # validate type ObjectIDPattern
            self.validate_ObjectIDPattern(self.object_reference[-1])
        elif nodeName_ == 'filter':
            obj_ = filter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.filter.append(obj_)
            obj_.original_tagname_ = 'filter'
# end class set_


class filter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, action='exclude', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.action = _cast(None, action)
        self.action_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, filter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if filter.subclass:
            return filter.subclass(*args_, **kwargs_)
        else:
            return filter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_action(self):
        return self.action
    def set_action(self, action):
        self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_StateIDPattern(self, value):
        result = True
        # Validate type StateIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_StateIDPattern_patterns_, ))
                result = False
        return result
    validate_StateIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:ste:[1-9][0-9]*)$']]
    def validate_FilterActionEnumeration(self, value):
        # Validate type oval-def:FilterActionEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['exclude', 'include']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FilterActionEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='filter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('filter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'filter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='filter')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='filter'):
        if self.action != "exclude" and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='filter', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
            self.validate_FilterActionEnumeration(self.action)    # validate type FilterActionEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class filter


class StatesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, state=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        if state is None:
            self.state = []
        else:
            self.state = state
        self.state_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatesType.subclass:
            return StatesType.subclass(*args_, **kwargs_)
        else:
            return StatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def add_state(self, value):
        self.state.append(value)
    def insert_state_at(self, index, value):
        self.state.insert(index, value)
    def replace_state_at(self, index, value):
        self.state[index] = value
    def has__content(self):
        if (
            self.state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='StatesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StatesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StatesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StatesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StatesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='StatesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='StatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for state_ in self.state:
            state_.export(outfile, level, namespaceprefix_, name_='state', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'state':
            obj_ = StateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.state.append(obj_)
            obj_.original_tagname_ = 'state'
# end class StatesType


class StateType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, version=None, operator='AND', comment=None, deprecated='false', Signature=None, notes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.comment = _cast(None, comment)
        self.comment_nsprefix_ = None
        self.deprecated = _cast(None, deprecated)
        self.deprecated_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
        self.notes = notes
        self.notes_nsprefix_ = "oval"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateType.subclass:
            return StateType.subclass(*args_, **kwargs_)
        else:
            return StateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_notes(self):
        return self.notes
    def set_notes(self, notes):
        self.notes = notes
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    def validate_StateIDPattern(self, value):
        # Validate type oval:StateIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_StateIDPattern_patterns_, ))
    validate_StateIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:ste:[1-9][0-9]*)$']]
    def validate_OperatorEnumeration(self, value):
        # Validate type oval:OperatorEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['AND', 'ONE', 'OR', 'XOR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperatorEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NonEmptyStringType(self, value):
        # Validate type oval:NonEmptyStringType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.Signature is not None or
            self.notes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='StateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StateType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StateType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='StateType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.operator != "AND" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.deprecated != "false" and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated=%s' % (quote_attrib(self.deprecated), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='StateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            self.notes.export(outfile, level, namespaceprefix_='oval:', namespacedef_='', name_='notes', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_StateIDPattern(self.id)    # validate type StateIDPattern
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_OperatorEnumeration(self.operator)    # validate type OperatorEnumeration
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
            self.validate_NonEmptyStringType(self.comment)    # validate type NonEmptyStringType
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            self.deprecated = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
# end class StateType


class VariablesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, variable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        if variable is None:
            self.variable = []
        else:
            self.variable = variable
        self.variable_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariablesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariablesType.subclass:
            return VariablesType.subclass(*args_, **kwargs_)
        else:
            return VariablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_variable(self):
        return self.variable
    def set_variable(self, variable):
        self.variable = variable
    def add_variable(self, value):
        self.variable.append(value)
    def insert_variable_at(self, index, value):
        self.variable.insert(index, value)
    def replace_variable_at(self, index, value):
        self.variable[index] = value
    def has__content(self):
        if (
            self.variable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='VariablesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariablesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariablesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariablesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariablesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='VariablesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='VariablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variable_ in self.variable:
            variable_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'variable':
            class_obj_ = self.get_class_obj_(child_, VariableType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'variable'
        elif nodeName_ == 'external_variable':
            obj_ = ExternalVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'external_variable'
        elif nodeName_ == 'constant_variable':
            obj_ = ConstantVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'constant_variable'
        elif nodeName_ == 'local_variable':
            obj_ = LocalVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'local_variable'
        elif nodeName_ == 'constant_variable':
            obj_ = ConstantVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'constant_variable'
        elif nodeName_ == 'local_variable':
            obj_ = LocalVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'local_variable'
        elif nodeName_ == 'external_variable':
            obj_ = ExternalVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'external_variable'
# end class VariablesType


class VariableType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, version=None, datatype=None, comment=None, deprecated='false', Signature=None, notes=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.comment = _cast(None, comment)
        self.comment_nsprefix_ = None
        self.deprecated = _cast(None, deprecated)
        self.deprecated_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
        self.notes = notes
        self.notes_nsprefix_ = "oval"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableType.subclass:
            return VariableType.subclass(*args_, **kwargs_)
        else:
            return VariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_notes(self):
        return self.notes
    def set_notes(self, notes):
        self.notes = notes
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_VariableIDPattern(self, value):
        # Validate type oval:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NonEmptyStringType(self, value):
        # Validate type oval:NonEmptyStringType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.Signature is not None or
            self.notes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='VariableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='VariableType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.deprecated != "false" and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated=%s' % (quote_attrib(self.deprecated), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='VariableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            self.notes.export(outfile, level, namespaceprefix_='oval:', namespacedef_='', name_='notes', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_VariableIDPattern(self.id)    # validate type VariableIDPattern
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
            self.validate_NonEmptyStringType(self.comment)    # validate type NonEmptyStringType
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            self.deprecated = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes = obj_
            obj_.original_tagname_ = 'notes'
# end class VariableType


class PossibleValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, hint=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.hint = _cast(None, hint)
        self.hint_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PossibleValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PossibleValueType.subclass:
            return PossibleValueType.subclass(*args_, **kwargs_)
        else:
            return PossibleValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_hint(self):
        return self.hint
    def set_hint(self, hint):
        self.hint = hint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='PossibleValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PossibleValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PossibleValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PossibleValueType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='PossibleValueType'):
        if self.hint is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            outfile.write(' hint=%s' % (quote_attrib(self.hint), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='PossibleValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hint', node)
        if value is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            self.hint = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PossibleValueType


class PossibleRestrictionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, operator='AND', hint=None, restriction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.hint = _cast(None, hint)
        self.hint_nsprefix_ = None
        if restriction is None:
            self.restriction = []
        else:
            self.restriction = restriction
        self.restriction_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PossibleRestrictionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PossibleRestrictionType.subclass:
            return PossibleRestrictionType.subclass(*args_, **kwargs_)
        else:
            return PossibleRestrictionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_restriction(self):
        return self.restriction
    def set_restriction(self, restriction):
        self.restriction = restriction
    def add_restriction(self, value):
        self.restriction.append(value)
    def insert_restriction_at(self, index, value):
        self.restriction.insert(index, value)
    def replace_restriction_at(self, index, value):
        self.restriction[index] = value
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_hint(self):
        return self.hint
    def set_hint(self, hint):
        self.hint = hint
    def validate_OperatorEnumeration(self, value):
        # Validate type oval:OperatorEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['AND', 'ONE', 'OR', 'XOR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperatorEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.restriction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='PossibleRestrictionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PossibleRestrictionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PossibleRestrictionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PossibleRestrictionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PossibleRestrictionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='PossibleRestrictionType'):
        if self.operator != "AND" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.hint is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            outfile.write(' hint=%s' % (quote_attrib(self.hint), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='PossibleRestrictionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for restriction_ in self.restriction:
            namespaceprefix_ = self.restriction_nsprefix_ + ':' if (UseCapturedNS_ and self.restriction_nsprefix_) else ''
            restriction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='restriction', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_OperatorEnumeration(self.operator)    # validate type OperatorEnumeration
        value = find_attr_value_('hint', node)
        if value is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            self.hint = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'restriction':
            obj_ = RestrictionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.restriction.append(obj_)
            obj_.original_tagname_ = 'restriction'
# end class PossibleRestrictionType


class RestrictionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, operation=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.operation = _cast(None, operation)
        self.operation_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RestrictionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RestrictionType.subclass:
            return RestrictionType.subclass(*args_, **kwargs_)
        else:
            return RestrictionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_operation(self):
        return self.operation
    def set_operation(self, operation):
        self.operation = operation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_OperationEnumeration(self, value):
        # Validate type oval:OperationEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['equals', 'not equal', 'case insensitive equals', 'case insensitive not equal', 'greater than', 'less than', 'greater than or equal', 'less than or equal', 'bitwise and', 'bitwise or', 'pattern match', 'subset of', 'superset of']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperationEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='RestrictionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RestrictionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RestrictionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RestrictionType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='RestrictionType'):
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='RestrictionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
            self.validate_OperationEnumeration(self.operation)    # validate type OperationEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RestrictionType


class ValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueType.subclass:
            return ValueType.subclass(*args_, **kwargs_)
        else:
            return ValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ValueType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ValueType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ValueType


class LiteralComponentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, datatype='string', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LiteralComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LiteralComponentType.subclass:
            return LiteralComponentType.subclass(*args_, **kwargs_)
        else:
            return LiteralComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='LiteralComponentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LiteralComponentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LiteralComponentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LiteralComponentType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='LiteralComponentType'):
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='LiteralComponentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LiteralComponentType


class ObjectComponentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, object_ref=None, item_field=None, record_field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.object_ref = _cast(None, object_ref)
        self.object_ref_nsprefix_ = None
        self.item_field = _cast(None, item_field)
        self.item_field_nsprefix_ = None
        self.record_field = _cast(None, record_field)
        self.record_field_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectComponentType.subclass:
            return ObjectComponentType.subclass(*args_, **kwargs_)
        else:
            return ObjectComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_ref(self):
        return self.object_ref
    def set_object_ref(self, object_ref):
        self.object_ref = object_ref
    def get_item_field(self):
        return self.item_field
    def set_item_field(self, item_field):
        self.item_field = item_field
    def get_record_field(self):
        return self.record_field
    def set_record_field(self, record_field):
        self.record_field = record_field
    def validate_ObjectIDPattern(self, value):
        # Validate type oval:ObjectIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ObjectIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ObjectIDPattern_patterns_, ))
    validate_ObjectIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*)$']]
    def validate_NonEmptyStringType(self, value):
        # Validate type oval:NonEmptyStringType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on NonEmptyStringType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ObjectComponentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectComponentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjectComponentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectComponentType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObjectComponentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ObjectComponentType'):
        if self.object_ref is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            outfile.write(' object_ref=%s' % (quote_attrib(self.object_ref), ))
        if self.item_field is not None and 'item_field' not in already_processed:
            already_processed.add('item_field')
            outfile.write(' item_field=%s' % (quote_attrib(self.item_field), ))
        if self.record_field is not None and 'record_field' not in already_processed:
            already_processed.add('record_field')
            outfile.write(' record_field=%s' % (quote_attrib(self.record_field), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='ObjectComponentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('object_ref', node)
        if value is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            self.object_ref = value
            self.validate_ObjectIDPattern(self.object_ref)    # validate type ObjectIDPattern
        value = find_attr_value_('item_field', node)
        if value is not None and 'item_field' not in already_processed:
            already_processed.add('item_field')
            self.item_field = value
            self.validate_NonEmptyStringType(self.item_field)    # validate type NonEmptyStringType
        value = find_attr_value_('record_field', node)
        if value is not None and 'record_field' not in already_processed:
            already_processed.add('record_field')
            self.record_field = value
            self.validate_NonEmptyStringType(self.record_field)    # validate type NonEmptyStringType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ObjectComponentType


class VariableComponentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, var_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableComponentType.subclass:
            return VariableComponentType.subclass(*args_, **kwargs_)
        else:
            return VariableComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def validate_VariableIDPattern(self, value):
        # Validate type oval:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='VariableComponentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableComponentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariableComponentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableComponentType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariableComponentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='VariableComponentType'):
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='VariableComponentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VariableComponentType


class ArithmeticFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, arithmetic_operation=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.arithmetic_operation = _cast(None, arithmetic_operation)
        self.arithmetic_operation_nsprefix_ = None
        if object_component is None:
            self.object_component = []
        else:
            self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        if variable_component is None:
            self.variable_component = []
        else:
            self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        if literal_component is None:
            self.literal_component = []
        else:
            self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        if arithmetic is None:
            self.arithmetic = []
        else:
            self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        if begin is None:
            self.begin = []
        else:
            self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        if concat is None:
            self.concat = []
        else:
            self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        if end is None:
            self.end = []
        else:
            self.end = end
        self.end_nsprefix_ = "oval-def"
        if escape_regex is None:
            self.escape_regex = []
        else:
            self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        if split is None:
            self.split = []
        else:
            self.split = split
        self.split_nsprefix_ = "oval-def"
        if substring is None:
            self.substring = []
        else:
            self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        if time_difference is None:
            self.time_difference = []
        else:
            self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        if regex_capture is None:
            self.regex_capture = []
        else:
            self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        if unique is None:
            self.unique = []
        else:
            self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        if count is None:
            self.count = []
        else:
            self.count = count
        self.count_nsprefix_ = "oval-def"
        if glob_to_regex is None:
            self.glob_to_regex = []
        else:
            self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArithmeticFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArithmeticFunctionType.subclass:
            return ArithmeticFunctionType.subclass(*args_, **kwargs_)
        else:
            return ArithmeticFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def add_object_component(self, value):
        self.object_component.append(value)
    def insert_object_component_at(self, index, value):
        self.object_component.insert(index, value)
    def replace_object_component_at(self, index, value):
        self.object_component[index] = value
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def add_variable_component(self, value):
        self.variable_component.append(value)
    def insert_variable_component_at(self, index, value):
        self.variable_component.insert(index, value)
    def replace_variable_component_at(self, index, value):
        self.variable_component[index] = value
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def add_literal_component(self, value):
        self.literal_component.append(value)
    def insert_literal_component_at(self, index, value):
        self.literal_component.insert(index, value)
    def replace_literal_component_at(self, index, value):
        self.literal_component[index] = value
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def add_arithmetic(self, value):
        self.arithmetic.append(value)
    def insert_arithmetic_at(self, index, value):
        self.arithmetic.insert(index, value)
    def replace_arithmetic_at(self, index, value):
        self.arithmetic[index] = value
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def add_begin(self, value):
        self.begin.append(value)
    def insert_begin_at(self, index, value):
        self.begin.insert(index, value)
    def replace_begin_at(self, index, value):
        self.begin[index] = value
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def add_concat(self, value):
        self.concat.append(value)
    def insert_concat_at(self, index, value):
        self.concat.insert(index, value)
    def replace_concat_at(self, index, value):
        self.concat[index] = value
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def add_end(self, value):
        self.end.append(value)
    def insert_end_at(self, index, value):
        self.end.insert(index, value)
    def replace_end_at(self, index, value):
        self.end[index] = value
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def add_escape_regex(self, value):
        self.escape_regex.append(value)
    def insert_escape_regex_at(self, index, value):
        self.escape_regex.insert(index, value)
    def replace_escape_regex_at(self, index, value):
        self.escape_regex[index] = value
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def add_split(self, value):
        self.split.append(value)
    def insert_split_at(self, index, value):
        self.split.insert(index, value)
    def replace_split_at(self, index, value):
        self.split[index] = value
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def add_substring(self, value):
        self.substring.append(value)
    def insert_substring_at(self, index, value):
        self.substring.insert(index, value)
    def replace_substring_at(self, index, value):
        self.substring[index] = value
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def add_time_difference(self, value):
        self.time_difference.append(value)
    def insert_time_difference_at(self, index, value):
        self.time_difference.insert(index, value)
    def replace_time_difference_at(self, index, value):
        self.time_difference[index] = value
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def add_regex_capture(self, value):
        self.regex_capture.append(value)
    def insert_regex_capture_at(self, index, value):
        self.regex_capture.insert(index, value)
    def replace_regex_capture_at(self, index, value):
        self.regex_capture[index] = value
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def add_unique(self, value):
        self.unique.append(value)
    def insert_unique_at(self, index, value):
        self.unique.insert(index, value)
    def replace_unique_at(self, index, value):
        self.unique[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def add_count(self, value):
        self.count.append(value)
    def insert_count_at(self, index, value):
        self.count.insert(index, value)
    def replace_count_at(self, index, value):
        self.count[index] = value
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def add_glob_to_regex(self, value):
        self.glob_to_regex.append(value)
    def insert_glob_to_regex_at(self, index, value):
        self.glob_to_regex.insert(index, value)
    def replace_glob_to_regex_at(self, index, value):
        self.glob_to_regex[index] = value
    def get_arithmetic_operation(self):
        return self.arithmetic_operation
    def set_arithmetic_operation(self, arithmetic_operation):
        self.arithmetic_operation = arithmetic_operation
    def validate_ArithmeticEnumeration(self, value):
        # Validate type oval-def:ArithmeticEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['add', 'multiply']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ArithmeticEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.object_component or
            self.variable_component or
            self.literal_component or
            self.arithmetic or
            self.begin or
            self.concat or
            self.end or
            self.escape_regex or
            self.split or
            self.substring or
            self.time_difference or
            self.regex_capture or
            self.unique or
            self.count or
            self.glob_to_regex
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='ArithmeticFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArithmeticFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArithmeticFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArithmeticFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArithmeticFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ArithmeticFunctionType'):
        if self.arithmetic_operation is not None and 'arithmetic_operation' not in already_processed:
            already_processed.add('arithmetic_operation')
            outfile.write(' arithmetic_operation=%s' % (quote_attrib(self.arithmetic_operation), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='ArithmeticFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_component_ in self.object_component:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            object_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        for variable_component_ in self.variable_component:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            variable_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        for literal_component_ in self.literal_component:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            literal_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        for arithmetic_ in self.arithmetic:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            arithmetic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        for begin_ in self.begin:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            begin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        for concat_ in self.concat:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            concat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        for end_ in self.end:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            end_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        for escape_regex_ in self.escape_regex:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            escape_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        for split_ in self.split:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            split_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        for substring_ in self.substring:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            substring_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        for time_difference_ in self.time_difference:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            time_difference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        for regex_capture_ in self.regex_capture:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            regex_capture_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        for unique_ in self.unique:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            unique_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        for count_ in self.count:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            count_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        for glob_to_regex_ in self.glob_to_regex:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            glob_to_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arithmetic_operation', node)
        if value is not None and 'arithmetic_operation' not in already_processed:
            already_processed.add('arithmetic_operation')
            self.arithmetic_operation = value
            self.validate_ArithmeticEnumeration(self.arithmetic_operation)    # validate type ArithmeticEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component.append(obj_)
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component.append(obj_)
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component.append(obj_)
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic.append(obj_)
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin.append(obj_)
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat.append(obj_)
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end.append(obj_)
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex.append(obj_)
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split.append(obj_)
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring.append(obj_)
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference.append(obj_)
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture.append(obj_)
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique.append(obj_)
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count.append(obj_)
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex.append(obj_)
            obj_.original_tagname_ = 'glob_to_regex'
# end class ArithmeticFunctionType


class BeginFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, character=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.character = _cast(None, character)
        self.character_nsprefix_ = None
        self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        self.end = end
        self.end_nsprefix_ = "oval-def"
        self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        self.split = split
        self.split_nsprefix_ = "oval-def"
        self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        self.count = count
        self.count_nsprefix_ = "oval-def"
        self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BeginFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BeginFunctionType.subclass:
            return BeginFunctionType.subclass(*args_, **kwargs_)
        else:
            return BeginFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def get_character(self):
        return self.character
    def set_character(self, character):
        self.character = character
    def has__content(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None or
            self.glob_to_regex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='BeginFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BeginFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BeginFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BeginFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='BeginFunctionType'):
        if self.character is not None and 'character' not in already_processed:
            already_processed.add('character')
            outfile.write(' character=%s' % (quote_attrib(self.character), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='BeginFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            self.object_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            self.variable_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            self.literal_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            self.arithmetic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            self.concat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            self.escape_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            self.split.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            self.substring.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            self.time_difference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            self.regex_capture.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            self.unique.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            self.count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        if self.glob_to_regex is not None:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            self.glob_to_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('character', node)
        if value is not None and 'character' not in already_processed:
            already_processed.add('character')
            self.character = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component = obj_
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component = obj_
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component = obj_
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic = obj_
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat = obj_
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex = obj_
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split = obj_
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring = obj_
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference = obj_
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture = obj_
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique = obj_
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex = obj_
            obj_.original_tagname_ = 'glob_to_regex'
# end class BeginFunctionType


class ConcatFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        if object_component is None:
            self.object_component = []
        else:
            self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        if variable_component is None:
            self.variable_component = []
        else:
            self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        if literal_component is None:
            self.literal_component = []
        else:
            self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        if arithmetic is None:
            self.arithmetic = []
        else:
            self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        if begin is None:
            self.begin = []
        else:
            self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        if concat is None:
            self.concat = []
        else:
            self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        if end is None:
            self.end = []
        else:
            self.end = end
        self.end_nsprefix_ = "oval-def"
        if escape_regex is None:
            self.escape_regex = []
        else:
            self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        if split is None:
            self.split = []
        else:
            self.split = split
        self.split_nsprefix_ = "oval-def"
        if substring is None:
            self.substring = []
        else:
            self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        if time_difference is None:
            self.time_difference = []
        else:
            self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        if regex_capture is None:
            self.regex_capture = []
        else:
            self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        if unique is None:
            self.unique = []
        else:
            self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        if count is None:
            self.count = []
        else:
            self.count = count
        self.count_nsprefix_ = "oval-def"
        if glob_to_regex is None:
            self.glob_to_regex = []
        else:
            self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConcatFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConcatFunctionType.subclass:
            return ConcatFunctionType.subclass(*args_, **kwargs_)
        else:
            return ConcatFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def add_object_component(self, value):
        self.object_component.append(value)
    def insert_object_component_at(self, index, value):
        self.object_component.insert(index, value)
    def replace_object_component_at(self, index, value):
        self.object_component[index] = value
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def add_variable_component(self, value):
        self.variable_component.append(value)
    def insert_variable_component_at(self, index, value):
        self.variable_component.insert(index, value)
    def replace_variable_component_at(self, index, value):
        self.variable_component[index] = value
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def add_literal_component(self, value):
        self.literal_component.append(value)
    def insert_literal_component_at(self, index, value):
        self.literal_component.insert(index, value)
    def replace_literal_component_at(self, index, value):
        self.literal_component[index] = value
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def add_arithmetic(self, value):
        self.arithmetic.append(value)
    def insert_arithmetic_at(self, index, value):
        self.arithmetic.insert(index, value)
    def replace_arithmetic_at(self, index, value):
        self.arithmetic[index] = value
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def add_begin(self, value):
        self.begin.append(value)
    def insert_begin_at(self, index, value):
        self.begin.insert(index, value)
    def replace_begin_at(self, index, value):
        self.begin[index] = value
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def add_concat(self, value):
        self.concat.append(value)
    def insert_concat_at(self, index, value):
        self.concat.insert(index, value)
    def replace_concat_at(self, index, value):
        self.concat[index] = value
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def add_end(self, value):
        self.end.append(value)
    def insert_end_at(self, index, value):
        self.end.insert(index, value)
    def replace_end_at(self, index, value):
        self.end[index] = value
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def add_escape_regex(self, value):
        self.escape_regex.append(value)
    def insert_escape_regex_at(self, index, value):
        self.escape_regex.insert(index, value)
    def replace_escape_regex_at(self, index, value):
        self.escape_regex[index] = value
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def add_split(self, value):
        self.split.append(value)
    def insert_split_at(self, index, value):
        self.split.insert(index, value)
    def replace_split_at(self, index, value):
        self.split[index] = value
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def add_substring(self, value):
        self.substring.append(value)
    def insert_substring_at(self, index, value):
        self.substring.insert(index, value)
    def replace_substring_at(self, index, value):
        self.substring[index] = value
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def add_time_difference(self, value):
        self.time_difference.append(value)
    def insert_time_difference_at(self, index, value):
        self.time_difference.insert(index, value)
    def replace_time_difference_at(self, index, value):
        self.time_difference[index] = value
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def add_regex_capture(self, value):
        self.regex_capture.append(value)
    def insert_regex_capture_at(self, index, value):
        self.regex_capture.insert(index, value)
    def replace_regex_capture_at(self, index, value):
        self.regex_capture[index] = value
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def add_unique(self, value):
        self.unique.append(value)
    def insert_unique_at(self, index, value):
        self.unique.insert(index, value)
    def replace_unique_at(self, index, value):
        self.unique[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def add_count(self, value):
        self.count.append(value)
    def insert_count_at(self, index, value):
        self.count.insert(index, value)
    def replace_count_at(self, index, value):
        self.count[index] = value
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def add_glob_to_regex(self, value):
        self.glob_to_regex.append(value)
    def insert_glob_to_regex_at(self, index, value):
        self.glob_to_regex.insert(index, value)
    def replace_glob_to_regex_at(self, index, value):
        self.glob_to_regex[index] = value
    def has__content(self):
        if (
            self.object_component or
            self.variable_component or
            self.literal_component or
            self.arithmetic or
            self.begin or
            self.concat or
            self.end or
            self.escape_regex or
            self.split or
            self.substring or
            self.time_difference or
            self.regex_capture or
            self.unique or
            self.count or
            self.glob_to_regex
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='ConcatFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConcatFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConcatFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConcatFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConcatFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='ConcatFunctionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='ConcatFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_component_ in self.object_component:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            object_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        for variable_component_ in self.variable_component:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            variable_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        for literal_component_ in self.literal_component:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            literal_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        for arithmetic_ in self.arithmetic:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            arithmetic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        for begin_ in self.begin:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            begin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        for concat_ in self.concat:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            concat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        for end_ in self.end:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            end_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        for escape_regex_ in self.escape_regex:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            escape_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        for split_ in self.split:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            split_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        for substring_ in self.substring:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            substring_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        for time_difference_ in self.time_difference:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            time_difference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        for regex_capture_ in self.regex_capture:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            regex_capture_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        for unique_ in self.unique:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            unique_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        for count_ in self.count:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            count_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        for glob_to_regex_ in self.glob_to_regex:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            glob_to_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component.append(obj_)
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component.append(obj_)
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component.append(obj_)
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic.append(obj_)
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin.append(obj_)
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat.append(obj_)
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end.append(obj_)
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex.append(obj_)
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split.append(obj_)
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring.append(obj_)
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference.append(obj_)
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture.append(obj_)
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique.append(obj_)
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count.append(obj_)
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex.append(obj_)
            obj_.original_tagname_ = 'glob_to_regex'
# end class ConcatFunctionType


class EndFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, character=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.character = _cast(None, character)
        self.character_nsprefix_ = None
        self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        self.end = end
        self.end_nsprefix_ = "oval-def"
        self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        self.split = split
        self.split_nsprefix_ = "oval-def"
        self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        self.count = count
        self.count_nsprefix_ = "oval-def"
        self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndFunctionType.subclass:
            return EndFunctionType.subclass(*args_, **kwargs_)
        else:
            return EndFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def get_character(self):
        return self.character
    def set_character(self, character):
        self.character = character
    def has__content(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None or
            self.glob_to_regex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='EndFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EndFunctionType'):
        if self.character is not None and 'character' not in already_processed:
            already_processed.add('character')
            outfile.write(' character=%s' % (quote_attrib(self.character), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='EndFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            self.object_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            self.variable_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            self.literal_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            self.arithmetic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            self.concat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            self.escape_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            self.split.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            self.substring.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            self.time_difference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            self.regex_capture.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            self.unique.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            self.count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        if self.glob_to_regex is not None:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            self.glob_to_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('character', node)
        if value is not None and 'character' not in already_processed:
            already_processed.add('character')
            self.character = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component = obj_
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component = obj_
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component = obj_
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic = obj_
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat = obj_
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex = obj_
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split = obj_
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring = obj_
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference = obj_
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture = obj_
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique = obj_
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex = obj_
            obj_.original_tagname_ = 'glob_to_regex'
# end class EndFunctionType


class EscapeRegexFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        self.end = end
        self.end_nsprefix_ = "oval-def"
        self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        self.split = split
        self.split_nsprefix_ = "oval-def"
        self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        self.count = count
        self.count_nsprefix_ = "oval-def"
        self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EscapeRegexFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EscapeRegexFunctionType.subclass:
            return EscapeRegexFunctionType.subclass(*args_, **kwargs_)
        else:
            return EscapeRegexFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def has__content(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None or
            self.glob_to_regex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='EscapeRegexFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EscapeRegexFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EscapeRegexFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EscapeRegexFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EscapeRegexFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EscapeRegexFunctionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='EscapeRegexFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            self.object_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            self.variable_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            self.literal_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            self.arithmetic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            self.concat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            self.escape_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            self.split.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            self.substring.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            self.time_difference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            self.regex_capture.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            self.unique.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            self.count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        if self.glob_to_regex is not None:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            self.glob_to_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component = obj_
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component = obj_
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component = obj_
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic = obj_
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat = obj_
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex = obj_
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split = obj_
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring = obj_
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference = obj_
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture = obj_
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique = obj_
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex = obj_
            obj_.original_tagname_ = 'glob_to_regex'
# end class EscapeRegexFunctionType


class SplitFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, delimiter=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.delimiter = _cast(None, delimiter)
        self.delimiter_nsprefix_ = None
        self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        self.end = end
        self.end_nsprefix_ = "oval-def"
        self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        self.split = split
        self.split_nsprefix_ = "oval-def"
        self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        self.count = count
        self.count_nsprefix_ = "oval-def"
        self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplitFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplitFunctionType.subclass:
            return SplitFunctionType.subclass(*args_, **kwargs_)
        else:
            return SplitFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def has__content(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None or
            self.glob_to_regex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='SplitFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SplitFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SplitFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SplitFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SplitFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='SplitFunctionType'):
        if self.delimiter is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            outfile.write(' delimiter=%s' % (quote_attrib(self.delimiter), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='SplitFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            self.object_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            self.variable_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            self.literal_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            self.arithmetic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            self.concat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            self.escape_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            self.split.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            self.substring.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            self.time_difference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            self.regex_capture.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            self.unique.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            self.count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        if self.glob_to_regex is not None:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            self.glob_to_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delimiter', node)
        if value is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            self.delimiter = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component = obj_
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component = obj_
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component = obj_
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic = obj_
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat = obj_
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex = obj_
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split = obj_
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring = obj_
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference = obj_
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture = obj_
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique = obj_
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex = obj_
            obj_.original_tagname_ = 'glob_to_regex'
# end class SplitFunctionType


class SubstringFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, substring_start=None, substring_length=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.substring_start = _cast(None, substring_start)
        self.substring_start_nsprefix_ = None
        self.substring_length = _cast(None, substring_length)
        self.substring_length_nsprefix_ = None
        self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        self.end = end
        self.end_nsprefix_ = "oval-def"
        self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        self.split = split
        self.split_nsprefix_ = "oval-def"
        self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        self.count = count
        self.count_nsprefix_ = "oval-def"
        self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubstringFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubstringFunctionType.subclass:
            return SubstringFunctionType.subclass(*args_, **kwargs_)
        else:
            return SubstringFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def get_substring_start(self):
        return self.substring_start
    def set_substring_start(self, substring_start):
        self.substring_start = substring_start
    def get_substring_length(self):
        return self.substring_length
    def set_substring_length(self, substring_length):
        self.substring_length = substring_length
    def has__content(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None or
            self.glob_to_regex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='SubstringFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubstringFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubstringFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubstringFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubstringFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='SubstringFunctionType'):
        if self.substring_start is not None and 'substring_start' not in already_processed:
            already_processed.add('substring_start')
            outfile.write(' substring_start=%s' % (quote_attrib(self.substring_start), ))
        if self.substring_length is not None and 'substring_length' not in already_processed:
            already_processed.add('substring_length')
            outfile.write(' substring_length=%s' % (quote_attrib(self.substring_length), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='SubstringFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            self.object_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            self.variable_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            self.literal_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            self.arithmetic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            self.concat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            self.escape_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            self.split.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            self.substring.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            self.time_difference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            self.regex_capture.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            self.unique.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            self.count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        if self.glob_to_regex is not None:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            self.glob_to_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('substring_start', node)
        if value is not None and 'substring_start' not in already_processed:
            already_processed.add('substring_start')
            self.substring_start = value
        value = find_attr_value_('substring_length', node)
        if value is not None and 'substring_length' not in already_processed:
            already_processed.add('substring_length')
            self.substring_length = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component = obj_
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component = obj_
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component = obj_
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic = obj_
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat = obj_
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex = obj_
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split = obj_
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring = obj_
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference = obj_
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture = obj_
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique = obj_
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex = obj_
            obj_.original_tagname_ = 'glob_to_regex'
# end class SubstringFunctionType


class TimeDifferenceFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, format_1='year_month_day', format_2='year_month_day', object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.format_1 = _cast(None, format_1)
        self.format_1_nsprefix_ = None
        self.format_2 = _cast(None, format_2)
        self.format_2_nsprefix_ = None
        if object_component is None:
            self.object_component = []
        else:
            self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        if variable_component is None:
            self.variable_component = []
        else:
            self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        if literal_component is None:
            self.literal_component = []
        else:
            self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        if arithmetic is None:
            self.arithmetic = []
        else:
            self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        if begin is None:
            self.begin = []
        else:
            self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        if concat is None:
            self.concat = []
        else:
            self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        if end is None:
            self.end = []
        else:
            self.end = end
        self.end_nsprefix_ = "oval-def"
        if escape_regex is None:
            self.escape_regex = []
        else:
            self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        if split is None:
            self.split = []
        else:
            self.split = split
        self.split_nsprefix_ = "oval-def"
        if substring is None:
            self.substring = []
        else:
            self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        if time_difference is None:
            self.time_difference = []
        else:
            self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        if regex_capture is None:
            self.regex_capture = []
        else:
            self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        if unique is None:
            self.unique = []
        else:
            self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        if count is None:
            self.count = []
        else:
            self.count = count
        self.count_nsprefix_ = "oval-def"
        if glob_to_regex is None:
            self.glob_to_regex = []
        else:
            self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeDifferenceFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeDifferenceFunctionType.subclass:
            return TimeDifferenceFunctionType.subclass(*args_, **kwargs_)
        else:
            return TimeDifferenceFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def add_object_component(self, value):
        self.object_component.append(value)
    def insert_object_component_at(self, index, value):
        self.object_component.insert(index, value)
    def replace_object_component_at(self, index, value):
        self.object_component[index] = value
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def add_variable_component(self, value):
        self.variable_component.append(value)
    def insert_variable_component_at(self, index, value):
        self.variable_component.insert(index, value)
    def replace_variable_component_at(self, index, value):
        self.variable_component[index] = value
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def add_literal_component(self, value):
        self.literal_component.append(value)
    def insert_literal_component_at(self, index, value):
        self.literal_component.insert(index, value)
    def replace_literal_component_at(self, index, value):
        self.literal_component[index] = value
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def add_arithmetic(self, value):
        self.arithmetic.append(value)
    def insert_arithmetic_at(self, index, value):
        self.arithmetic.insert(index, value)
    def replace_arithmetic_at(self, index, value):
        self.arithmetic[index] = value
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def add_begin(self, value):
        self.begin.append(value)
    def insert_begin_at(self, index, value):
        self.begin.insert(index, value)
    def replace_begin_at(self, index, value):
        self.begin[index] = value
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def add_concat(self, value):
        self.concat.append(value)
    def insert_concat_at(self, index, value):
        self.concat.insert(index, value)
    def replace_concat_at(self, index, value):
        self.concat[index] = value
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def add_end(self, value):
        self.end.append(value)
    def insert_end_at(self, index, value):
        self.end.insert(index, value)
    def replace_end_at(self, index, value):
        self.end[index] = value
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def add_escape_regex(self, value):
        self.escape_regex.append(value)
    def insert_escape_regex_at(self, index, value):
        self.escape_regex.insert(index, value)
    def replace_escape_regex_at(self, index, value):
        self.escape_regex[index] = value
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def add_split(self, value):
        self.split.append(value)
    def insert_split_at(self, index, value):
        self.split.insert(index, value)
    def replace_split_at(self, index, value):
        self.split[index] = value
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def add_substring(self, value):
        self.substring.append(value)
    def insert_substring_at(self, index, value):
        self.substring.insert(index, value)
    def replace_substring_at(self, index, value):
        self.substring[index] = value
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def add_time_difference(self, value):
        self.time_difference.append(value)
    def insert_time_difference_at(self, index, value):
        self.time_difference.insert(index, value)
    def replace_time_difference_at(self, index, value):
        self.time_difference[index] = value
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def add_regex_capture(self, value):
        self.regex_capture.append(value)
    def insert_regex_capture_at(self, index, value):
        self.regex_capture.insert(index, value)
    def replace_regex_capture_at(self, index, value):
        self.regex_capture[index] = value
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def add_unique(self, value):
        self.unique.append(value)
    def insert_unique_at(self, index, value):
        self.unique.insert(index, value)
    def replace_unique_at(self, index, value):
        self.unique[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def add_count(self, value):
        self.count.append(value)
    def insert_count_at(self, index, value):
        self.count.insert(index, value)
    def replace_count_at(self, index, value):
        self.count[index] = value
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def add_glob_to_regex(self, value):
        self.glob_to_regex.append(value)
    def insert_glob_to_regex_at(self, index, value):
        self.glob_to_regex.insert(index, value)
    def replace_glob_to_regex_at(self, index, value):
        self.glob_to_regex[index] = value
    def get_format_1(self):
        return self.format_1
    def set_format_1(self, format_1):
        self.format_1 = format_1
    def get_format_2(self):
        return self.format_2
    def set_format_2(self, format_2):
        self.format_2 = format_2
    def validate_DateTimeFormatEnumeration(self, value):
        # Validate type oval-def:DateTimeFormatEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['year_month_day', 'month_day_year', 'day_month_year', 'win_filetime', 'seconds_since_epoch', 'cim_datetime']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DateTimeFormatEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.object_component or
            self.variable_component or
            self.literal_component or
            self.arithmetic or
            self.begin or
            self.concat or
            self.end or
            self.escape_regex or
            self.split or
            self.substring or
            self.time_difference or
            self.regex_capture or
            self.unique or
            self.count or
            self.glob_to_regex
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='TimeDifferenceFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeDifferenceFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeDifferenceFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeDifferenceFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeDifferenceFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='TimeDifferenceFunctionType'):
        if self.format_1 != "year_month_day" and 'format_1' not in already_processed:
            already_processed.add('format_1')
            outfile.write(' format_1=%s' % (quote_attrib(self.format_1), ))
        if self.format_2 != "year_month_day" and 'format_2' not in already_processed:
            already_processed.add('format_2')
            outfile.write(' format_2=%s' % (quote_attrib(self.format_2), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='TimeDifferenceFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_component_ in self.object_component:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            object_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        for variable_component_ in self.variable_component:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            variable_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        for literal_component_ in self.literal_component:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            literal_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        for arithmetic_ in self.arithmetic:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            arithmetic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        for begin_ in self.begin:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            begin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        for concat_ in self.concat:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            concat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        for end_ in self.end:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            end_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        for escape_regex_ in self.escape_regex:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            escape_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        for split_ in self.split:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            split_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        for substring_ in self.substring:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            substring_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        for time_difference_ in self.time_difference:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            time_difference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        for regex_capture_ in self.regex_capture:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            regex_capture_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        for unique_ in self.unique:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            unique_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        for count_ in self.count:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            count_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        for glob_to_regex_ in self.glob_to_regex:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            glob_to_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('format_1', node)
        if value is not None and 'format_1' not in already_processed:
            already_processed.add('format_1')
            self.format_1 = value
            self.validate_DateTimeFormatEnumeration(self.format_1)    # validate type DateTimeFormatEnumeration
        value = find_attr_value_('format_2', node)
        if value is not None and 'format_2' not in already_processed:
            already_processed.add('format_2')
            self.format_2 = value
            self.validate_DateTimeFormatEnumeration(self.format_2)    # validate type DateTimeFormatEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component.append(obj_)
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component.append(obj_)
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component.append(obj_)
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic.append(obj_)
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin.append(obj_)
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat.append(obj_)
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end.append(obj_)
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex.append(obj_)
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split.append(obj_)
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring.append(obj_)
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference.append(obj_)
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture.append(obj_)
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique.append(obj_)
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count.append(obj_)
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex.append(obj_)
            obj_.original_tagname_ = 'glob_to_regex'
# end class TimeDifferenceFunctionType


class RegexCaptureFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, pattern=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.pattern = _cast(None, pattern)
        self.pattern_nsprefix_ = None
        self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        self.end = end
        self.end_nsprefix_ = "oval-def"
        self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        self.split = split
        self.split_nsprefix_ = "oval-def"
        self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        self.count = count
        self.count_nsprefix_ = "oval-def"
        self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegexCaptureFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegexCaptureFunctionType.subclass:
            return RegexCaptureFunctionType.subclass(*args_, **kwargs_)
        else:
            return RegexCaptureFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def get_pattern(self):
        return self.pattern
    def set_pattern(self, pattern):
        self.pattern = pattern
    def has__content(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None or
            self.glob_to_regex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='RegexCaptureFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegexCaptureFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RegexCaptureFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RegexCaptureFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RegexCaptureFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='RegexCaptureFunctionType'):
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            outfile.write(' pattern=%s' % (quote_attrib(self.pattern), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='RegexCaptureFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            self.object_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            self.variable_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            self.literal_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            self.arithmetic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            self.concat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            self.escape_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            self.split.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            self.substring.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            self.time_difference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            self.regex_capture.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            self.unique.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            self.count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        if self.glob_to_regex is not None:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            self.glob_to_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pattern', node)
        if value is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            self.pattern = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component = obj_
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component = obj_
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component = obj_
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic = obj_
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat = obj_
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex = obj_
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split = obj_
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring = obj_
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference = obj_
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture = obj_
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique = obj_
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex = obj_
            obj_.original_tagname_ = 'glob_to_regex'
# end class RegexCaptureFunctionType


class UniqueFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        if object_component is None:
            self.object_component = []
        else:
            self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        if variable_component is None:
            self.variable_component = []
        else:
            self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        if literal_component is None:
            self.literal_component = []
        else:
            self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        if arithmetic is None:
            self.arithmetic = []
        else:
            self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        if begin is None:
            self.begin = []
        else:
            self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        if concat is None:
            self.concat = []
        else:
            self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        if end is None:
            self.end = []
        else:
            self.end = end
        self.end_nsprefix_ = "oval-def"
        if escape_regex is None:
            self.escape_regex = []
        else:
            self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        if split is None:
            self.split = []
        else:
            self.split = split
        self.split_nsprefix_ = "oval-def"
        if substring is None:
            self.substring = []
        else:
            self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        if time_difference is None:
            self.time_difference = []
        else:
            self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        if regex_capture is None:
            self.regex_capture = []
        else:
            self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        if unique is None:
            self.unique = []
        else:
            self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        if count is None:
            self.count = []
        else:
            self.count = count
        self.count_nsprefix_ = "oval-def"
        if glob_to_regex is None:
            self.glob_to_regex = []
        else:
            self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UniqueFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UniqueFunctionType.subclass:
            return UniqueFunctionType.subclass(*args_, **kwargs_)
        else:
            return UniqueFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def add_object_component(self, value):
        self.object_component.append(value)
    def insert_object_component_at(self, index, value):
        self.object_component.insert(index, value)
    def replace_object_component_at(self, index, value):
        self.object_component[index] = value
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def add_variable_component(self, value):
        self.variable_component.append(value)
    def insert_variable_component_at(self, index, value):
        self.variable_component.insert(index, value)
    def replace_variable_component_at(self, index, value):
        self.variable_component[index] = value
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def add_literal_component(self, value):
        self.literal_component.append(value)
    def insert_literal_component_at(self, index, value):
        self.literal_component.insert(index, value)
    def replace_literal_component_at(self, index, value):
        self.literal_component[index] = value
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def add_arithmetic(self, value):
        self.arithmetic.append(value)
    def insert_arithmetic_at(self, index, value):
        self.arithmetic.insert(index, value)
    def replace_arithmetic_at(self, index, value):
        self.arithmetic[index] = value
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def add_begin(self, value):
        self.begin.append(value)
    def insert_begin_at(self, index, value):
        self.begin.insert(index, value)
    def replace_begin_at(self, index, value):
        self.begin[index] = value
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def add_concat(self, value):
        self.concat.append(value)
    def insert_concat_at(self, index, value):
        self.concat.insert(index, value)
    def replace_concat_at(self, index, value):
        self.concat[index] = value
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def add_end(self, value):
        self.end.append(value)
    def insert_end_at(self, index, value):
        self.end.insert(index, value)
    def replace_end_at(self, index, value):
        self.end[index] = value
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def add_escape_regex(self, value):
        self.escape_regex.append(value)
    def insert_escape_regex_at(self, index, value):
        self.escape_regex.insert(index, value)
    def replace_escape_regex_at(self, index, value):
        self.escape_regex[index] = value
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def add_split(self, value):
        self.split.append(value)
    def insert_split_at(self, index, value):
        self.split.insert(index, value)
    def replace_split_at(self, index, value):
        self.split[index] = value
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def add_substring(self, value):
        self.substring.append(value)
    def insert_substring_at(self, index, value):
        self.substring.insert(index, value)
    def replace_substring_at(self, index, value):
        self.substring[index] = value
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def add_time_difference(self, value):
        self.time_difference.append(value)
    def insert_time_difference_at(self, index, value):
        self.time_difference.insert(index, value)
    def replace_time_difference_at(self, index, value):
        self.time_difference[index] = value
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def add_regex_capture(self, value):
        self.regex_capture.append(value)
    def insert_regex_capture_at(self, index, value):
        self.regex_capture.insert(index, value)
    def replace_regex_capture_at(self, index, value):
        self.regex_capture[index] = value
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def add_unique(self, value):
        self.unique.append(value)
    def insert_unique_at(self, index, value):
        self.unique.insert(index, value)
    def replace_unique_at(self, index, value):
        self.unique[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def add_count(self, value):
        self.count.append(value)
    def insert_count_at(self, index, value):
        self.count.insert(index, value)
    def replace_count_at(self, index, value):
        self.count[index] = value
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def add_glob_to_regex(self, value):
        self.glob_to_regex.append(value)
    def insert_glob_to_regex_at(self, index, value):
        self.glob_to_regex.insert(index, value)
    def replace_glob_to_regex_at(self, index, value):
        self.glob_to_regex[index] = value
    def has__content(self):
        if (
            self.object_component or
            self.variable_component or
            self.literal_component or
            self.arithmetic or
            self.begin or
            self.concat or
            self.end or
            self.escape_regex or
            self.split or
            self.substring or
            self.time_difference or
            self.regex_capture or
            self.unique or
            self.count or
            self.glob_to_regex
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='UniqueFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UniqueFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UniqueFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UniqueFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UniqueFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='UniqueFunctionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='UniqueFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_component_ in self.object_component:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            object_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        for variable_component_ in self.variable_component:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            variable_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        for literal_component_ in self.literal_component:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            literal_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        for arithmetic_ in self.arithmetic:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            arithmetic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        for begin_ in self.begin:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            begin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        for concat_ in self.concat:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            concat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        for end_ in self.end:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            end_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        for escape_regex_ in self.escape_regex:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            escape_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        for split_ in self.split:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            split_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        for substring_ in self.substring:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            substring_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        for time_difference_ in self.time_difference:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            time_difference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        for regex_capture_ in self.regex_capture:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            regex_capture_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        for unique_ in self.unique:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            unique_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        for count_ in self.count:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            count_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        for glob_to_regex_ in self.glob_to_regex:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            glob_to_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component.append(obj_)
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component.append(obj_)
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component.append(obj_)
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic.append(obj_)
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin.append(obj_)
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat.append(obj_)
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end.append(obj_)
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex.append(obj_)
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split.append(obj_)
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring.append(obj_)
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference.append(obj_)
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture.append(obj_)
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique.append(obj_)
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count.append(obj_)
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex.append(obj_)
            obj_.original_tagname_ = 'glob_to_regex'
# end class UniqueFunctionType


class CountFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        if object_component is None:
            self.object_component = []
        else:
            self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        if variable_component is None:
            self.variable_component = []
        else:
            self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        if literal_component is None:
            self.literal_component = []
        else:
            self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        if arithmetic is None:
            self.arithmetic = []
        else:
            self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        if begin is None:
            self.begin = []
        else:
            self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        if concat is None:
            self.concat = []
        else:
            self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        if end is None:
            self.end = []
        else:
            self.end = end
        self.end_nsprefix_ = "oval-def"
        if escape_regex is None:
            self.escape_regex = []
        else:
            self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        if split is None:
            self.split = []
        else:
            self.split = split
        self.split_nsprefix_ = "oval-def"
        if substring is None:
            self.substring = []
        else:
            self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        if time_difference is None:
            self.time_difference = []
        else:
            self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        if regex_capture is None:
            self.regex_capture = []
        else:
            self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        if unique is None:
            self.unique = []
        else:
            self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        if count is None:
            self.count = []
        else:
            self.count = count
        self.count_nsprefix_ = "oval-def"
        if glob_to_regex is None:
            self.glob_to_regex = []
        else:
            self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountFunctionType.subclass:
            return CountFunctionType.subclass(*args_, **kwargs_)
        else:
            return CountFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def add_object_component(self, value):
        self.object_component.append(value)
    def insert_object_component_at(self, index, value):
        self.object_component.insert(index, value)
    def replace_object_component_at(self, index, value):
        self.object_component[index] = value
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def add_variable_component(self, value):
        self.variable_component.append(value)
    def insert_variable_component_at(self, index, value):
        self.variable_component.insert(index, value)
    def replace_variable_component_at(self, index, value):
        self.variable_component[index] = value
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def add_literal_component(self, value):
        self.literal_component.append(value)
    def insert_literal_component_at(self, index, value):
        self.literal_component.insert(index, value)
    def replace_literal_component_at(self, index, value):
        self.literal_component[index] = value
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def add_arithmetic(self, value):
        self.arithmetic.append(value)
    def insert_arithmetic_at(self, index, value):
        self.arithmetic.insert(index, value)
    def replace_arithmetic_at(self, index, value):
        self.arithmetic[index] = value
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def add_begin(self, value):
        self.begin.append(value)
    def insert_begin_at(self, index, value):
        self.begin.insert(index, value)
    def replace_begin_at(self, index, value):
        self.begin[index] = value
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def add_concat(self, value):
        self.concat.append(value)
    def insert_concat_at(self, index, value):
        self.concat.insert(index, value)
    def replace_concat_at(self, index, value):
        self.concat[index] = value
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def add_end(self, value):
        self.end.append(value)
    def insert_end_at(self, index, value):
        self.end.insert(index, value)
    def replace_end_at(self, index, value):
        self.end[index] = value
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def add_escape_regex(self, value):
        self.escape_regex.append(value)
    def insert_escape_regex_at(self, index, value):
        self.escape_regex.insert(index, value)
    def replace_escape_regex_at(self, index, value):
        self.escape_regex[index] = value
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def add_split(self, value):
        self.split.append(value)
    def insert_split_at(self, index, value):
        self.split.insert(index, value)
    def replace_split_at(self, index, value):
        self.split[index] = value
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def add_substring(self, value):
        self.substring.append(value)
    def insert_substring_at(self, index, value):
        self.substring.insert(index, value)
    def replace_substring_at(self, index, value):
        self.substring[index] = value
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def add_time_difference(self, value):
        self.time_difference.append(value)
    def insert_time_difference_at(self, index, value):
        self.time_difference.insert(index, value)
    def replace_time_difference_at(self, index, value):
        self.time_difference[index] = value
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def add_regex_capture(self, value):
        self.regex_capture.append(value)
    def insert_regex_capture_at(self, index, value):
        self.regex_capture.insert(index, value)
    def replace_regex_capture_at(self, index, value):
        self.regex_capture[index] = value
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def add_unique(self, value):
        self.unique.append(value)
    def insert_unique_at(self, index, value):
        self.unique.insert(index, value)
    def replace_unique_at(self, index, value):
        self.unique[index] = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def add_count(self, value):
        self.count.append(value)
    def insert_count_at(self, index, value):
        self.count.insert(index, value)
    def replace_count_at(self, index, value):
        self.count[index] = value
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def add_glob_to_regex(self, value):
        self.glob_to_regex.append(value)
    def insert_glob_to_regex_at(self, index, value):
        self.glob_to_regex.insert(index, value)
    def replace_glob_to_regex_at(self, index, value):
        self.glob_to_regex[index] = value
    def has__content(self):
        if (
            self.object_component or
            self.variable_component or
            self.literal_component or
            self.arithmetic or
            self.begin or
            self.concat or
            self.end or
            self.escape_regex or
            self.split or
            self.substring or
            self.time_difference or
            self.regex_capture or
            self.unique or
            self.count or
            self.glob_to_regex
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='CountFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CountFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CountFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CountFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CountFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='CountFunctionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='CountFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_component_ in self.object_component:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            object_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        for variable_component_ in self.variable_component:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            variable_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        for literal_component_ in self.literal_component:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            literal_component_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        for arithmetic_ in self.arithmetic:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            arithmetic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        for begin_ in self.begin:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            begin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        for concat_ in self.concat:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            concat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        for end_ in self.end:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            end_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        for escape_regex_ in self.escape_regex:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            escape_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        for split_ in self.split:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            split_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        for substring_ in self.substring:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            substring_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        for time_difference_ in self.time_difference:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            time_difference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        for regex_capture_ in self.regex_capture:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            regex_capture_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        for unique_ in self.unique:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            unique_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        for count_ in self.count:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            count_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        for glob_to_regex_ in self.glob_to_regex:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            glob_to_regex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component.append(obj_)
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component.append(obj_)
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component.append(obj_)
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic.append(obj_)
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin.append(obj_)
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat.append(obj_)
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end.append(obj_)
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex.append(obj_)
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split.append(obj_)
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring.append(obj_)
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference.append(obj_)
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture.append(obj_)
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique.append(obj_)
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count.append(obj_)
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex.append(obj_)
            obj_.original_tagname_ = 'glob_to_regex'
# end class CountFunctionType


class GlobToRegexFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, glob_noescape='false', object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None, glob_to_regex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        self.glob_noescape = _cast(None, glob_noescape)
        self.glob_noescape_nsprefix_ = None
        self.object_component = object_component
        self.object_component_nsprefix_ = "oval-def"
        self.variable_component = variable_component
        self.variable_component_nsprefix_ = "oval-def"
        self.literal_component = literal_component
        self.literal_component_nsprefix_ = "oval-def"
        self.arithmetic = arithmetic
        self.arithmetic_nsprefix_ = "oval-def"
        self.begin = begin
        self.begin_nsprefix_ = "oval-def"
        self.concat = concat
        self.concat_nsprefix_ = "oval-def"
        self.end = end
        self.end_nsprefix_ = "oval-def"
        self.escape_regex = escape_regex
        self.escape_regex_nsprefix_ = "oval-def"
        self.split = split
        self.split_nsprefix_ = "oval-def"
        self.substring = substring
        self.substring_nsprefix_ = "oval-def"
        self.time_difference = time_difference
        self.time_difference_nsprefix_ = "oval-def"
        self.regex_capture = regex_capture
        self.regex_capture_nsprefix_ = "oval-def"
        self.unique = unique
        self.unique_nsprefix_ = "oval-def"
        self.count = count
        self.count_nsprefix_ = "oval-def"
        self.glob_to_regex = glob_to_regex
        self.glob_to_regex_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlobToRegexFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlobToRegexFunctionType.subclass:
            return GlobToRegexFunctionType.subclass(*args_, **kwargs_)
        else:
            return GlobToRegexFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_object_component(self):
        return self.object_component
    def set_object_component(self, object_component):
        self.object_component = object_component
    def get_variable_component(self):
        return self.variable_component
    def set_variable_component(self, variable_component):
        self.variable_component = variable_component
    def get_literal_component(self):
        return self.literal_component
    def set_literal_component(self, literal_component):
        self.literal_component = literal_component
    def get_arithmetic(self):
        return self.arithmetic
    def set_arithmetic(self, arithmetic):
        self.arithmetic = arithmetic
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_concat(self):
        return self.concat
    def set_concat(self, concat):
        self.concat = concat
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def get_escape_regex(self):
        return self.escape_regex
    def set_escape_regex(self, escape_regex):
        self.escape_regex = escape_regex
    def get_split(self):
        return self.split
    def set_split(self, split):
        self.split = split
    def get_substring(self):
        return self.substring
    def set_substring(self, substring):
        self.substring = substring
    def get_time_difference(self):
        return self.time_difference
    def set_time_difference(self, time_difference):
        self.time_difference = time_difference
    def get_regex_capture(self):
        return self.regex_capture
    def set_regex_capture(self, regex_capture):
        self.regex_capture = regex_capture
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_glob_to_regex(self):
        return self.glob_to_regex
    def set_glob_to_regex(self, glob_to_regex):
        self.glob_to_regex = glob_to_regex
    def get_glob_noescape(self):
        return self.glob_noescape
    def set_glob_noescape(self, glob_noescape):
        self.glob_noescape = glob_noescape
    def has__content(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None or
            self.glob_to_regex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='GlobToRegexFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GlobToRegexFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GlobToRegexFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GlobToRegexFunctionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GlobToRegexFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='GlobToRegexFunctionType'):
        if self.glob_noescape != "false" and 'glob_noescape' not in already_processed:
            already_processed.add('glob_noescape')
            outfile.write(' glob_noescape=%s' % (quote_attrib(self.glob_noescape), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='GlobToRegexFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            namespaceprefix_ = self.object_component_nsprefix_ + ':' if (UseCapturedNS_ and self.object_component_nsprefix_) else ''
            self.object_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            namespaceprefix_ = self.variable_component_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_component_nsprefix_) else ''
            self.variable_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            namespaceprefix_ = self.literal_component_nsprefix_ + ':' if (UseCapturedNS_ and self.literal_component_nsprefix_) else ''
            self.literal_component.export(outfile, level, namespaceprefix_, namespacedef_='', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            namespaceprefix_ = self.arithmetic_nsprefix_ + ':' if (UseCapturedNS_ and self.arithmetic_nsprefix_) else ''
            self.arithmetic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            namespaceprefix_ = self.begin_nsprefix_ + ':' if (UseCapturedNS_ and self.begin_nsprefix_) else ''
            self.begin.export(outfile, level, namespaceprefix_, namespacedef_='', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            namespaceprefix_ = self.concat_nsprefix_ + ':' if (UseCapturedNS_ and self.concat_nsprefix_) else ''
            self.concat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            namespaceprefix_ = self.end_nsprefix_ + ':' if (UseCapturedNS_ and self.end_nsprefix_) else ''
            self.end.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            namespaceprefix_ = self.escape_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.escape_regex_nsprefix_) else ''
            self.escape_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            namespaceprefix_ = self.split_nsprefix_ + ':' if (UseCapturedNS_ and self.split_nsprefix_) else ''
            self.split.export(outfile, level, namespaceprefix_, namespacedef_='', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            namespaceprefix_ = self.substring_nsprefix_ + ':' if (UseCapturedNS_ and self.substring_nsprefix_) else ''
            self.substring.export(outfile, level, namespaceprefix_, namespacedef_='', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            namespaceprefix_ = self.time_difference_nsprefix_ + ':' if (UseCapturedNS_ and self.time_difference_nsprefix_) else ''
            self.time_difference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            namespaceprefix_ = self.regex_capture_nsprefix_ + ':' if (UseCapturedNS_ and self.regex_capture_nsprefix_) else ''
            self.regex_capture.export(outfile, level, namespaceprefix_, namespacedef_='', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            namespaceprefix_ = self.unique_nsprefix_ + ':' if (UseCapturedNS_ and self.unique_nsprefix_) else ''
            self.unique.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            self.count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
        if self.glob_to_regex is not None:
            namespaceprefix_ = self.glob_to_regex_nsprefix_ + ':' if (UseCapturedNS_ and self.glob_to_regex_nsprefix_) else ''
            self.glob_to_regex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glob_to_regex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('glob_noescape', node)
        if value is not None and 'glob_noescape' not in already_processed:
            already_processed.add('glob_noescape')
            self.glob_noescape = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object_component = obj_
            obj_.original_tagname_ = 'object_component'
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_component = obj_
            obj_.original_tagname_ = 'variable_component'
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.literal_component = obj_
            obj_.original_tagname_ = 'literal_component'
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arithmetic = obj_
            obj_.original_tagname_ = 'arithmetic'
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.concat = obj_
            obj_.original_tagname_ = 'concat'
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.escape_regex = obj_
            obj_.original_tagname_ = 'escape_regex'
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.split = obj_
            obj_.original_tagname_ = 'split'
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.substring = obj_
            obj_.original_tagname_ = 'substring'
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_difference = obj_
            obj_.original_tagname_ = 'time_difference'
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regex_capture = obj_
            obj_.original_tagname_ = 'regex_capture'
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unique = obj_
            obj_.original_tagname_ = 'unique'
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
        elif nodeName_ == 'glob_to_regex':
            obj_ = GlobToRegexFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glob_to_regex = obj_
            obj_.original_tagname_ = 'glob_to_regex'
# end class GlobToRegexFunctionType


class EntitySimpleBaseType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.operation = _cast(None, operation)
        self.operation_nsprefix_ = None
        self.mask = _cast(None, mask)
        self.mask_nsprefix_ = None
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
        self.var_check = _cast(None, var_check)
        self.var_check_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntitySimpleBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntitySimpleBaseType.subclass:
            return EntitySimpleBaseType.subclass(*args_, **kwargs_)
        else:
            return EntitySimpleBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_operation(self):
        return self.operation
    def set_operation(self, operation):
        self.operation = operation
    def get_mask(self):
        return self.mask
    def set_mask(self, mask):
        self.mask = mask
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def get_var_check(self):
        return self.var_check
    def set_var_check(self, var_check):
        self.var_check = var_check
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DatatypeEnumeration(self, value):
        # Validate type oval:DatatypeEnumeration, a restriction on None.
        pass
    def validate_OperationEnumeration(self, value):
        # Validate type oval:OperationEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['equals', 'not equal', 'case insensitive equals', 'case insensitive not equal', 'greater than', 'less than', 'greater than or equal', 'less than or equal', 'bitwise and', 'bitwise or', 'pattern match', 'subset of', 'superset of']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperationEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_VariableIDPattern(self, value):
        # Validate type oval:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def validate_CheckEnumeration(self, value):
        # Validate type oval:CheckEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all', 'at least one', 'none exist', 'none satisfy', 'only one']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CheckEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntitySimpleBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntitySimpleBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntitySimpleBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntitySimpleBaseType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntitySimpleBaseType'):
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.operation != "equals" and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
        if self.mask != "false" and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(' mask=%s' % (quote_attrib(self.mask), ))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntitySimpleBaseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_DatatypeEnumeration(self.datatype)    # validate type DatatypeEnumeration
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
            self.validate_OperationEnumeration(self.operation)    # validate type OperationEnumeration
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            self.mask = value
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
        value = find_attr_value_('var_check', node)
        if value is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            self.var_check = value
            self.validate_CheckEnumeration(self.var_check)    # validate type CheckEnumeration
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntitySimpleBaseType


class EntityComplexBaseType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.operation = _cast(None, operation)
        self.operation_nsprefix_ = None
        self.mask = _cast(None, mask)
        self.mask_nsprefix_ = None
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
        self.var_check = _cast(None, var_check)
        self.var_check_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityComplexBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityComplexBaseType.subclass:
            return EntityComplexBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityComplexBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_operation(self):
        return self.operation
    def set_operation(self, operation):
        self.operation = operation
    def get_mask(self):
        return self.mask
    def set_mask(self, mask):
        self.mask = mask
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def get_var_check(self):
        return self.var_check
    def set_var_check(self, var_check):
        self.var_check = var_check
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DatatypeEnumeration(self, value):
        # Validate type oval:DatatypeEnumeration, a restriction on None.
        pass
    def validate_OperationEnumeration(self, value):
        # Validate type oval:OperationEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['equals', 'not equal', 'case insensitive equals', 'case insensitive not equal', 'greater than', 'less than', 'greater than or equal', 'less than or equal', 'bitwise and', 'bitwise or', 'pattern match', 'subset of', 'superset of']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperationEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_VariableIDPattern(self, value):
        # Validate type oval:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def validate_CheckEnumeration(self, value):
        # Validate type oval:CheckEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all', 'at least one', 'none exist', 'none satisfy', 'only one']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CheckEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityComplexBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityComplexBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityComplexBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityComplexBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EntityComplexBaseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityComplexBaseType'):
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.operation != "equals" and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
        if self.mask != "false" and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(' mask=%s' % (quote_attrib(self.mask), ))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityComplexBaseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_DatatypeEnumeration(self.datatype)    # validate type DatatypeEnumeration
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
            self.validate_OperationEnumeration(self.operation)    # validate type OperationEnumeration
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            self.mask = value
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
        value = find_attr_value_('var_check', node)
        if value is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            self.var_check = value
            self.validate_CheckEnumeration(self.var_check)    # validate type CheckEnumeration
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityComplexBaseType


class EntityObjectIPAddressType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectIPAddressType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectIPAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectIPAddressType.subclass:
            return EntityObjectIPAddressType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectIPAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectIPAddressType(self, value):
        result = True
        # Validate type EntityObjectIPAddressType, a restriction on xsd:string.
        pass
        return result
    def validate_datatypeType(self, value):
        # Validate type datatypeType, a restriction on oval:SimpleDatatypeEnumeration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ipv4_address', 'ipv6_address']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectIPAddressType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectIPAddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectIPAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectIPAddressType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectIPAddressType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectIPAddressType'):
        super(EntityObjectIPAddressType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectIPAddressType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectIPAddressType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectIPAddressType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_datatypeType(self.datatype)    # validate type datatypeType
        super(EntityObjectIPAddressType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectIPAddressType


class EntityObjectIPAddressStringType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectIPAddressStringType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectIPAddressStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectIPAddressStringType.subclass:
            return EntityObjectIPAddressStringType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectIPAddressStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectIPAddressStringType(self, value):
        result = True
        # Validate type EntityObjectIPAddressStringType, a restriction on xsd:string.
        pass
        return result
    def validate_datatypeType44(self, value):
        # Validate type datatypeType44, a restriction on oval:SimpleDatatypeEnumeration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ipv4_address', 'ipv6_address', 'string']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType44' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType44' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectIPAddressStringType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectIPAddressStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectIPAddressStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectIPAddressStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectIPAddressStringType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectIPAddressStringType'):
        super(EntityObjectIPAddressStringType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectIPAddressStringType')
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectIPAddressStringType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectIPAddressStringType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_datatypeType44(self.datatype)    # validate type datatypeType44
        super(EntityObjectIPAddressStringType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectIPAddressStringType


class EntityObjectAnySimpleType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectAnySimpleType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectAnySimpleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectAnySimpleType.subclass:
            return EntityObjectAnySimpleType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectAnySimpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectAnySimpleType(self, value):
        result = True
        # Validate type EntityObjectAnySimpleType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectAnySimpleType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectAnySimpleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectAnySimpleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectAnySimpleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectAnySimpleType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectAnySimpleType'):
        super(EntityObjectAnySimpleType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectAnySimpleType')
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectAnySimpleType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectAnySimpleType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityObjectAnySimpleType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectAnySimpleType


class EntityObjectBinaryType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectBinaryType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectBinaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectBinaryType.subclass:
            return EntityObjectBinaryType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectBinaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectBinaryType(self, value):
        result = True
        # Validate type EntityObjectBinaryType, a restriction on None.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectBinaryType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectBinaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectBinaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectBinaryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectBinaryType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectBinaryType'):
        super(EntityObjectBinaryType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectBinaryType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectBinaryType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectBinaryType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityObjectBinaryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectBinaryType


class EntityObjectBoolType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectBoolType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectBoolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectBoolType.subclass:
            return EntityObjectBoolType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectBoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectBoolType(self, value):
        result = True
        # Validate type EntityObjectBoolType, a restriction on None.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectBoolType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectBoolType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectBoolType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectBoolType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectBoolType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectBoolType'):
        super(EntityObjectBoolType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectBoolType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectBoolType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectBoolType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityObjectBoolType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectBoolType


class EntityObjectFloatType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectFloatType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectFloatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectFloatType.subclass:
            return EntityObjectFloatType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectFloatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectFloatType(self, value):
        result = True
        # Validate type EntityObjectFloatType, a restriction on None.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectFloatType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectFloatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectFloatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectFloatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectFloatType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectFloatType'):
        super(EntityObjectFloatType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectFloatType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectFloatType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectFloatType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityObjectFloatType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectFloatType


class EntityObjectIntType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectIntType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectIntType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectIntType.subclass:
            return EntityObjectIntType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectIntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectIntType(self, value):
        result = True
        # Validate type EntityObjectIntType, a restriction on None.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectIntType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectIntType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectIntType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectIntType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectIntType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectIntType'):
        super(EntityObjectIntType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectIntType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectIntType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectIntType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityObjectIntType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectIntType


class EntityObjectStringType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectStringType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectStringType.subclass:
            return EntityObjectStringType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectStringType(self, value):
        result = True
        # Validate type EntityObjectStringType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectStringType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectStringType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectStringType'):
        super(EntityObjectStringType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectStringType')
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectStringType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectStringType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityObjectStringType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectStringType


class EntityObjectVersionType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityObjectVersionType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectVersionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectVersionType.subclass:
            return EntityObjectVersionType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityObjectVersionType(self, value):
        result = True
        # Validate type EntityObjectVersionType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityObjectVersionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectVersionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectVersionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectVersionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectVersionType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectVersionType'):
        super(EntityObjectVersionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectVersionType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectVersionType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectVersionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityObjectVersionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectVersionType


class EntityObjectRecordType(EntityComplexBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityComplexBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        super(globals().get("EntityObjectRecordType"), self).__init__(datatype, operation, mask, var_ref, var_check,  **kwargs_)
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectRecordType.subclass:
            return EntityObjectRecordType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def add_field(self, value):
        self.field.append(value)
    def insert_field_at(self, index, value):
        self.field.insert(index, value)
    def replace_field_at(self, index, value):
        self.field[index] = value
    def has__content(self):
        if (
            self.field or
            super(EntityObjectRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='EntityObjectRecordType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectRecordType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectRecordType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectRecordType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EntityObjectRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectRecordType'):
        super(EntityObjectRecordType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectRecordType')
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='EntityObjectRecordType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectRecordType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for field_ in self.field:
            namespaceprefix_ = self.field_nsprefix_ + ':' if (UseCapturedNS_ and self.field_nsprefix_) else ''
            field_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EntityObjectRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'field':
            obj_ = EntityObjectFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        super(EntityObjectRecordType, self)._buildChildren(child_, node, nodeName_, True)
# end class EntityObjectRecordType


class EntityObjectFieldType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, entity_check='all', datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.entity_check = _cast(None, entity_check)
        self.entity_check_nsprefix_ = None
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.operation = _cast(None, operation)
        self.operation_nsprefix_ = None
        self.mask = _cast(None, mask)
        self.mask_nsprefix_ = None
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
        self.var_check = _cast(None, var_check)
        self.var_check_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityObjectFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityObjectFieldType.subclass:
            return EntityObjectFieldType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_entity_check(self):
        return self.entity_check
    def set_entity_check(self, entity_check):
        self.entity_check = entity_check
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_operation(self):
        return self.operation
    def set_operation(self, operation):
        self.operation = operation
    def get_mask(self):
        return self.mask
    def set_mask(self, mask):
        self.mask = mask
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def get_var_check(self):
        return self.var_check
    def set_var_check(self, var_check):
        self.var_check = var_check
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_nameType(self, value):
        # Validate type nameType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_nameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nameType_patterns_, ))
    validate_nameType_patterns_ = [['^([^A-Z]+)$']]
    def validate_CheckEnumeration(self, value):
        # Validate type oval:CheckEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all', 'at least one', 'none exist', 'none satisfy', 'only one']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CheckEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DatatypeEnumeration(self, value):
        # Validate type oval:DatatypeEnumeration, a restriction on None.
        pass
    def validate_OperationEnumeration(self, value):
        # Validate type oval:OperationEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['equals', 'not equal', 'case insensitive equals', 'case insensitive not equal', 'greater than', 'less than', 'greater than or equal', 'less than or equal', 'bitwise and', 'bitwise or', 'pattern match', 'subset of', 'superset of']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperationEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_VariableIDPattern(self, value):
        # Validate type oval:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectFieldType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityObjectFieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityObjectFieldType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityObjectFieldType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityObjectFieldType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.entity_check != "all" and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.operation != "equals" and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
        if self.mask != "false" and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(' mask=%s' % (quote_attrib(self.mask), ))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityObjectFieldType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_nameType(self.name)    # validate type nameType
        value = find_attr_value_('entity_check', node)
        if value is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            self.entity_check = value
            self.validate_CheckEnumeration(self.entity_check)    # validate type CheckEnumeration
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_DatatypeEnumeration(self.datatype)    # validate type DatatypeEnumeration
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
            self.validate_OperationEnumeration(self.operation)    # validate type OperationEnumeration
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            self.mask = value
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
        value = find_attr_value_('var_check', node)
        if value is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            self.var_check = value
            self.validate_CheckEnumeration(self.var_check)    # validate type CheckEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityObjectFieldType


class EntityStateSimpleBaseType(EntitySimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateSimpleBaseType"), self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, extensiontype_,  **kwargs_)
        self.entity_check = _cast(None, entity_check)
        self.entity_check_nsprefix_ = None
        self.check_existence = _cast(None, check_existence)
        self.check_existence_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateSimpleBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateSimpleBaseType.subclass:
            return EntityStateSimpleBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityStateSimpleBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entity_check(self):
        return self.entity_check
    def set_entity_check(self, entity_check):
        self.entity_check = entity_check
    def get_check_existence(self):
        return self.check_existence
    def set_check_existence(self, check_existence):
        self.check_existence = check_existence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_CheckEnumeration(self, value):
        # Validate type oval:CheckEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all', 'at least one', 'none exist', 'none satisfy', 'only one']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CheckEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ExistenceEnumeration(self, value):
        # Validate type oval:ExistenceEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all_exist', 'any_exist', 'at_least_one_exists', 'none_exist', 'only_one_exists']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ExistenceEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateSimpleBaseType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateSimpleBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateSimpleBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateSimpleBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateSimpleBaseType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateSimpleBaseType'):
        super(EntityStateSimpleBaseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateSimpleBaseType')
        if self.entity_check != "all" and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.check_existence != "at_least_one_exists" and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            outfile.write(' check_existence=%s' % (quote_attrib(self.check_existence), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateSimpleBaseType', fromsubclass_=False, pretty_print=True):
        super(EntityStateSimpleBaseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entity_check', node)
        if value is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            self.entity_check = value
            self.validate_CheckEnumeration(self.entity_check)    # validate type CheckEnumeration
        value = find_attr_value_('check_existence', node)
        if value is not None and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            self.check_existence = value
            self.validate_ExistenceEnumeration(self.check_existence)    # validate type ExistenceEnumeration
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EntityStateSimpleBaseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateSimpleBaseType


class EntityStateComplexBaseType(EntityComplexBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityComplexBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateComplexBaseType"), self).__init__(datatype, operation, mask, var_ref, var_check, extensiontype_,  **kwargs_)
        self.entity_check = _cast(None, entity_check)
        self.entity_check_nsprefix_ = None
        self.check_existence = _cast(None, check_existence)
        self.check_existence_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateComplexBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateComplexBaseType.subclass:
            return EntityStateComplexBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityStateComplexBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entity_check(self):
        return self.entity_check
    def set_entity_check(self, entity_check):
        self.entity_check = entity_check
    def get_check_existence(self):
        return self.check_existence
    def set_check_existence(self, check_existence):
        self.check_existence = check_existence
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_CheckEnumeration(self, value):
        # Validate type oval:CheckEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all', 'at least one', 'none exist', 'none satisfy', 'only one']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CheckEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ExistenceEnumeration(self, value):
        # Validate type oval:ExistenceEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all_exist', 'any_exist', 'at_least_one_exists', 'none_exist', 'only_one_exists']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ExistenceEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(EntityStateComplexBaseType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateComplexBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateComplexBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateComplexBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateComplexBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EntityStateComplexBaseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateComplexBaseType'):
        super(EntityStateComplexBaseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateComplexBaseType')
        if self.entity_check != "all" and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.check_existence != "at_least_one_exists" and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            outfile.write(' check_existence=%s' % (quote_attrib(self.check_existence), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateComplexBaseType', fromsubclass_=False, pretty_print=True):
        super(EntityStateComplexBaseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entity_check', node)
        if value is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            self.entity_check = value
            self.validate_CheckEnumeration(self.entity_check)    # validate type CheckEnumeration
        value = find_attr_value_('check_existence', node)
        if value is not None and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            self.check_existence = value
            self.validate_ExistenceEnumeration(self.check_existence)    # validate type ExistenceEnumeration
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EntityStateComplexBaseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EntityStateComplexBaseType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class EntityStateComplexBaseType


class EntityStateIPAddressType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateIPAddressType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateIPAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateIPAddressType.subclass:
            return EntityStateIPAddressType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIPAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateIPAddressType(self, value):
        result = True
        # Validate type EntityStateIPAddressType, a restriction on xsd:string.
        pass
        return result
    def validate_datatypeType45(self, value):
        # Validate type datatypeType45, a restriction on oval:SimpleDatatypeEnumeration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ipv4_address', 'ipv6_address']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType45' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType45' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateIPAddressType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateIPAddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateIPAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateIPAddressType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateIPAddressType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateIPAddressType'):
        super(EntityStateIPAddressType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateIPAddressType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateIPAddressType', fromsubclass_=False, pretty_print=True):
        super(EntityStateIPAddressType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_datatypeType45(self.datatype)    # validate type datatypeType45
        super(EntityStateIPAddressType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateIPAddressType


class EntityStateIPAddressStringType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateIPAddressStringType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateIPAddressStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateIPAddressStringType.subclass:
            return EntityStateIPAddressStringType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIPAddressStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateIPAddressStringType(self, value):
        result = True
        # Validate type EntityStateIPAddressStringType, a restriction on xsd:string.
        pass
        return result
    def validate_datatypeType46(self, value):
        # Validate type datatypeType46, a restriction on oval:SimpleDatatypeEnumeration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ipv4_address', 'ipv6_address', 'string']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType46' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType46' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateIPAddressStringType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateIPAddressStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateIPAddressStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateIPAddressStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateIPAddressStringType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateIPAddressStringType'):
        super(EntityStateIPAddressStringType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateIPAddressStringType')
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateIPAddressStringType', fromsubclass_=False, pretty_print=True):
        super(EntityStateIPAddressStringType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_datatypeType46(self.datatype)    # validate type datatypeType46
        super(EntityStateIPAddressStringType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateIPAddressStringType


class EntityStateAnySimpleType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateAnySimpleType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateAnySimpleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateAnySimpleType.subclass:
            return EntityStateAnySimpleType.subclass(*args_, **kwargs_)
        else:
            return EntityStateAnySimpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateAnySimpleType(self, value):
        result = True
        # Validate type EntityStateAnySimpleType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateAnySimpleType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateAnySimpleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateAnySimpleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateAnySimpleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateAnySimpleType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateAnySimpleType'):
        super(EntityStateAnySimpleType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateAnySimpleType')
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateAnySimpleType', fromsubclass_=False, pretty_print=True):
        super(EntityStateAnySimpleType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateAnySimpleType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateAnySimpleType


class EntityStateBinaryType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateBinaryType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateBinaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateBinaryType.subclass:
            return EntityStateBinaryType.subclass(*args_, **kwargs_)
        else:
            return EntityStateBinaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateBinaryType(self, value):
        result = True
        # Validate type EntityStateBinaryType, a restriction on None.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateBinaryType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateBinaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateBinaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateBinaryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateBinaryType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateBinaryType'):
        super(EntityStateBinaryType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateBinaryType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateBinaryType', fromsubclass_=False, pretty_print=True):
        super(EntityStateBinaryType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateBinaryType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateBinaryType


class EntityStateBoolType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateBoolType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateBoolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateBoolType.subclass:
            return EntityStateBoolType.subclass(*args_, **kwargs_)
        else:
            return EntityStateBoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateBoolType(self, value):
        result = True
        # Validate type EntityStateBoolType, a restriction on None.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateBoolType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateBoolType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateBoolType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateBoolType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateBoolType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateBoolType'):
        super(EntityStateBoolType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateBoolType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateBoolType', fromsubclass_=False, pretty_print=True):
        super(EntityStateBoolType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateBoolType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateBoolType


class EntityStateFloatType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateFloatType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateFloatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateFloatType.subclass:
            return EntityStateFloatType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFloatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateFloatType(self, value):
        result = True
        # Validate type EntityStateFloatType, a restriction on None.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateFloatType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateFloatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateFloatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateFloatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateFloatType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateFloatType'):
        super(EntityStateFloatType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateFloatType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateFloatType', fromsubclass_=False, pretty_print=True):
        super(EntityStateFloatType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateFloatType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateFloatType


class EntityStateIntType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateIntType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateIntType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateIntType.subclass:
            return EntityStateIntType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateIntType(self, value):
        result = True
        # Validate type EntityStateIntType, a restriction on None.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateIntType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateIntType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateIntType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateIntType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateIntType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateIntType'):
        super(EntityStateIntType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateIntType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateIntType', fromsubclass_=False, pretty_print=True):
        super(EntityStateIntType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateIntType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateIntType


class EntityStateEVRStringType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateEVRStringType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateEVRStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateEVRStringType.subclass:
            return EntityStateEVRStringType.subclass(*args_, **kwargs_)
        else:
            return EntityStateEVRStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateEVRStringType(self, value):
        result = True
        # Validate type EntityStateEVRStringType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateEVRStringType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateEVRStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateEVRStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateEVRStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateEVRStringType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateEVRStringType'):
        super(EntityStateEVRStringType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateEVRStringType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateEVRStringType', fromsubclass_=False, pretty_print=True):
        super(EntityStateEVRStringType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateEVRStringType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateEVRStringType


class EntityStateDebianEVRStringType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateDebianEVRStringType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateDebianEVRStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateDebianEVRStringType.subclass:
            return EntityStateDebianEVRStringType.subclass(*args_, **kwargs_)
        else:
            return EntityStateDebianEVRStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateDebianEVRStringType(self, value):
        result = True
        # Validate type EntityStateDebianEVRStringType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateDebianEVRStringType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateDebianEVRStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateDebianEVRStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateDebianEVRStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateDebianEVRStringType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateDebianEVRStringType'):
        super(EntityStateDebianEVRStringType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateDebianEVRStringType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateDebianEVRStringType', fromsubclass_=False, pretty_print=True):
        super(EntityStateDebianEVRStringType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateDebianEVRStringType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateDebianEVRStringType


class EntityStateVersionType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateVersionType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateVersionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateVersionType.subclass:
            return EntityStateVersionType.subclass(*args_, **kwargs_)
        else:
            return EntityStateVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateVersionType(self, value):
        result = True
        # Validate type EntityStateVersionType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateVersionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateVersionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateVersionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateVersionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateVersionType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateVersionType'):
        super(EntityStateVersionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateVersionType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateVersionType', fromsubclass_=False, pretty_print=True):
        super(EntityStateVersionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateVersionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateVersionType


class EntityStateFileSetRevisionType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateFileSetRevisionType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateFileSetRevisionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateFileSetRevisionType.subclass:
            return EntityStateFileSetRevisionType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFileSetRevisionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateFileSetRevisionType(self, value):
        result = True
        # Validate type EntityStateFileSetRevisionType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateFileSetRevisionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateFileSetRevisionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateFileSetRevisionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateFileSetRevisionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateFileSetRevisionType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateFileSetRevisionType'):
        super(EntityStateFileSetRevisionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateFileSetRevisionType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateFileSetRevisionType', fromsubclass_=False, pretty_print=True):
        super(EntityStateFileSetRevisionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateFileSetRevisionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateFileSetRevisionType


class EntityStateIOSVersionType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateIOSVersionType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateIOSVersionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateIOSVersionType.subclass:
            return EntityStateIOSVersionType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIOSVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateIOSVersionType(self, value):
        result = True
        # Validate type EntityStateIOSVersionType, a restriction on xsd:string.
        pass
        return result
    def validate_datatypeType47(self, value):
        # Validate type datatypeType47, a restriction on oval:SimpleDatatypeEnumeration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ios_version', 'string']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType47' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on datatypeType47' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateIOSVersionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateIOSVersionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateIOSVersionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateIOSVersionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateIOSVersionType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateIOSVersionType'):
        super(EntityStateIOSVersionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateIOSVersionType')
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateIOSVersionType', fromsubclass_=False, pretty_print=True):
        super(EntityStateIOSVersionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_datatypeType47(self.datatype)    # validate type datatypeType47
        super(EntityStateIOSVersionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateIOSVersionType


class EntityStateStringType(EntityStateSimpleBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        super(globals().get("EntityStateStringType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence, valueOf_,  **kwargs_)
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateStringType.subclass:
            return EntityStateStringType.subclass(*args_, **kwargs_)
        else:
            return EntityStateStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_EntityStateStringType(self, value):
        result = True
        # Validate type EntityStateStringType, a restriction on xsd:string.
        pass
        return result
    def validate_SimpleDatatypeEnumeration(self, value):
        # Validate type oval:SimpleDatatypeEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['binary', 'boolean', 'evr_string', 'debian_evr_string', 'fileset_revision', 'float', 'ios_version', 'int', 'ipv4_address', 'ipv6_address', 'string', 'version']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SimpleDatatypeEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EntityStateStringType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateStringType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateStringType'):
        super(EntityStateStringType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateStringType')
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateStringType', fromsubclass_=False, pretty_print=True):
        super(EntityStateStringType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_SimpleDatatypeEnumeration(self.datatype)    # validate type SimpleDatatypeEnumeration
        super(EntityStateStringType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateStringType


class EntityStateRecordType(EntityStateComplexBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EntityStateComplexBaseType
    def __init__(self, datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, entity_check='all', check_existence='at_least_one_exists', field=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval-def"
        super(globals().get("EntityStateRecordType"), self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, check_existence,  **kwargs_)
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = "oval-def"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateRecordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateRecordType.subclass:
            return EntityStateRecordType.subclass(*args_, **kwargs_)
        else:
            return EntityStateRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def add_field(self, value):
        self.field.append(value)
    def insert_field_at(self, index, value):
        self.field.insert(index, value)
    def replace_field_at(self, index, value):
        self.field[index] = value
    def has__content(self):
        if (
            self.field or
            super(EntityStateRecordType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='EntityStateRecordType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateRecordType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateRecordType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateRecordType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EntityStateRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateRecordType'):
        super(EntityStateRecordType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateRecordType')
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='EntityStateRecordType', fromsubclass_=False, pretty_print=True):
        super(EntityStateRecordType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for field_ in self.field:
            namespaceprefix_ = self.field_nsprefix_ + ':' if (UseCapturedNS_ and self.field_nsprefix_) else ''
            field_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EntityStateRecordType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'field':
            obj_ = EntityStateFieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        super(EntityStateRecordType, self)._buildChildren(child_, node, nodeName_, True)
# end class EntityStateRecordType


class EntityStateFieldType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, entity_check='all', datatype='string', operation='equals', mask='false', var_ref=None, var_check=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "oval"
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.entity_check = _cast(None, entity_check)
        self.entity_check_nsprefix_ = None
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.operation = _cast(None, operation)
        self.operation_nsprefix_ = None
        self.mask = _cast(None, mask)
        self.mask_nsprefix_ = None
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
        self.var_check = _cast(None, var_check)
        self.var_check_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityStateFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityStateFieldType.subclass:
            return EntityStateFieldType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_entity_check(self):
        return self.entity_check
    def set_entity_check(self, entity_check):
        self.entity_check = entity_check
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def get_operation(self):
        return self.operation
    def set_operation(self, operation):
        self.operation = operation
    def get_mask(self):
        return self.mask
    def set_mask(self, mask):
        self.mask = mask
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def get_var_check(self):
        return self.var_check
    def set_var_check(self, var_check):
        self.var_check = var_check
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_nameType48(self, value):
        # Validate type nameType48, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_nameType48_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nameType48_patterns_, ))
    validate_nameType48_patterns_ = [['^([^A-Z]+)$']]
    def validate_CheckEnumeration(self, value):
        # Validate type oval:CheckEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['all', 'at least one', 'none exist', 'none satisfy', 'only one']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CheckEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DatatypeEnumeration(self, value):
        # Validate type oval:DatatypeEnumeration, a restriction on None.
        pass
    def validate_OperationEnumeration(self, value):
        # Validate type oval:OperationEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['equals', 'not equal', 'case insensitive equals', 'case insensitive not equal', 'greater than', 'less than', 'greater than or equal', 'less than or equal', 'bitwise and', 'bitwise or', 'pattern match', 'subset of', 'superset of']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperationEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_VariableIDPattern(self, value):
        # Validate type oval:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateFieldType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntityStateFieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntityStateFieldType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntityStateFieldType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='EntityStateFieldType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.entity_check != "all" and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.datatype != "string" and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.operation != "equals" and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
        if self.mask != "false" and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(' mask=%s' % (quote_attrib(self.mask), ))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='EntityStateFieldType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_nameType48(self.name)    # validate type nameType48
        value = find_attr_value_('entity_check', node)
        if value is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            self.entity_check = value
            self.validate_CheckEnumeration(self.entity_check)    # validate type CheckEnumeration
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_DatatypeEnumeration(self.datatype)    # validate type DatatypeEnumeration
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
            self.validate_OperationEnumeration(self.operation)    # validate type OperationEnumeration
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            self.mask = value
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
        value = find_attr_value_('var_check', node)
        if value is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            self.var_check = value
            self.validate_CheckEnumeration(self.var_check)    # validate type CheckEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EntityStateFieldType


class ElementMapType(GeneratedsSuper):
    """test -- The local name of an OVAL test.
    object -- The local name of an OVAL object.
    state -- The local name of an OVAL state.
    item -- The local name of an OVAL item.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, test=None, object=None, state=None, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.test = test
        self.test_nsprefix_ = "oval"
        self.object = object
        self.object_nsprefix_ = "oval"
        self.state = state
        self.state_nsprefix_ = "oval"
        self.item = item
        self.item_nsprefix_ = "oval"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementMapType.subclass:
            return ElementMapType.subclass(*args_, **kwargs_)
        else:
            return ElementMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_test(self):
        return self.test
    def set_test(self, test):
        self.test = test
    def get_object(self):
        return self.object
    def set_object(self, object):
        self.object = object
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def has__content(self):
        if (
            self.test is not None or
            self.object is not None or
            self.state is not None or
            self.item is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='ElementMapType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ElementMapType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElementMapType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ElementMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval:', name_='ElementMapType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='ElementMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.test is not None:
            namespaceprefix_ = self.test_nsprefix_ + ':' if (UseCapturedNS_ and self.test_nsprefix_) else ''
            self.test.export(outfile, level, namespaceprefix_, namespacedef_='', name_='test', pretty_print=pretty_print)
        if self.object is not None:
            namespaceprefix_ = self.object_nsprefix_ + ':' if (UseCapturedNS_ and self.object_nsprefix_) else ''
            self.object.export(outfile, level, namespaceprefix_, namespacedef_='', name_='object', pretty_print=pretty_print)
        if self.state is not None:
            namespaceprefix_ = self.state_nsprefix_ + ':' if (UseCapturedNS_ and self.state_nsprefix_) else ''
            self.state.export(outfile, level, namespaceprefix_, namespacedef_='', name_='state', pretty_print=pretty_print)
        if self.item is not None:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            self.item.export(outfile, level, namespaceprefix_, namespacedef_='', name_='item', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'test':
            obj_ = ElementMapItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test = obj_
            obj_.original_tagname_ = 'test'
        elif nodeName_ == 'object':
            obj_ = ElementMapItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.object = obj_
            obj_.original_tagname_ = 'object'
        elif nodeName_ == 'state':
            obj_ = ElementMapItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.state = obj_
            obj_.original_tagname_ = 'state'
        elif nodeName_ == 'item':
            obj_ = ElementMapItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item = obj_
            obj_.original_tagname_ = 'item'
# end class ElementMapType


class ElementMapItemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target_namespace=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target_namespace = _cast(None, target_namespace)
        self.target_namespace_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementMapItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementMapItemType.subclass:
            return ElementMapItemType.subclass(*args_, **kwargs_)
        else:
            return ElementMapItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target_namespace(self):
        return self.target_namespace
    def set_target_namespace(self, target_namespace):
        self.target_namespace = target_namespace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='ElementMapItemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementMapItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ElementMapItemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElementMapItemType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval:', name_='ElementMapItemType'):
        if self.target_namespace is not None and 'target_namespace' not in already_processed:
            already_processed.add('target_namespace')
            outfile.write(' target_namespace=%s' % (quote_attrib(self.target_namespace), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='ElementMapItemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target_namespace', node)
        if value is not None and 'target_namespace' not in already_processed:
            already_processed.add('target_namespace')
            self.target_namespace = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ElementMapItemType


class DeprecatedInfoType(GeneratedsSuper):
    """version -- The required version child element details the version of OVAL in which the construct became deprecated.
    reason -- The required reason child element is used to provide an explanation as to why an item was deprecated and to direct a reader to possible alternative structures within OVAL.
    comment -- The optional comment child element is used to supply additional information regarding the element's deprecated status.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, version=None, reason=None, comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.version = version
        self.validate_versionType49(self.version)
        self.version_nsprefix_ = None
        self.reason = reason
        self.reason_nsprefix_ = None
        self.comment = comment
        self.comment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeprecatedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeprecatedInfoType.subclass:
            return DeprecatedInfoType.subclass(*args_, **kwargs_)
        else:
            return DeprecatedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_reason(self):
        return self.reason
    def set_reason(self, reason):
        self.reason = reason
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    def validate_versionType49(self, value):
        result = True
        # Validate type versionType49, a restriction on oval:SchemaVersionPattern.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_versionType49_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versionType49_patterns_, ))
                result = False
        return result
    validate_versionType49_patterns_ = [['^([0-9]+\\.[0-9]+(\\.[0-9]+)?(:[0-9]+\\.[0-9]+(\\.[0-9]+)?)?)$']]
    def has__content(self):
        if (
            self.version is not None or
            self.reason is not None or
            self.comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='DeprecatedInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeprecatedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeprecatedInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeprecatedInfoType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeprecatedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval:', name_='DeprecatedInfoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='DeprecatedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.reason is not None:
            namespaceprefix_ = self.reason_nsprefix_ + ':' if (UseCapturedNS_ and self.reason_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreason>%s</%sreason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reason), input_name='reason')), namespaceprefix_ , eol_))
        if self.comment is not None:
            namespaceprefix_ = self.comment_nsprefix_ + ':' if (UseCapturedNS_ and self.comment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.comment), input_name='comment')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
            # validate type versionType49
            self.validate_versionType49(self.version)
        elif nodeName_ == 'reason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reason')
            value_ = self.gds_validate_string(value_, node, 'reason')
            self.reason = value_
            self.reason_nsprefix_ = child_.prefix
        elif nodeName_ == 'comment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'comment')
            value_ = self.gds_validate_string(value_, node, 'comment')
            self.comment = value_
            self.comment_nsprefix_ = child_.prefix
# end class DeprecatedInfoType


class GeneratorType(GeneratedsSuper):
    """product_name -- The optional product_name specifies the name of the application used to generate the file. Product names SHOULD be expressed as CPE Names according to the Common Platform Enumeration: Name Matching Specification Version 2.3.
    product_version -- The optional product_version specifies the version of the application used to generate the file.
    schema_version -- The required schema_version specifies the version of the OVAL Schema that the document has been written in and that should be used for validation. The versions for both the Core and any platform extensions used should be declared in separate schema_version elements.
    timestamp -- The required timestamp specifies when the particular OVAL document was compiled. The format for the timestamp is yyyy-mm-ddThh:mm:ss. Note that the timestamp element does not specify when a definition (or set of definitions) was created or modified but rather when the actual XML document that contains the definition was created. For example, the document might have pulled a bunch of existing OVAL Definitions together, each of the definitions having been created at some point in the past. The timestamp in this case would be when the combined document was created.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, product_name=None, product_version=None, schema_version=None, timestamp=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.product_name = product_name
        self.product_name_nsprefix_ = None
        self.product_version = product_version
        self.product_version_nsprefix_ = None
        if schema_version is None:
            self.schema_version = []
        else:
            self.schema_version = schema_version
        self.schema_version_nsprefix_ = "oval"
        self.timestamp = timestamp
        self.timestamp_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneratorType.subclass:
            return GeneratorType.subclass(*args_, **kwargs_)
        else:
            return GeneratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_product_name(self):
        return self.product_name
    def set_product_name(self, product_name):
        self.product_name = product_name
    def get_product_version(self):
        return self.product_version
    def set_product_version(self, product_version):
        self.product_version = product_version
    def get_schema_version(self):
        return self.schema_version
    def set_schema_version(self, schema_version):
        self.schema_version = schema_version
    def add_schema_version(self, value):
        self.schema_version.append(value)
    def insert_schema_version_at(self, index, value):
        self.schema_version.insert(index, value)
    def replace_schema_version_at(self, index, value):
        self.schema_version[index] = value
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.product_name is not None or
            self.product_version is not None or
            self.schema_version or
            self.timestamp is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='GeneratorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneratorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneratorType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneratorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval:', name_='GeneratorType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval="http://oval.mitre.org/XMLSchema/oval-definitions-5" ', name_='GeneratorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.product_name is not None:
            namespaceprefix_ = self.product_name_nsprefix_ + ':' if (UseCapturedNS_ and self.product_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_name>%s</%sproduct_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_name), input_name='product_name')), namespaceprefix_ , eol_))
        if self.product_version is not None:
            namespaceprefix_ = self.product_version_nsprefix_ + ':' if (UseCapturedNS_ and self.product_version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_version>%s</%sproduct_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_version), input_name='product_version')), namespaceprefix_ , eol_))
        for schema_version_ in self.schema_version:
            namespaceprefix_ = self.schema_version_nsprefix_ + ':' if (UseCapturedNS_ and self.schema_version_nsprefix_) else ''
            schema_version_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='schema_version', pretty_print=pretty_print)
        if self.timestamp is not None:
            namespaceprefix_ = self.timestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.timestamp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimestamp>%s</%stimestamp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timestamp), input_name='timestamp')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'product_name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product_name')
            value_ = self.gds_validate_string(value_, node, 'product_name')
            self.product_name = value_
            self.product_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'product_version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product_version')
            value_ = self.gds_validate_string(value_, node, 'product_version')
            self.product_version = value_
            self.product_version_nsprefix_ = child_.prefix
        elif nodeName_ == 'schema_version':
            obj_ = SchemaVersionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.schema_version.append(obj_)
            obj_.original_tagname_ = 'schema_version'
        elif nodeName_ == 'timestamp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'timestamp')
            value_ = self.gds_validate_string(value_, node, 'timestamp')
            self.timestamp = value_
            self.timestamp_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'GeneratorType')
            self.anytypeobjs_.append(content_)
# end class GeneratorType


class SchemaVersionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, platform=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.platform = _cast(None, platform)
        self.platform_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchemaVersionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchemaVersionType.subclass:
            return SchemaVersionType.subclass(*args_, **kwargs_)
        else:
            return SchemaVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_platform(self):
        return self.platform
    def set_platform(self, platform):
        self.platform = platform
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SchemaVersionPattern(self, value):
        result = True
        # Validate type SchemaVersionPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_SchemaVersionPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SchemaVersionPattern_patterns_, ))
                result = False
        return result
    validate_SchemaVersionPattern_patterns_ = [['^([0-9]+\\.[0-9]+(\\.[0-9]+)?(:[0-9]+\\.[0-9]+(\\.[0-9]+)?)?)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='SchemaVersionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SchemaVersionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SchemaVersionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SchemaVersionType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval:', name_='SchemaVersionType'):
        if self.platform is not None and 'platform' not in already_processed:
            already_processed.add('platform')
            outfile.write(' platform=%s' % (quote_attrib(self.platform), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='SchemaVersionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('platform', node)
        if value is not None and 'platform' not in already_processed:
            already_processed.add('platform')
            self.platform = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SchemaVersionType


class MessageType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, level='info', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.level = _cast(None, level)
        self.level_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageType.subclass:
            return MessageType.subclass(*args_, **kwargs_)
        else:
            return MessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_MessageLevelEnumeration(self, value):
        # Validate type oval:MessageLevelEnumeration, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['debug', 'error', 'fatal', 'info', 'warning']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MessageLevelEnumeration' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='MessageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MessageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval:', name_='MessageType'):
        if self.level != "info" and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='MessageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_MessageLevelEnumeration(self.level)    # validate type MessageLevelEnumeration
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MessageType


class NotesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, note=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotesType.subclass:
            return NotesType.subclass(*args_, **kwargs_)
        else:
            return NotesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def has__content(self):
        if (
            self.note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='NotesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NotesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NotesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NotesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NotesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval:', name_='NotesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"', name_='NotesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for note_ in self.note:
            namespaceprefix_ = self.note_nsprefix_ + ':' if (UseCapturedNS_ and self.note_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snote>%s</%snote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(note_), input_name='note')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'note':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'note')
            value_ = self.gds_validate_string(value_, node, 'note')
            self.note.append(value_)
            self.note_nsprefix_ = child_.prefix
# end class NotesType


class SignatureType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None, Object=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.SignedInfo = SignedInfo
        self.SignedInfo_nsprefix_ = "ds"
        self.SignatureValue = SignatureValue
        self.SignatureValue_nsprefix_ = "ds"
        self.KeyInfo = KeyInfo
        self.KeyInfo_nsprefix_ = "ds"
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
        self.Object_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SignedInfo(self):
        return self.SignedInfo
    def set_SignedInfo(self, SignedInfo):
        self.SignedInfo = SignedInfo
    def get_SignatureValue(self):
        return self.SignatureValue
    def set_SignatureValue(self, SignatureValue):
        self.SignatureValue = SignatureValue
    def get_KeyInfo(self):
        return self.KeyInfo
    def set_KeyInfo(self, KeyInfo):
        self.KeyInfo = KeyInfo
    def get_Object(self):
        return self.Object
    def set_Object(self, Object):
        self.Object = Object
    def add_Object(self, value):
        self.Object.append(value)
    def insert_Object_at(self, index, value):
        self.Object.insert(index, value)
    def replace_Object_at(self, index, value):
        self.Object[index] = value
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def has__content(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None or
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            namespaceprefix_ = self.SignedInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.SignedInfo_nsprefix_) else ''
            self.SignedInfo.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            namespaceprefix_ = self.SignatureValue_nsprefix_ + ':' if (UseCapturedNS_ and self.SignatureValue_nsprefix_) else ''
            self.SignatureValue.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            namespaceprefix_ = self.KeyInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.KeyInfo_nsprefix_) else ''
            self.KeyInfo.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='KeyInfo', pretty_print=pretty_print)
        for Object_ in self.Object:
            namespaceprefix_ = self.Object_nsprefix_ + ':' if (UseCapturedNS_ and self.Object_nsprefix_) else ''
            Object_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Object', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
        elif nodeName_ == 'Object':
            obj_ = ObjectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Object.append(obj_)
            obj_.original_tagname_ = 'Object'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"', name_='SignatureValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureValueType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"', name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.CanonicalizationMethod = CanonicalizationMethod
        self.CanonicalizationMethod_nsprefix_ = "ds"
        self.SignatureMethod = SignatureMethod
        self.SignatureMethod_nsprefix_ = "ds"
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CanonicalizationMethod(self):
        return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod):
        self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self):
        return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod):
        self.SignatureMethod = SignatureMethod
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def has__content(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignedInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignedInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignedInfoType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            namespaceprefix_ = self.CanonicalizationMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.CanonicalizationMethod_nsprefix_) else ''
            self.CanonicalizationMethod.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            namespaceprefix_ = self.SignatureMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.SignatureMethod_nsprefix_) else ''
            self.SignatureMethod.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignatureMethod', pretty_print=pretty_print)
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class CanonicalizationMethodType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='CanonicalizationMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CanonicalizationMethodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CanonicalizationMethodType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='CanonicalizationMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, HMACOutputLength=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        self.HMACOutputLength = HMACOutputLength
        self.validate_HMACOutputLengthType(self.HMACOutputLength)
        self.HMACOutputLength_nsprefix_ = "ds"
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HMACOutputLength(self):
        return self.HMACOutputLength
    def set_HMACOutputLength(self, HMACOutputLength):
        self.HMACOutputLength = HMACOutputLength
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HMACOutputLengthType(self, value):
        result = True
        # Validate type HMACOutputLengthType, a restriction on integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.HMACOutputLength is not None or
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SignatureMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureMethodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureMethodType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HMACOutputLength is not None:
            namespaceprefix_ = self.HMACOutputLength_nsprefix_ + ':' if (UseCapturedNS_ and self.HMACOutputLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHMACOutputLength>%s</%sHMACOutputLength>%s' % (namespaceprefix_ , self.gds_format_integer(self.HMACOutputLength, input_name='HMACOutputLength'), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HMACOutputLength' and child_.text is not None:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'HMACOutputLength')
            ival_ = self.gds_validate_integer(ival_, node, 'HMACOutputLength')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeInteger, 'HMACOutputLength', ival_)
            self.content_.append(obj_)
            self.HMACOutputLength_nsprefix_ = child_.prefix
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignatureMethodType


class ReferenceType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.URI = _cast(None, URI)
        self.URI_nsprefix_ = None
        self.Type = _cast(None, Type)
        self.Type_nsprefix_ = None
        self.Transforms = Transforms
        self.Transforms_nsprefix_ = "ds"
        self.DigestMethod = DigestMethod
        self.DigestMethod_nsprefix_ = "ds"
        self.DigestValue = DigestValue
        self.DigestValue_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType1.subclass:
            return ReferenceType1.subclass(*args_, **kwargs_)
        else:
            return ReferenceType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Transforms(self):
        return self.Transforms
    def set_Transforms(self, Transforms):
        self.Transforms = Transforms
    def get_DigestMethod(self):
        return self.DigestMethod
    def set_DigestMethod(self, DigestMethod):
        self.DigestMethod = DigestMethod
    def get_DigestValue(self):
        return self.DigestValue
    def set_DigestValue(self, DigestValue):
        self.DigestValue = DigestValue
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_URI(self):
        return self.URI
    def set_URI(self, URI):
        self.URI = URI
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def has__content(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='ReferenceType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ReferenceType1'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='ReferenceType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            namespaceprefix_ = self.Transforms_nsprefix_ + ':' if (UseCapturedNS_ and self.Transforms_nsprefix_) else ''
            self.Transforms.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            namespaceprefix_ = self.DigestMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.DigestMethod_nsprefix_) else ''
            self.DigestMethod.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            namespaceprefix_ = self.DigestValue_nsprefix_ + ':' if (UseCapturedNS_ and self.DigestValue_nsprefix_) else ''
            self.DigestValue.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='DigestValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            obj_ = DigestValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DigestValue = obj_
            obj_.original_tagname_ = 'DigestValue'
# end class ReferenceType1


class TransformsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Transform=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
        self.Transform_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Transform(self):
        return self.Transform
    def set_Transform(self, Transform):
        self.Transform = Transform
    def add_Transform(self, value):
        self.Transform.append(value)
    def insert_Transform_at(self, index, value):
        self.Transform.insert(index, value)
    def replace_Transform_at(self, index, value):
        self.Transform[index] = value
    def has__content(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='TransformsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransformsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            namespaceprefix_ = self.Transform_nsprefix_ + ':' if (UseCapturedNS_ and self.Transform_nsprefix_) else ''
            Transform_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Transform', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, XPath=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
        self.XPath_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_XPath(self):
        return self.XPath
    def set_XPath(self, XPath):
        self.XPath = XPath
    def add_XPath(self, value):
        self.XPath.append(value)
    def insert_XPath_at(self, index, value):
        self.XPath.insert(index, value)
    def replace_XPath_at(self, index, value):
        self.XPath[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None or
            self.XPath or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='TransformType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransformType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='TransformType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            namespaceprefix_ = self.XPath_nsprefix_ + ':' if (UseCapturedNS_ and self.XPath_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sXPath>%s</%sXPath>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(XPath_), input_name='XPath')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        elif nodeName_ == 'XPath' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'XPath')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'XPath')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'XPath', valuestr_)
            self.content_.append(obj_)
            self.XPath_nsprefix_ = child_.prefix
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TransformType


class DigestMethodType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='DigestMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DigestMethodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DigestMethodType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='DigestMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class DigestMethodType


class KeyInfoType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, KeyName=None, KeyValue=None, RetrievalMethod=None, X509Data=None, PGPData=None, SPKIData=None, MgmtData=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        if KeyName is None:
            self.KeyName = []
        else:
            self.KeyName = KeyName
        self.KeyName_nsprefix_ = "ds"
        if KeyValue is None:
            self.KeyValue = []
        else:
            self.KeyValue = KeyValue
        self.KeyValue_nsprefix_ = "ds"
        if RetrievalMethod is None:
            self.RetrievalMethod = []
        else:
            self.RetrievalMethod = RetrievalMethod
        self.RetrievalMethod_nsprefix_ = "ds"
        if X509Data is None:
            self.X509Data = []
        else:
            self.X509Data = X509Data
        self.X509Data_nsprefix_ = "ds"
        if PGPData is None:
            self.PGPData = []
        else:
            self.PGPData = PGPData
        self.PGPData_nsprefix_ = "ds"
        if SPKIData is None:
            self.SPKIData = []
        else:
            self.SPKIData = SPKIData
        self.SPKIData_nsprefix_ = "ds"
        if MgmtData is None:
            self.MgmtData = []
        else:
            self.MgmtData = MgmtData
        self.MgmtData_nsprefix_ = "ds"
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_KeyName(self):
        return self.KeyName
    def set_KeyName(self, KeyName):
        self.KeyName = KeyName
    def add_KeyName(self, value):
        self.KeyName.append(value)
    def insert_KeyName_at(self, index, value):
        self.KeyName.insert(index, value)
    def replace_KeyName_at(self, index, value):
        self.KeyName[index] = value
    def get_KeyValue(self):
        return self.KeyValue
    def set_KeyValue(self, KeyValue):
        self.KeyValue = KeyValue
    def add_KeyValue(self, value):
        self.KeyValue.append(value)
    def insert_KeyValue_at(self, index, value):
        self.KeyValue.insert(index, value)
    def replace_KeyValue_at(self, index, value):
        self.KeyValue[index] = value
    def get_RetrievalMethod(self):
        return self.RetrievalMethod
    def set_RetrievalMethod(self, RetrievalMethod):
        self.RetrievalMethod = RetrievalMethod
    def add_RetrievalMethod(self, value):
        self.RetrievalMethod.append(value)
    def insert_RetrievalMethod_at(self, index, value):
        self.RetrievalMethod.insert(index, value)
    def replace_RetrievalMethod_at(self, index, value):
        self.RetrievalMethod[index] = value
    def get_X509Data(self):
        return self.X509Data
    def set_X509Data(self, X509Data):
        self.X509Data = X509Data
    def add_X509Data(self, value):
        self.X509Data.append(value)
    def insert_X509Data_at(self, index, value):
        self.X509Data.insert(index, value)
    def replace_X509Data_at(self, index, value):
        self.X509Data[index] = value
    def get_PGPData(self):
        return self.PGPData
    def set_PGPData(self, PGPData):
        self.PGPData = PGPData
    def add_PGPData(self, value):
        self.PGPData.append(value)
    def insert_PGPData_at(self, index, value):
        self.PGPData.insert(index, value)
    def replace_PGPData_at(self, index, value):
        self.PGPData[index] = value
    def get_SPKIData(self):
        return self.SPKIData
    def set_SPKIData(self, SPKIData):
        self.SPKIData = SPKIData
    def add_SPKIData(self, value):
        self.SPKIData.append(value)
    def insert_SPKIData_at(self, index, value):
        self.SPKIData.insert(index, value)
    def replace_SPKIData_at(self, index, value):
        self.SPKIData[index] = value
    def get_MgmtData(self):
        return self.MgmtData
    def set_MgmtData(self, MgmtData):
        self.MgmtData = MgmtData
    def add_MgmtData(self, value):
        self.MgmtData.append(value)
    def insert_MgmtData_at(self, index, value):
        self.MgmtData.insert(index, value)
    def replace_MgmtData_at(self, index, value):
        self.MgmtData[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.KeyName or
            self.KeyValue or
            self.RetrievalMethod or
            self.X509Data or
            self.PGPData or
            self.SPKIData or
            self.MgmtData or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='KeyInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KeyInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyInfoType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for KeyName_ in self.KeyName:
            namespaceprefix_ = self.KeyName_nsprefix_ + ':' if (UseCapturedNS_ and self.KeyName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyName>%s</%sKeyName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(KeyName_), input_name='KeyName')), namespaceprefix_ , eol_))
        for KeyValue_ in self.KeyValue:
            namespaceprefix_ = self.KeyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.KeyValue_nsprefix_) else ''
            KeyValue_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='KeyValue', pretty_print=pretty_print)
        for RetrievalMethod_ in self.RetrievalMethod:
            namespaceprefix_ = self.RetrievalMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.RetrievalMethod_nsprefix_) else ''
            RetrievalMethod_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='RetrievalMethod', pretty_print=pretty_print)
        for X509Data_ in self.X509Data:
            namespaceprefix_ = self.X509Data_nsprefix_ + ':' if (UseCapturedNS_ and self.X509Data_nsprefix_) else ''
            X509Data_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='X509Data', pretty_print=pretty_print)
        for PGPData_ in self.PGPData:
            namespaceprefix_ = self.PGPData_nsprefix_ + ':' if (UseCapturedNS_ and self.PGPData_nsprefix_) else ''
            PGPData_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='PGPData', pretty_print=pretty_print)
        for SPKIData_ in self.SPKIData:
            namespaceprefix_ = self.SPKIData_nsprefix_ + ':' if (UseCapturedNS_ and self.SPKIData_nsprefix_) else ''
            SPKIData_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SPKIData', pretty_print=pretty_print)
        for MgmtData_ in self.MgmtData:
            namespaceprefix_ = self.MgmtData_nsprefix_ + ':' if (UseCapturedNS_ and self.MgmtData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMgmtData>%s</%sMgmtData>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(MgmtData_), input_name='MgmtData')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'KeyName' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'KeyName')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'KeyName')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'KeyName', valuestr_)
            self.content_.append(obj_)
            self.KeyName_nsprefix_ = child_.prefix
        elif nodeName_ == 'KeyValue':
            obj_ = KeyValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'KeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_KeyValue'):
              self.add_KeyValue(obj_.value)
            elif hasattr(self, 'set_KeyValue'):
              self.set_KeyValue(obj_.value)
        elif nodeName_ == 'RetrievalMethod':
            obj_ = RetrievalMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RetrievalMethod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_RetrievalMethod'):
              self.add_RetrievalMethod(obj_.value)
            elif hasattr(self, 'set_RetrievalMethod'):
              self.set_RetrievalMethod(obj_.value)
        elif nodeName_ == 'X509Data':
            obj_ = X509DataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'X509Data', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_X509Data'):
              self.add_X509Data(obj_.value)
            elif hasattr(self, 'set_X509Data'):
              self.set_X509Data(obj_.value)
        elif nodeName_ == 'PGPData':
            obj_ = PGPDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'PGPData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_PGPData'):
              self.add_PGPData(obj_.value)
            elif hasattr(self, 'set_PGPData'):
              self.set_PGPData(obj_.value)
        elif nodeName_ == 'SPKIData':
            obj_ = SPKIDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'SPKIData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_SPKIData'):
              self.add_SPKIData(obj_.value)
            elif hasattr(self, 'set_SPKIData'):
              self.set_SPKIData(obj_.value)
        elif nodeName_ == 'MgmtData' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'MgmtData')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'MgmtData')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'MgmtData', valuestr_)
            self.content_.append(obj_)
            self.MgmtData_nsprefix_ = child_.prefix
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyInfoType


class KeyValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DSAKeyValue=None, RSAKeyValue=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DSAKeyValue = DSAKeyValue
        self.DSAKeyValue_nsprefix_ = "ds"
        self.RSAKeyValue = RSAKeyValue
        self.RSAKeyValue_nsprefix_ = "ds"
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyValueType.subclass:
            return KeyValueType.subclass(*args_, **kwargs_)
        else:
            return KeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DSAKeyValue(self):
        return self.DSAKeyValue
    def set_DSAKeyValue(self, DSAKeyValue):
        self.DSAKeyValue = DSAKeyValue
    def get_RSAKeyValue(self):
        return self.RSAKeyValue
    def set_RSAKeyValue(self, RSAKeyValue):
        self.RSAKeyValue = RSAKeyValue
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.DSAKeyValue is not None or
            self.RSAKeyValue is not None or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='KeyValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KeyValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyValueType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='KeyValueType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='KeyValueType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DSAKeyValue is not None:
            namespaceprefix_ = self.DSAKeyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.DSAKeyValue_nsprefix_) else ''
            self.DSAKeyValue.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='DSAKeyValue', pretty_print=pretty_print)
        if self.RSAKeyValue is not None:
            namespaceprefix_ = self.RSAKeyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.RSAKeyValue_nsprefix_) else ''
            self.RSAKeyValue.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='RSAKeyValue', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DSAKeyValue':
            obj_ = DSAKeyValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'DSAKeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_DSAKeyValue'):
              self.add_DSAKeyValue(obj_.value)
            elif hasattr(self, 'set_DSAKeyValue'):
              self.set_DSAKeyValue(obj_.value)
        elif nodeName_ == 'RSAKeyValue':
            obj_ = RSAKeyValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RSAKeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_RSAKeyValue'):
              self.add_RSAKeyValue(obj_.value)
            elif hasattr(self, 'set_RSAKeyValue'):
              self.set_RSAKeyValue(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyValueType


class RetrievalMethodType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, URI=None, Type=None, Transforms=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.URI = _cast(None, URI)
        self.URI_nsprefix_ = None
        self.Type = _cast(None, Type)
        self.Type_nsprefix_ = None
        self.Transforms = Transforms
        self.Transforms_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetrievalMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetrievalMethodType.subclass:
            return RetrievalMethodType.subclass(*args_, **kwargs_)
        else:
            return RetrievalMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Transforms(self):
        return self.Transforms
    def set_Transforms(self, Transforms):
        self.Transforms = Transforms
    def get_URI(self):
        return self.URI
    def set_URI(self, URI):
        self.URI = URI
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def has__content(self):
        if (
            self.Transforms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='RetrievalMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RetrievalMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RetrievalMethodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RetrievalMethodType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RetrievalMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='RetrievalMethodType'):
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='RetrievalMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            namespaceprefix_ = self.Transforms_nsprefix_ + ':' if (UseCapturedNS_ and self.Transforms_nsprefix_) else ''
            self.Transforms.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Transforms', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
# end class RetrievalMethodType


class X509DataType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, X509IssuerSerial=None, X509SKI=None, X509SubjectName=None, X509Certificate=None, X509CRL=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if X509IssuerSerial is None:
            self.X509IssuerSerial = []
        else:
            self.X509IssuerSerial = X509IssuerSerial
        self.X509IssuerSerial_nsprefix_ = "ds"
        if X509SKI is None:
            self.X509SKI = []
        else:
            self.X509SKI = X509SKI
        self.X509SKI_nsprefix_ = None
        if X509SubjectName is None:
            self.X509SubjectName = []
        else:
            self.X509SubjectName = X509SubjectName
        self.X509SubjectName_nsprefix_ = None
        if X509Certificate is None:
            self.X509Certificate = []
        else:
            self.X509Certificate = X509Certificate
        self.X509Certificate_nsprefix_ = None
        if X509CRL is None:
            self.X509CRL = []
        else:
            self.X509CRL = X509CRL
        self.X509CRL_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X509IssuerSerial(self):
        return self.X509IssuerSerial
    def set_X509IssuerSerial(self, X509IssuerSerial):
        self.X509IssuerSerial = X509IssuerSerial
    def add_X509IssuerSerial(self, value):
        self.X509IssuerSerial.append(value)
    def insert_X509IssuerSerial_at(self, index, value):
        self.X509IssuerSerial.insert(index, value)
    def replace_X509IssuerSerial_at(self, index, value):
        self.X509IssuerSerial[index] = value
    def get_X509SKI(self):
        return self.X509SKI
    def set_X509SKI(self, X509SKI):
        self.X509SKI = X509SKI
    def add_X509SKI(self, value):
        self.X509SKI.append(value)
    def insert_X509SKI_at(self, index, value):
        self.X509SKI.insert(index, value)
    def replace_X509SKI_at(self, index, value):
        self.X509SKI[index] = value
    def get_X509SubjectName(self):
        return self.X509SubjectName
    def set_X509SubjectName(self, X509SubjectName):
        self.X509SubjectName = X509SubjectName
    def add_X509SubjectName(self, value):
        self.X509SubjectName.append(value)
    def insert_X509SubjectName_at(self, index, value):
        self.X509SubjectName.insert(index, value)
    def replace_X509SubjectName_at(self, index, value):
        self.X509SubjectName[index] = value
    def get_X509Certificate(self):
        return self.X509Certificate
    def set_X509Certificate(self, X509Certificate):
        self.X509Certificate = X509Certificate
    def add_X509Certificate(self, value):
        self.X509Certificate.append(value)
    def insert_X509Certificate_at(self, index, value):
        self.X509Certificate.insert(index, value)
    def replace_X509Certificate_at(self, index, value):
        self.X509Certificate[index] = value
    def get_X509CRL(self):
        return self.X509CRL
    def set_X509CRL(self, X509CRL):
        self.X509CRL = X509CRL
    def add_X509CRL(self, value):
        self.X509CRL.append(value)
    def insert_X509CRL_at(self, index, value):
        self.X509CRL.insert(index, value)
    def replace_X509CRL_at(self, index, value):
        self.X509CRL[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def has__content(self):
        if (
            self.X509IssuerSerial or
            self.X509SKI or
            self.X509SubjectName or
            self.X509Certificate or
            self.X509CRL or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='X509DataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'X509DataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509DataType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='X509DataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for X509IssuerSerial_ in self.X509IssuerSerial:
            namespaceprefix_ = self.X509IssuerSerial_nsprefix_ + ':' if (UseCapturedNS_ and self.X509IssuerSerial_nsprefix_) else ''
            X509IssuerSerial_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X509IssuerSerial', pretty_print=pretty_print)
        for X509SKI_ in self.X509SKI:
            namespaceprefix_ = self.X509SKI_nsprefix_ + ':' if (UseCapturedNS_ and self.X509SKI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SKI>%s</%sX509SKI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(X509SKI_), input_name='X509SKI')), namespaceprefix_ , eol_))
        for X509SubjectName_ in self.X509SubjectName:
            namespaceprefix_ = self.X509SubjectName_nsprefix_ + ':' if (UseCapturedNS_ and self.X509SubjectName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SubjectName>%s</%sX509SubjectName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(X509SubjectName_), input_name='X509SubjectName')), namespaceprefix_ , eol_))
        for X509Certificate_ in self.X509Certificate:
            namespaceprefix_ = self.X509Certificate_nsprefix_ + ':' if (UseCapturedNS_ and self.X509Certificate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509Certificate>%s</%sX509Certificate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(X509Certificate_), input_name='X509Certificate')), namespaceprefix_ , eol_))
        for X509CRL_ in self.X509CRL:
            namespaceprefix_ = self.X509CRL_nsprefix_ + ':' if (UseCapturedNS_ and self.X509CRL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509CRL>%s</%sX509CRL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(X509CRL_), input_name='X509CRL')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X509IssuerSerial':
            obj_ = X509IssuerSerialType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X509IssuerSerial.append(obj_)
            obj_.original_tagname_ = 'X509IssuerSerial'
        elif nodeName_ == 'X509SKI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509SKI')
            value_ = self.gds_validate_string(value_, node, 'X509SKI')
            self.X509SKI.append(value_)
            self.X509SKI_nsprefix_ = child_.prefix
        elif nodeName_ == 'X509SubjectName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509SubjectName')
            value_ = self.gds_validate_string(value_, node, 'X509SubjectName')
            self.X509SubjectName.append(value_)
            self.X509SubjectName_nsprefix_ = child_.prefix
        elif nodeName_ == 'X509Certificate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509Certificate')
            value_ = self.gds_validate_string(value_, node, 'X509Certificate')
            self.X509Certificate.append(value_)
            self.X509Certificate_nsprefix_ = child_.prefix
        elif nodeName_ == 'X509CRL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509CRL')
            value_ = self.gds_validate_string(value_, node, 'X509CRL')
            self.X509CRL.append(value_)
            self.X509CRL_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'X509DataType')
            self.set_anytypeobjs_(content_)
# end class X509DataType


class X509IssuerSerialType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, X509IssuerName=None, X509SerialNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.X509IssuerName = X509IssuerName
        self.X509IssuerName_nsprefix_ = None
        self.X509SerialNumber = X509SerialNumber
        self.X509SerialNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509IssuerSerialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509IssuerSerialType.subclass:
            return X509IssuerSerialType.subclass(*args_, **kwargs_)
        else:
            return X509IssuerSerialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X509IssuerName(self):
        return self.X509IssuerName
    def set_X509IssuerName(self, X509IssuerName):
        self.X509IssuerName = X509IssuerName
    def get_X509SerialNumber(self):
        return self.X509SerialNumber
    def set_X509SerialNumber(self, X509SerialNumber):
        self.X509SerialNumber = X509SerialNumber
    def has__content(self):
        if (
            self.X509IssuerName is not None or
            self.X509SerialNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='X509IssuerSerialType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509IssuerSerialType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'X509IssuerSerialType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509IssuerSerialType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='X509IssuerSerialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='X509IssuerSerialType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='X509IssuerSerialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509IssuerName is not None:
            namespaceprefix_ = self.X509IssuerName_nsprefix_ + ':' if (UseCapturedNS_ and self.X509IssuerName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509IssuerName>%s</%sX509IssuerName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.X509IssuerName), input_name='X509IssuerName')), namespaceprefix_ , eol_))
        if self.X509SerialNumber is not None:
            namespaceprefix_ = self.X509SerialNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.X509SerialNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SerialNumber>%s</%sX509SerialNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.X509SerialNumber), input_name='X509SerialNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X509IssuerName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509IssuerName')
            value_ = self.gds_validate_string(value_, node, 'X509IssuerName')
            self.X509IssuerName = value_
            self.X509IssuerName_nsprefix_ = child_.prefix
        elif nodeName_ == 'X509SerialNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509SerialNumber')
            value_ = self.gds_validate_string(value_, node, 'X509SerialNumber')
            self.X509SerialNumber = value_
            self.X509SerialNumber_nsprefix_ = child_.prefix
# end class X509IssuerSerialType


class PGPDataType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PGPKeyID=None, PGPKeyPacket=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PGPKeyID = PGPKeyID
        self.PGPKeyID_nsprefix_ = None
        self.PGPKeyPacket = PGPKeyPacket
        self.PGPKeyPacket_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PGPDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PGPDataType.subclass:
            return PGPDataType.subclass(*args_, **kwargs_)
        else:
            return PGPDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PGPKeyID(self):
        return self.PGPKeyID
    def set_PGPKeyID(self, PGPKeyID):
        self.PGPKeyID = PGPKeyID
    def get_PGPKeyPacket(self):
        return self.PGPKeyPacket
    def set_PGPKeyPacket(self, PGPKeyPacket):
        self.PGPKeyPacket = PGPKeyPacket
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.PGPKeyID is not None or
            self.PGPKeyPacket is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='PGPDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PGPDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PGPDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PGPDataType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PGPDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='PGPDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='PGPDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PGPKeyID is not None:
            namespaceprefix_ = self.PGPKeyID_nsprefix_ + ':' if (UseCapturedNS_ and self.PGPKeyID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPGPKeyID>%s</%sPGPKeyID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyID), input_name='PGPKeyID')), namespaceprefix_ , eol_))
        if self.PGPKeyPacket is not None:
            namespaceprefix_ = self.PGPKeyPacket_nsprefix_ + ':' if (UseCapturedNS_ and self.PGPKeyPacket_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPGPKeyPacket>%s</%sPGPKeyPacket>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyPacket), input_name='PGPKeyPacket')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PGPKeyID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PGPKeyID')
            value_ = self.gds_validate_string(value_, node, 'PGPKeyID')
            self.PGPKeyID = value_
            self.PGPKeyID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PGPKeyPacket':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PGPKeyPacket')
            value_ = self.gds_validate_string(value_, node, 'PGPKeyPacket')
            self.PGPKeyPacket = value_
            self.PGPKeyPacket_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'PGPDataType')
            self.anytypeobjs_.append(content_)
# end class PGPDataType


class SPKIDataType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SPKISexp=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SPKISexp is None:
            self.SPKISexp = []
        else:
            self.SPKISexp = SPKISexp
        self.SPKISexp_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPKIDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPKIDataType.subclass:
            return SPKIDataType.subclass(*args_, **kwargs_)
        else:
            return SPKIDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SPKISexp(self):
        return self.SPKISexp
    def set_SPKISexp(self, SPKISexp):
        self.SPKISexp = SPKISexp
    def add_SPKISexp(self, value):
        self.SPKISexp.append(value)
    def insert_SPKISexp_at(self, index, value):
        self.SPKISexp.insert(index, value)
    def replace_SPKISexp_at(self, index, value):
        self.SPKISexp[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def has__content(self):
        if (
            self.SPKISexp or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SPKIDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SPKIDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SPKIDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SPKIDataType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SPKIDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SPKIDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SPKIDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SPKISexp_ in self.SPKISexp:
            namespaceprefix_ = self.SPKISexp_nsprefix_ + ':' if (UseCapturedNS_ and self.SPKISexp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPKISexp>%s</%sSPKISexp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(SPKISexp_), input_name='SPKISexp')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SPKISexp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SPKISexp')
            value_ = self.gds_validate_string(value_, node, 'SPKISexp')
            self.SPKISexp.append(value_)
            self.SPKISexp_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'SPKIDataType')
            self.set_anytypeobjs_(content_)
# end class SPKIDataType


class ObjectType2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, MimeType=None, Encoding=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.MimeType = _cast(None, MimeType)
        self.MimeType_nsprefix_ = None
        self.Encoding = _cast(None, Encoding)
        self.Encoding_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectType2.subclass:
            return ObjectType2.subclass(*args_, **kwargs_)
        else:
            return ObjectType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_MimeType(self):
        return self.MimeType
    def set_MimeType(self, MimeType):
        self.MimeType = MimeType
    def get_Encoding(self):
        return self.Encoding
    def set_Encoding(self, Encoding):
        self.Encoding = Encoding
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ObjectType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjectType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectType2')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ObjectType2'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.MimeType is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            outfile.write(' MimeType=%s' % (quote_attrib(self.MimeType), ))
        if self.Encoding is not None and 'Encoding' not in already_processed:
            already_processed.add('Encoding')
            outfile.write(' Encoding=%s' % (quote_attrib(self.Encoding), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ObjectType2', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('MimeType', node)
        if value is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            self.MimeType = value
        value = find_attr_value_('Encoding', node)
        if value is not None and 'Encoding' not in already_processed:
            already_processed.add('Encoding')
            self.Encoding = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ObjectType2


class ManifestType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManifestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManifestType.subclass:
            return ManifestType.subclass(*args_, **kwargs_)
        else:
            return ManifestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def has__content(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='ManifestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManifestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManifestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManifestType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManifestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ManifestType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='ManifestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ManifestType


class SignaturePropertiesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignatureProperty=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        if SignatureProperty is None:
            self.SignatureProperty = []
        else:
            self.SignatureProperty = SignatureProperty
        self.SignatureProperty_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignaturePropertiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignaturePropertiesType.subclass:
            return SignaturePropertiesType.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SignatureProperty(self):
        return self.SignatureProperty
    def set_SignatureProperty(self, SignatureProperty):
        self.SignatureProperty = SignatureProperty
    def add_SignatureProperty(self, value):
        self.SignatureProperty.append(value)
    def insert_SignatureProperty_at(self, index, value):
        self.SignatureProperty.insert(index, value)
    def replace_SignatureProperty_at(self, index, value):
        self.SignatureProperty[index] = value
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def has__content(self):
        if (
            self.SignatureProperty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignaturePropertiesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignaturePropertiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignaturePropertiesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignaturePropertiesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignaturePropertiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignaturePropertiesType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignaturePropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SignatureProperty_ in self.SignatureProperty:
            namespaceprefix_ = self.SignatureProperty_nsprefix_ + ':' if (UseCapturedNS_ and self.SignatureProperty_nsprefix_) else ''
            SignatureProperty_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignatureProperty', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SignatureProperty':
            obj_ = SignaturePropertyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignatureProperty.append(obj_)
            obj_.original_tagname_ = 'SignatureProperty'
# end class SignaturePropertiesType


class SignaturePropertyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Target=None, Id=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Target = _cast(None, Target)
        self.Target_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignaturePropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignaturePropertyType.subclass:
            return SignaturePropertyType.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Target(self):
        return self.Target
    def set_Target(self, Target):
        self.Target = Target
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SignaturePropertyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignaturePropertyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignaturePropertyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignaturePropertyType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignaturePropertyType'):
        if self.Target is not None and 'Target' not in already_processed:
            already_processed.add('Target')
            outfile.write(' Target=%s' % (quote_attrib(self.Target), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SignaturePropertyType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Target', node)
        if value is not None and 'Target' not in already_processed:
            already_processed.add('Target')
            self.Target = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignaturePropertyType


class DSAKeyValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, P=None, Q=None, G=None, Y=None, J=None, Seed=None, PgenCounter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.P = P
        self.validate_CryptoBinary(self.P)
        self.P_nsprefix_ = "ds"
        self.Q = Q
        self.validate_CryptoBinary(self.Q)
        self.Q_nsprefix_ = "ds"
        self.G = G
        self.validate_CryptoBinary(self.G)
        self.G_nsprefix_ = "ds"
        self.Y = Y
        self.validate_CryptoBinary(self.Y)
        self.Y_nsprefix_ = "ds"
        self.J = J
        self.validate_CryptoBinary(self.J)
        self.J_nsprefix_ = "ds"
        self.Seed = Seed
        self.validate_CryptoBinary(self.Seed)
        self.Seed_nsprefix_ = "ds"
        self.PgenCounter = PgenCounter
        self.validate_CryptoBinary(self.PgenCounter)
        self.PgenCounter_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DSAKeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DSAKeyValueType.subclass:
            return DSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return DSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_P(self):
        return self.P
    def set_P(self, P):
        self.P = P
    def get_Q(self):
        return self.Q
    def set_Q(self, Q):
        self.Q = Q
    def get_G(self):
        return self.G
    def set_G(self, G):
        self.G = G
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_J(self):
        return self.J
    def set_J(self, J):
        self.J = J
    def get_Seed(self):
        return self.Seed
    def set_Seed(self, Seed):
        self.Seed = Seed
    def get_PgenCounter(self):
        return self.PgenCounter
    def set_PgenCounter(self, PgenCounter):
        self.PgenCounter = PgenCounter
    def validate_CryptoBinary(self, value):
        result = True
        # Validate type CryptoBinary, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def has__content(self):
        if (
            self.P is not None or
            self.Q is not None or
            self.G is not None or
            self.Y is not None or
            self.J is not None or
            self.Seed is not None or
            self.PgenCounter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='DSAKeyValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DSAKeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DSAKeyValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DSAKeyValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DSAKeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='DSAKeyValueType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='DSAKeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.P is not None:
            namespaceprefix_ = self.P_nsprefix_ + ':' if (UseCapturedNS_ and self.P_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sP>%s</%sP>%s' % (namespaceprefix_ , self.gds_format_base64(self.P, input_name='P'), namespaceprefix_ , eol_))
        if self.Q is not None:
            namespaceprefix_ = self.Q_nsprefix_ + ':' if (UseCapturedNS_ and self.Q_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQ>%s</%sQ>%s' % (namespaceprefix_ , self.gds_format_base64(self.Q, input_name='Q'), namespaceprefix_ , eol_))
        if self.G is not None:
            namespaceprefix_ = self.G_nsprefix_ + ':' if (UseCapturedNS_ and self.G_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sG>%s</%sG>%s' % (namespaceprefix_ , self.gds_format_base64(self.G, input_name='G'), namespaceprefix_ , eol_))
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY>%s</%sY>%s' % (namespaceprefix_ , self.gds_format_base64(self.Y, input_name='Y'), namespaceprefix_ , eol_))
        if self.J is not None:
            namespaceprefix_ = self.J_nsprefix_ + ':' if (UseCapturedNS_ and self.J_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJ>%s</%sJ>%s' % (namespaceprefix_ , self.gds_format_base64(self.J, input_name='J'), namespaceprefix_ , eol_))
        if self.Seed is not None:
            namespaceprefix_ = self.Seed_nsprefix_ + ':' if (UseCapturedNS_ and self.Seed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeed>%s</%sSeed>%s' % (namespaceprefix_ , self.gds_format_base64(self.Seed, input_name='Seed'), namespaceprefix_ , eol_))
        if self.PgenCounter is not None:
            namespaceprefix_ = self.PgenCounter_nsprefix_ + ':' if (UseCapturedNS_ and self.PgenCounter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPgenCounter>%s</%sPgenCounter>%s' % (namespaceprefix_ , self.gds_format_base64(self.PgenCounter, input_name='PgenCounter'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'P':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'P')
            else:
                bval_ = None
            self.P = bval_
            self.P_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.P)
        elif nodeName_ == 'Q':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Q')
            else:
                bval_ = None
            self.Q = bval_
            self.Q_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Q)
        elif nodeName_ == 'G':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'G')
            else:
                bval_ = None
            self.G = bval_
            self.G_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.G)
        elif nodeName_ == 'Y':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Y')
            else:
                bval_ = None
            self.Y = bval_
            self.Y_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Y)
        elif nodeName_ == 'J':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'J')
            else:
                bval_ = None
            self.J = bval_
            self.J_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.J)
        elif nodeName_ == 'Seed':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Seed')
            else:
                bval_ = None
            self.Seed = bval_
            self.Seed_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Seed)
        elif nodeName_ == 'PgenCounter':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'PgenCounter')
            else:
                bval_ = None
            self.PgenCounter = bval_
            self.PgenCounter_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.PgenCounter)
# end class DSAKeyValueType


class RSAKeyValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Modulus=None, Exponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Modulus = Modulus
        self.validate_CryptoBinary(self.Modulus)
        self.Modulus_nsprefix_ = "ds"
        self.Exponent = Exponent
        self.validate_CryptoBinary(self.Exponent)
        self.Exponent_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RSAKeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RSAKeyValueType.subclass:
            return RSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return RSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Modulus(self):
        return self.Modulus
    def set_Modulus(self, Modulus):
        self.Modulus = Modulus
    def get_Exponent(self):
        return self.Exponent
    def set_Exponent(self, Exponent):
        self.Exponent = Exponent
    def validate_CryptoBinary(self, value):
        result = True
        # Validate type CryptoBinary, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def has__content(self):
        if (
            self.Modulus is not None or
            self.Exponent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='RSAKeyValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RSAKeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RSAKeyValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RSAKeyValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RSAKeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='RSAKeyValueType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='RSAKeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Modulus is not None:
            namespaceprefix_ = self.Modulus_nsprefix_ + ':' if (UseCapturedNS_ and self.Modulus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModulus>%s</%sModulus>%s' % (namespaceprefix_ , self.gds_format_base64(self.Modulus, input_name='Modulus'), namespaceprefix_ , eol_))
        if self.Exponent is not None:
            namespaceprefix_ = self.Exponent_nsprefix_ + ':' if (UseCapturedNS_ and self.Exponent_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExponent>%s</%sExponent>%s' % (namespaceprefix_ , self.gds_format_base64(self.Exponent, input_name='Exponent'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Modulus':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Modulus')
            else:
                bval_ = None
            self.Modulus = bval_
            self.Modulus_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Modulus)
        elif nodeName_ == 'Exponent':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Exponent')
            else:
                bval_ = None
            self.Exponent = bval_
            self.Exponent_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Exponent)
# end class RSAKeyValueType


class GeneratorType3(GeneratedsSuper):
    """product_name -- The optional product_name element specifies the name of the
    application used to generate the file.
    product_version -- The optional product_version element specifies the version of the
    application used to generate the file.
    schema_version -- The required schema_version element specifies the version of the
    schema that the document has been written against and that should be used for
    validation.
    timestamp -- The required timestamp element specifies when the particular
    document was compiled. The format for the timestamp is yyyy-mm-ddThh:mm:ss. Note that the
    timestamp element does not specify when an item in the document was created or modified but
    rather when the actual XML document that contains the items was created. For example, a document
    might pull a bunch of existing items together, each of which was created at some point in the
    past. The timestamp in this case would be when this combined document was
    created.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, product_name=None, product_version=None, schema_version=None, timestamp=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.product_name = product_name
        self.product_name_nsprefix_ = None
        self.product_version = product_version
        self.product_version_nsprefix_ = None
        self.schema_version = schema_version
        self.schema_version_nsprefix_ = None
        self.timestamp = timestamp
        self.timestamp_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneratorType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneratorType3.subclass:
            return GeneratorType3.subclass(*args_, **kwargs_)
        else:
            return GeneratorType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_product_name(self):
        return self.product_name
    def set_product_name(self, product_name):
        self.product_name = product_name
    def get_product_version(self):
        return self.product_version
    def set_product_version(self, product_version):
        self.product_version = product_version
    def get_schema_version(self):
        return self.schema_version
    def set_schema_version(self, schema_version):
        self.schema_version = schema_version
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.product_name is not None or
            self.product_version is not None or
            self.schema_version is not None or
            self.timestamp is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='GeneratorType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneratorType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneratorType3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneratorType3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneratorType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe_dict:', name_='GeneratorType3'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='GeneratorType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.product_name is not None:
            namespaceprefix_ = self.product_name_nsprefix_ + ':' if (UseCapturedNS_ and self.product_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_name>%s</%sproduct_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_name), input_name='product_name')), namespaceprefix_ , eol_))
        if self.product_version is not None:
            namespaceprefix_ = self.product_version_nsprefix_ + ':' if (UseCapturedNS_ and self.product_version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_version>%s</%sproduct_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_version), input_name='product_version')), namespaceprefix_ , eol_))
        if self.schema_version is not None:
            namespaceprefix_ = self.schema_version_nsprefix_ + ':' if (UseCapturedNS_ and self.schema_version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sschema_version>%s</%sschema_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.schema_version), input_name='schema_version')), namespaceprefix_ , eol_))
        if self.timestamp is not None:
            namespaceprefix_ = self.timestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.timestamp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimestamp>%s</%stimestamp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timestamp), input_name='timestamp')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'product_name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product_name')
            value_ = self.gds_validate_string(value_, node, 'product_name')
            self.product_name = value_
            self.product_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'product_version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product_version')
            value_ = self.gds_validate_string(value_, node, 'product_version')
            self.product_version = value_
            self.product_version_nsprefix_ = child_.prefix
        elif nodeName_ == 'schema_version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'schema_version')
            value_ = self.gds_validate_string(value_, node, 'schema_version')
            self.schema_version = value_
            self.schema_version_nsprefix_ = child_.prefix
        elif nodeName_ == 'timestamp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'timestamp')
            value_ = self.gds_validate_string(value_, node, 'timestamp')
            self.timestamp = value_
            self.timestamp_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'GeneratorType3')
            self.anytypeobjs_.append(content_)
# end class GeneratorType3


class ItemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, deprecated='false', deprecated_by=None, deprecation_date=None, title=None, notes=None, references=None, check=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.deprecated = _cast(None, deprecated)
        self.deprecated_nsprefix_ = None
        self.deprecated_by = _cast(None, deprecated_by)
        self.deprecated_by_nsprefix_ = None
        self.deprecation_date = _cast(None, deprecation_date)
        self.deprecation_date_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = "cpe_dict"
        if notes is None:
            self.notes = []
        else:
            self.notes = notes
        self.notes_nsprefix_ = "cpe_dict"
        self.references = references
        self.references_nsprefix_ = "cpe_dict"
        if check is None:
            self.check = []
        else:
            self.check = check
        self.check_nsprefix_ = "cpe_dict"
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemType.subclass:
            return ItemType.subclass(*args_, **kwargs_)
        else:
            return ItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_notes(self):
        return self.notes
    def set_notes(self, notes):
        self.notes = notes
    def add_notes(self, value):
        self.notes.append(value)
    def insert_notes_at(self, index, value):
        self.notes.insert(index, value)
    def replace_notes_at(self, index, value):
        self.notes[index] = value
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_check(self):
        return self.check
    def set_check(self, check):
        self.check = check
    def add_check(self, value):
        self.check.append(value)
    def insert_check_at(self, index, value):
        self.check.insert(index, value)
    def replace_check_at(self, index, value):
        self.check[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    def get_deprecated_by(self):
        return self.deprecated_by
    def set_deprecated_by(self, deprecated_by):
        self.deprecated_by = deprecated_by
    def get_deprecation_date(self):
        return self.deprecation_date
    def set_deprecation_date(self, deprecation_date):
        self.deprecation_date = deprecation_date
    def validate_cpe22Type(self, value):
        # Validate type cpe-name:cpe22Type, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_cpe22Type_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cpe22Type_patterns_, ))
    validate_cpe22Type_patterns_ = [['^([c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\\._\\-~%]*){0,6})$']]
    def has__content(self):
        if (
            self.title or
            self.notes or
            self.references is not None or
            self.check or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ItemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ItemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ItemType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe_dict:', name_='ItemType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.deprecated != "false" and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated=%s' % (quote_attrib(self.deprecated), ))
        if self.deprecated_by is not None and 'deprecated_by' not in already_processed:
            already_processed.add('deprecated_by')
            outfile.write(' deprecated_by=%s' % (quote_attrib(self.deprecated_by), ))
        if self.deprecation_date is not None and 'deprecation_date' not in already_processed:
            already_processed.add('deprecation_date')
            outfile.write(' deprecation_date=%s' % (quote_attrib(self.deprecation_date), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ItemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for notes_ in self.notes:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            notes_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='notes', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
        for check_ in self.check:
            namespaceprefix_ = self.check_nsprefix_ + ':' if (UseCapturedNS_ and self.check_nsprefix_) else ''
            check_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='check', pretty_print=pretty_print)
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_cpe22Type(self.name)    # validate type cpe22Type
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            self.deprecated = value
        value = find_attr_value_('deprecated_by', node)
        if value is not None and 'deprecated_by' not in already_processed:
            already_processed.add('deprecated_by')
            self.deprecated_by = value
            self.validate_cpe22Type(self.deprecated_by)    # validate type cpe22Type
        value = find_attr_value_('deprecation_date', node)
        if value is not None and 'deprecation_date' not in already_processed:
            already_processed.add('deprecation_date')
            self.deprecation_date = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes.append(obj_)
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes.append(obj_)
            obj_.original_tagname_ = 'notes'
        elif nodeName_ == 'references':
            obj_ = ReferencesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'check':
            obj_ = CheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.check.append(obj_)
            obj_.original_tagname_ = 'check'
        else:
            content_ = self.gds_build_any(child_, 'ItemType')
            self.anytypeobjs_.append(content_)
# end class ItemType


class ListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, generator=None, cpe_item=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.generator = generator
        self.generator_nsprefix_ = "cpe_dict"
        if cpe_item is None:
            self.cpe_item = []
        else:
            self.cpe_item = cpe_item
        self.cpe_item_nsprefix_ = "cpe_dict"
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ListType.subclass:
            return ListType.subclass(*args_, **kwargs_)
        else:
            return ListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_generator(self):
        return self.generator
    def set_generator(self, generator):
        self.generator = generator
    def get_cpe_item(self):
        return self.cpe_item
    def set_cpe_item(self, cpe_item):
        self.cpe_item = cpe_item
    def add_cpe_item(self, value):
        self.cpe_item.append(value)
    def insert_cpe_item_at(self, index, value):
        self.cpe_item.insert(index, value)
    def replace_cpe_item_at(self, index, value):
        self.cpe_item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.generator is not None or
            self.cpe_item or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ListType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe_dict:', name_='ListType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.generator is not None:
            namespaceprefix_ = self.generator_nsprefix_ + ':' if (UseCapturedNS_ and self.generator_nsprefix_) else ''
            self.generator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generator', pretty_print=pretty_print)
        for cpe_item_ in self.cpe_item:
            namespaceprefix_ = self.cpe_item_nsprefix_ + ':' if (UseCapturedNS_ and self.cpe_item_nsprefix_) else ''
            cpe_item_.export(outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='', name_='cpe-item', pretty_print=pretty_print)
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'generator':
            obj_ = GeneratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generator = obj_
            obj_.original_tagname_ = 'generator'
        elif nodeName_ == 'cpe-item':
            obj_ = ItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cpe_item.append(obj_)
            obj_.original_tagname_ = 'cpe-item'
        else:
            content_ = self.gds_build_any(child_, 'ListType')
            self.anytypeobjs_.append(content_)
# end class ListType


class TextType4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cpe-dict"
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextType4.subclass:
            return TextType4.subclass(*args_, **kwargs_)
        else:
            return TextType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='TextType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextType4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextType4')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe_dict:', name_='TextType4'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='TextType4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TextType4


class NotesType5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, note=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
        self.note_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotesType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotesType5.subclass:
            return NotesType5.subclass(*args_, **kwargs_)
        else:
            return NotesType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_note(self):
        return self.note
    def set_note(self, note):
        self.note = note
    def add_note(self, value):
        self.note.append(value)
    def insert_note_at(self, index, value):
        self.note.insert(index, value)
    def replace_note_at(self, index, value):
        self.note[index] = value
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def has__content(self):
        if (
            self.note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='NotesType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NotesType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NotesType5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NotesType5')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NotesType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe_dict:', name_='NotesType5'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='NotesType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for note_ in self.note:
            namespaceprefix_ = self.note_nsprefix_ + ':' if (UseCapturedNS_ and self.note_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snote>%s</%snote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(note_), input_name='note')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'note':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'note')
            value_ = self.gds_validate_string(value_, node, 'note')
            self.note.append(value_)
            self.note_nsprefix_ = child_.prefix
# end class NotesType5


class ReferencesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencesType.subclass:
            return ReferencesType.subclass(*args_, **kwargs_)
        else:
            return ReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def has__content(self):
        if (
            self.reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='ReferencesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferencesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferencesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe_dict:', name_='ReferencesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='ReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = referenceType50.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
# end class ReferencesType


class CheckType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, system=None, href=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cpe-dict"
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CheckType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CheckType.subclass:
            return CheckType.subclass(*args_, **kwargs_)
        else:
            return CheckType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='CheckType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CheckType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CheckType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CheckType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cpe_dict:', name_='CheckType'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cpe_dict:', namespacedef_='xmlns:cpe-dict="http://cpe.mitre.org/dictionary/2.0" xmlns:cpe_dict="http://cpe.mitre.org/dictionary/2.0"', name_='CheckType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CheckType


class OCILType(GeneratedsSuper):
    """generator -- The generator element contains information
    related to the generation of the file. Specifically, a generator
    contains information about the application used to create the
    file, when it was created, and the schema to use to validate
    it.
    document -- This element contains document-level information,
    including title, descriptions, and notices.
    questionnaires -- The questionnaires element contains all the
    questionnaire constructs defined within the document.
    test_actions -- The test_actions element contains all the
    boolean, choice, string, and numeric test actions defined within
    the document.
    questions -- The questions element contains all the boolean,
    choice, string, and numeric questions, and any other supporting
    elements (e.g. choice group) defined within the
    document.
    artifacts -- The artifacts element contains all the artifact
    constructs to be retrieved (as necessary) during
    evaluation.
    variables -- The variables element contains all the constant,
    local, and external variables available to be used within the
    document.
    results -- The results element contains the results of an
    evaluation of the OCIL file. This includes records of all
    questionnaire results, question results, and test_action
    results.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, generator=None, document=None, questionnaires=None, test_actions=None, questions=None, artifacts=None, variables=None, results=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.generator = generator
        self.generator_nsprefix_ = "inter"
        self.document = document
        self.document_nsprefix_ = "inter"
        self.questionnaires = questionnaires
        self.questionnaires_nsprefix_ = "inter"
        self.test_actions = test_actions
        self.test_actions_nsprefix_ = "inter"
        self.questions = questions
        self.questions_nsprefix_ = "inter"
        self.artifacts = artifacts
        self.artifacts_nsprefix_ = "inter"
        self.variables = variables
        self.variables_nsprefix_ = "inter"
        self.results = results
        self.results_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OCILType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OCILType.subclass:
            return OCILType.subclass(*args_, **kwargs_)
        else:
            return OCILType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_generator(self):
        return self.generator
    def set_generator(self, generator):
        self.generator = generator
    def get_document(self):
        return self.document
    def set_document(self, document):
        self.document = document
    def get_questionnaires(self):
        return self.questionnaires
    def set_questionnaires(self, questionnaires):
        self.questionnaires = questionnaires
    def get_test_actions(self):
        return self.test_actions
    def set_test_actions(self, test_actions):
        self.test_actions = test_actions
    def get_questions(self):
        return self.questions
    def set_questions(self, questions):
        self.questions = questions
    def get_artifacts(self):
        return self.artifacts
    def set_artifacts(self, artifacts):
        self.artifacts = artifacts
    def get_variables(self):
        return self.variables
    def set_variables(self, variables):
        self.variables = variables
    def get_results(self):
        return self.results
    def set_results(self, results):
        self.results = results
    def has__content(self):
        if (
            self.generator is not None or
            self.document is not None or
            self.questionnaires is not None or
            self.test_actions is not None or
            self.questions is not None or
            self.artifacts is not None or
            self.variables is not None or
            self.results is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='OCILType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OCILType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OCILType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OCILType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OCILType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='OCILType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='OCILType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.generator is not None:
            namespaceprefix_ = self.generator_nsprefix_ + ':' if (UseCapturedNS_ and self.generator_nsprefix_) else ''
            self.generator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generator', pretty_print=pretty_print)
        if self.document is not None:
            namespaceprefix_ = self.document_nsprefix_ + ':' if (UseCapturedNS_ and self.document_nsprefix_) else ''
            self.document.export(outfile, level, namespaceprefix_, namespacedef_='', name_='document', pretty_print=pretty_print)
        if self.questionnaires is not None:
            namespaceprefix_ = self.questionnaires_nsprefix_ + ':' if (UseCapturedNS_ and self.questionnaires_nsprefix_) else ''
            self.questionnaires.export(outfile, level, namespaceprefix_, namespacedef_='', name_='questionnaires', pretty_print=pretty_print)
        if self.test_actions is not None:
            namespaceprefix_ = self.test_actions_nsprefix_ + ':' if (UseCapturedNS_ and self.test_actions_nsprefix_) else ''
            self.test_actions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='test_actions', pretty_print=pretty_print)
        if self.questions is not None:
            namespaceprefix_ = self.questions_nsprefix_ + ':' if (UseCapturedNS_ and self.questions_nsprefix_) else ''
            self.questions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='questions', pretty_print=pretty_print)
        if self.artifacts is not None:
            namespaceprefix_ = self.artifacts_nsprefix_ + ':' if (UseCapturedNS_ and self.artifacts_nsprefix_) else ''
            self.artifacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artifacts', pretty_print=pretty_print)
        if self.variables is not None:
            namespaceprefix_ = self.variables_nsprefix_ + ':' if (UseCapturedNS_ and self.variables_nsprefix_) else ''
            self.variables.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variables', pretty_print=pretty_print)
        if self.results is not None:
            namespaceprefix_ = self.results_nsprefix_ + ':' if (UseCapturedNS_ and self.results_nsprefix_) else ''
            self.results.export(outfile, level, namespaceprefix_, namespacedef_='', name_='results', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'generator':
            obj_ = GeneratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generator = obj_
            obj_.original_tagname_ = 'generator'
        elif nodeName_ == 'document':
            obj_ = DocumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.document = obj_
            obj_.original_tagname_ = 'document'
        elif nodeName_ == 'questionnaires':
            obj_ = QuestionnairesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.questionnaires = obj_
            obj_.original_tagname_ = 'questionnaires'
        elif nodeName_ == 'test_actions':
            obj_ = TestActionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_actions = obj_
            obj_.original_tagname_ = 'test_actions'
        elif nodeName_ == 'questions':
            obj_ = QuestionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.questions = obj_
            obj_.original_tagname_ = 'questions'
        elif nodeName_ == 'artifacts':
            obj_ = ArtifactsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifacts = obj_
            obj_.original_tagname_ = 'artifacts'
        elif nodeName_ == 'variables':
            obj_ = VariablesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variables = obj_
            obj_.original_tagname_ = 'variables'
        elif nodeName_ == 'results':
            obj_ = ResultsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.results = obj_
            obj_.original_tagname_ = 'results'
# end class OCILType


class QuestionnairesType(GeneratedsSuper):
    """questionnaire -- A questionnaire contains a set of questions that
    determines compliance with a check. Each questionnaire returns a
    value based on the responses to the various questions that it
    references. Each questionnaire acting as top-level should represent
    a single compliance check, such as might be referenced by an XCCDF
    Rule.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, questionnaire=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if questionnaire is None:
            self.questionnaire = []
        else:
            self.questionnaire = questionnaire
        self.questionnaire_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionnairesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionnairesType.subclass:
            return QuestionnairesType.subclass(*args_, **kwargs_)
        else:
            return QuestionnairesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_questionnaire(self):
        return self.questionnaire
    def set_questionnaire(self, questionnaire):
        self.questionnaire = questionnaire
    def add_questionnaire(self, value):
        self.questionnaire.append(value)
    def insert_questionnaire_at(self, index, value):
        self.questionnaire.insert(index, value)
    def replace_questionnaire_at(self, index, value):
        self.questionnaire[index] = value
    def has__content(self):
        if (
            self.questionnaire
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionnairesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionnairesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionnairesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionnairesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionnairesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionnairesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionnairesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for questionnaire_ in self.questionnaire:
            namespaceprefix_ = self.questionnaire_nsprefix_ + ':' if (UseCapturedNS_ and self.questionnaire_nsprefix_) else ''
            questionnaire_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='questionnaire', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'questionnaire':
            obj_ = QuestionnaireType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.questionnaire.append(obj_)
            obj_.original_tagname_ = 'questionnaire'
# end class QuestionnairesType


class GeneratorType8(GeneratedsSuper):
    """product_name -- The product_name element specifies the name of the
    application used to generate the file.
    product_version -- The product_version element specifies the version
    of the application used to generate the file.
    author -- The author element identifies one of the authors
    of this document.
    schema_version -- The schema_version element specifies the version
    of the OCIL schema that the document has been written in and that
    should be used for validation.
    timestamp -- The timestamp element specifies when the
    particular OCIL document was generated. The format for the
    timestamp is yyyy-mm-ddThh:mm:ss.
    additional_data -- The additional_data element can be used to contain metadata
    extensions about the generator used to create the OCIL document
    instance.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, product_name=None, product_version=None, author=None, schema_version=None, timestamp=None, additional_data=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.product_name = product_name
        self.product_name_nsprefix_ = None
        self.product_version = product_version
        self.product_version_nsprefix_ = None
        if author is None:
            self.author = []
        else:
            self.author = author
        self.author_nsprefix_ = "inter"
        self.schema_version = schema_version
        self.schema_version_nsprefix_ = None
        self.timestamp = timestamp
        self.timestamp_nsprefix_ = None
        self.additional_data = additional_data
        self.additional_data_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneratorType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneratorType8.subclass:
            return GeneratorType8.subclass(*args_, **kwargs_)
        else:
            return GeneratorType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_product_name(self):
        return self.product_name
    def set_product_name(self, product_name):
        self.product_name = product_name
    def get_product_version(self):
        return self.product_version
    def set_product_version(self, product_version):
        self.product_version = product_version
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def add_author(self, value):
        self.author.append(value)
    def insert_author_at(self, index, value):
        self.author.insert(index, value)
    def replace_author_at(self, index, value):
        self.author[index] = value
    def get_schema_version(self):
        return self.schema_version
    def set_schema_version(self, schema_version):
        self.schema_version = schema_version
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def get_additional_data(self):
        return self.additional_data
    def set_additional_data(self, additional_data):
        self.additional_data = additional_data
    def has__content(self):
        if (
            self.product_name is not None or
            self.product_version is not None or
            self.author or
            self.schema_version is not None or
            self.timestamp is not None or
            self.additional_data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='GeneratorType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneratorType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneratorType8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneratorType8')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneratorType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='GeneratorType8'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='GeneratorType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.product_name is not None:
            namespaceprefix_ = self.product_name_nsprefix_ + ':' if (UseCapturedNS_ and self.product_name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_name>%s</%sproduct_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_name), input_name='product_name')), namespaceprefix_ , eol_))
        if self.product_version is not None:
            namespaceprefix_ = self.product_version_nsprefix_ + ':' if (UseCapturedNS_ and self.product_version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_version>%s</%sproduct_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_version), input_name='product_version')), namespaceprefix_ , eol_))
        for author_ in self.author:
            namespaceprefix_ = self.author_nsprefix_ + ':' if (UseCapturedNS_ and self.author_nsprefix_) else ''
            author_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='author', pretty_print=pretty_print)
        if self.schema_version is not None:
            namespaceprefix_ = self.schema_version_nsprefix_ + ':' if (UseCapturedNS_ and self.schema_version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sschema_version>%s</%sschema_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.schema_version), input_name='schema_version')), namespaceprefix_ , eol_))
        if self.timestamp is not None:
            namespaceprefix_ = self.timestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.timestamp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimestamp>%s</%stimestamp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timestamp), input_name='timestamp')), namespaceprefix_ , eol_))
        if self.additional_data is not None:
            namespaceprefix_ = self.additional_data_nsprefix_ + ':' if (UseCapturedNS_ and self.additional_data_nsprefix_) else ''
            self.additional_data.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additional_data', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'product_name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product_name')
            value_ = self.gds_validate_string(value_, node, 'product_name')
            self.product_name = value_
            self.product_name_nsprefix_ = child_.prefix
        elif nodeName_ == 'product_version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'product_version')
            value_ = self.gds_validate_string(value_, node, 'product_version')
            self.product_version = value_
            self.product_version_nsprefix_ = child_.prefix
        elif nodeName_ == 'author':
            obj_ = UserType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'schema_version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'schema_version')
            value_ = self.gds_validate_string(value_, node, 'schema_version')
            self.schema_version = value_
            self.schema_version_nsprefix_ = child_.prefix
        elif nodeName_ == 'timestamp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'timestamp')
            value_ = self.gds_validate_string(value_, node, 'timestamp')
            self.timestamp = value_
            self.timestamp_nsprefix_ = child_.prefix
        elif nodeName_ == 'additional_data':
            obj_ = ExtensionContainerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additional_data = obj_
            obj_.original_tagname_ = 'additional_data'
# end class GeneratorType8


class ExtensionContainerType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtensionContainerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtensionContainerType.subclass:
            return ExtensionContainerType.subclass(*args_, **kwargs_)
        else:
            return ExtensionContainerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ExtensionContainerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtensionContainerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExtensionContainerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtensionContainerType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExtensionContainerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ExtensionContainerType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ExtensionContainerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'ExtensionContainerType')
        self.anytypeobjs_.append(content_)
# end class ExtensionContainerType


class DocumentType(GeneratedsSuper):
    """title --  The title element provides a title for this document.
      
    * description --  Each description element contains part of an
      overall description for the entire document. (Note that
      questionnaires contain their own description for questionnaire
      specific descriptions.)
      TODO: Consider changing this to XHTML structured text in the next revision.
    * notice --  Each notice element contains a notice or warning to the
      user of this document.
      TODO: Consider changing this to XHTML structured text in the next revision.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, description=None, notice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if description is None:
            self.description = []
        else:
            self.description = description
        self.description_nsprefix_ = None
        if notice is None:
            self.notice = []
        else:
            self.notice = notice
        self.notice_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentType.subclass:
            return DocumentType.subclass(*args_, **kwargs_)
        else:
            return DocumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def add_description(self, value):
        self.description.append(value)
    def insert_description_at(self, index, value):
        self.description.insert(index, value)
    def replace_description_at(self, index, value):
        self.description[index] = value
    def get_notice(self):
        return self.notice
    def set_notice(self, notice):
        self.notice = notice
    def add_notice(self, value):
        self.notice.append(value)
    def insert_notice_at(self, index, value):
        self.notice.insert(index, value)
    def replace_notice_at(self, index, value):
        self.notice[index] = value
    def has__content(self):
        if (
            self.title is not None or
            self.description or
            self.notice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='DocumentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocumentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='DocumentType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='DocumentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        for description_ in self.description:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(description_), input_name='description')), namespaceprefix_ , eol_))
        for notice_ in self.notice:
            namespaceprefix_ = self.notice_nsprefix_ + ':' if (UseCapturedNS_ and self.notice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotice>%s</%snotice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(notice_), input_name='notice')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description.append(value_)
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'notice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notice')
            value_ = self.gds_validate_string(value_, node, 'notice')
            self.notice.append(value_)
            self.notice_nsprefix_ = child_.prefix
# end class DocumentType


class TestActionsType(GeneratedsSuper):
    """test_action -- The test_action element contains information about
    what action to take based on the answer to a referenced question
    element within a questionnaire. It can be a compound_test_action,
    boolean_question_test_action, choice_question_test_action,
    numeric_question_test_action, or string_question_test_action.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, test_action=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if test_action is None:
            self.test_action = []
        else:
            self.test_action = test_action
        self.test_action_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TestActionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TestActionsType.subclass:
            return TestActionsType.subclass(*args_, **kwargs_)
        else:
            return TestActionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_test_action(self):
        return self.test_action
    def set_test_action(self, test_action):
        self.test_action = test_action
    def add_test_action(self, value):
        self.test_action.append(value)
    def insert_test_action_at(self, index, value):
        self.test_action.insert(index, value)
    def replace_test_action_at(self, index, value):
        self.test_action[index] = value
    def has__content(self):
        if (
            self.test_action
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TestActionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TestActionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TestActionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TestActionsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TestActionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='TestActionsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TestActionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for test_action_ in self.test_action:
            test_action_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'test_action':
            class_obj_ = self.get_class_obj_(child_, ItemBaseType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action.append(obj_)
            obj_.original_tagname_ = 'test_action'
        elif nodeName_ == 'question_test_action':
            class_obj_ = self.get_class_obj_(child_, QuestionTestActionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action.append(obj_)
            obj_.original_tagname_ = 'question_test_action'
        elif nodeName_ == 'boolean_question_test_action':
            obj_ = BooleanQuestionTestActionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action.append(obj_)
            obj_.original_tagname_ = 'boolean_question_test_action'
        elif nodeName_ == 'choice_question_test_action':
            obj_ = ChoiceQuestionTestActionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action.append(obj_)
            obj_.original_tagname_ = 'choice_question_test_action'
        elif nodeName_ == 'numeric_question_test_action':
            obj_ = NumericQuestionTestActionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action.append(obj_)
            obj_.original_tagname_ = 'numeric_question_test_action'
        elif nodeName_ == 'string_question_test_action':
            obj_ = StringQuestionTestActionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action.append(obj_)
            obj_.original_tagname_ = 'string_question_test_action'
# end class TestActionsType


class TestActionRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, negate='false', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.negate = _cast(None, negate)
        self.negate_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TestActionRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TestActionRefType.subclass:
            return TestActionRefType.subclass(*args_, **kwargs_)
        else:
            return TestActionRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_negate(self):
        return self.negate
    def set_negate(self, negate):
        self.negate = negate
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_TestActionRefValuePattern(self, value):
        result = True
        # Validate type TestActionRefValuePattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_TestActionRefValuePattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TestActionRefValuePattern_patterns_, ))
                result = False
        return result
    validate_TestActionRefValuePattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:testaction:[1-9][0-9]*)$', '^(ocil:[A-Za-z0-9_\\-\\.]+:questionnaire:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='TestActionRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TestActionRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TestActionRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TestActionRefType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='TestActionRefType'):
        if self.negate != "false" and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='TestActionRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TestActionRefType


class PatternType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, var_ref=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PatternType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PatternType.subclass:
            return PatternType.subclass(*args_, **kwargs_)
        else:
            return PatternType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_VariableIDPattern(self, value):
        # Validate type inter:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='PatternType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PatternType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PatternType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PatternType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='PatternType'):
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='PatternType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PatternType


class RangeType(GeneratedsSuper):
    """min -- The min element contains a minimum value for the range.
      
    * max -- The max element contains a maximum value for teh range.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, min=None, max=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.min = min
        self.min_nsprefix_ = "inter"
        self.max = max
        self.max_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RangeType.subclass:
            return RangeType.subclass(*args_, **kwargs_)
        else:
            return RangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_min(self):
        return self.min
    def set_min(self, min):
        self.min = min
    def get_max(self):
        return self.max
    def set_max(self, max):
        self.max = max
    def has__content(self):
        if (
            self.min is not None or
            self.max is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='RangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RangeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RangeType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='RangeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='RangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.min is not None:
            namespaceprefix_ = self.min_nsprefix_ + ':' if (UseCapturedNS_ and self.min_nsprefix_) else ''
            self.min.export(outfile, level, namespaceprefix_, namespacedef_='', name_='min', pretty_print=pretty_print)
        if self.max is not None:
            namespaceprefix_ = self.max_nsprefix_ + ':' if (UseCapturedNS_ and self.max_nsprefix_) else ''
            self.max.export(outfile, level, namespaceprefix_, namespacedef_='', name_='max', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'min':
            obj_ = RangeValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.min = obj_
            obj_.original_tagname_ = 'min'
        elif nodeName_ == 'max':
            obj_ = RangeValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.max = obj_
            obj_.original_tagname_ = 'max'
# end class RangeType


class TestActionConditionType(GeneratedsSuper):
    """result --  This element indicates that a final value (i.e.
    PASS, FAIL, ERROR, UNKNOWN, NOT_TESTED, NOT_APPLICABLE) should
    be returned if the encapsulating handler is invoked.
      
    * test_action_ref --  This element indicates that a new test_action
      should be processed if the encapsulating handler is invoked.
      
    * artifact_refs -- The artifact_refs element contains all the artifacts
      that must be requested when a question, test_action, or
      questionnaire has been evaluated.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, result=None, test_action_ref=None, artifact_refs=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.result = result
        self.validate_ResultType(self.result)
        self.result_nsprefix_ = "inter"
        self.test_action_ref = test_action_ref
        self.test_action_ref_nsprefix_ = "inter"
        self.artifact_refs = artifact_refs
        self.artifact_refs_nsprefix_ = "inter"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TestActionConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TestActionConditionType.subclass:
            return TestActionConditionType.subclass(*args_, **kwargs_)
        else:
            return TestActionConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def get_test_action_ref(self):
        return self.test_action_ref
    def set_test_action_ref(self, test_action_ref):
        self.test_action_ref = test_action_ref
    def get_artifact_refs(self):
        return self.artifact_refs
    def set_artifact_refs(self, artifact_refs):
        self.artifact_refs = artifact_refs
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ResultType(self, value):
        result = True
        # Validate type ResultType, a restriction on xsd:token.
        pass
        return result
    def has__content(self):
        if (
            self.result is not None or
            self.test_action_ref is not None or
            self.artifact_refs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TestActionConditionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TestActionConditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TestActionConditionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TestActionConditionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TestActionConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='TestActionConditionType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TestActionConditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.result is not None:
            namespaceprefix_ = self.result_nsprefix_ + ':' if (UseCapturedNS_ and self.result_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.result), input_name='result')), namespaceprefix_ , eol_))
        if self.test_action_ref is not None:
            namespaceprefix_ = self.test_action_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.test_action_ref_nsprefix_) else ''
            self.test_action_ref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='test_action_ref', pretty_print=pretty_print)
        if self.artifact_refs is not None:
            namespaceprefix_ = self.artifact_refs_nsprefix_ + ':' if (UseCapturedNS_ and self.artifact_refs_nsprefix_) else ''
            self.artifact_refs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artifact_refs', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'result':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'result')
            value_ = self.gds_validate_string(value_, node, 'result')
            self.result = value_
            self.result_nsprefix_ = child_.prefix
            # validate type ResultType
            self.validate_ResultType(self.result)
        elif nodeName_ == 'test_action_ref':
            obj_ = TestActionRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action_ref = obj_
            obj_.original_tagname_ = 'test_action_ref'
        elif nodeName_ == 'artifact_refs':
            obj_ = ArtifactRefsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_refs = obj_
            obj_.original_tagname_ = 'artifact_refs'
# end class TestActionConditionType


class RangeValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, inclusive='true', var_ref=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.inclusive = _cast(None, inclusive)
        self.inclusive_nsprefix_ = None
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RangeValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RangeValueType.subclass:
            return RangeValueType.subclass(*args_, **kwargs_)
        else:
            return RangeValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_inclusive(self):
        return self.inclusive
    def set_inclusive(self, inclusive):
        self.inclusive = inclusive
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_VariableIDPattern(self, value):
        # Validate type inter:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='RangeValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RangeValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RangeValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RangeValueType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='RangeValueType'):
        if self.inclusive != "true" and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            outfile.write(' inclusive=%s' % (quote_attrib(self.inclusive), ))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='RangeValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inclusive', node)
        if value is not None and 'inclusive' not in already_processed:
            already_processed.add('inclusive')
            self.inclusive = value
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RangeValueType


class QuestionsType(GeneratedsSuper):
    """question -- The question element contains information for a
    single question to be answered. Based on the data type of
    acceptable answers to the question, it can be a boolean_question,
    choice_question, numeric_question, or string_question.
      
    * choice_group -- Holds choice groups which represent possible sets
      of choices for choice_questions. Choice_groups may be reused across
      multiple choice_questions.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, question=None, choice_group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if question is None:
            self.question = []
        else:
            self.question = question
        self.question_nsprefix_ = "inter"
        if choice_group is None:
            self.choice_group = []
        else:
            self.choice_group = choice_group
        self.choice_group_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionsType.subclass:
            return QuestionsType.subclass(*args_, **kwargs_)
        else:
            return QuestionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_question(self):
        return self.question
    def set_question(self, question):
        self.question = question
    def add_question(self, value):
        self.question.append(value)
    def insert_question_at(self, index, value):
        self.question.insert(index, value)
    def replace_question_at(self, index, value):
        self.question[index] = value
    def get_choice_group(self):
        return self.choice_group
    def set_choice_group(self, choice_group):
        self.choice_group = choice_group
    def add_choice_group(self, value):
        self.choice_group.append(value)
    def insert_choice_group_at(self, index, value):
        self.choice_group.insert(index, value)
    def replace_choice_group_at(self, index, value):
        self.choice_group[index] = value
    def has__content(self):
        if (
            self.question or
            self.choice_group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for question_ in self.question:
            question_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for choice_group_ in self.choice_group:
            namespaceprefix_ = self.choice_group_nsprefix_ + ':' if (UseCapturedNS_ and self.choice_group_nsprefix_) else ''
            choice_group_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='choice_group', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'question':
            class_obj_ = self.get_class_obj_(child_, QuestionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'question'
        elif nodeName_ == 'boolean_question':
            obj_ = BooleanQuestionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'boolean_question'
        elif nodeName_ == 'choice_question':
            obj_ = ChoiceQuestionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'choice_question'
        elif nodeName_ == 'numeric_question':
            obj_ = NumericQuestionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'numeric_question'
        elif nodeName_ == 'string_question':
            obj_ = StringQuestionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question.append(obj_)
            obj_.original_tagname_ = 'string_question'
        elif nodeName_ == 'choice_group':
            obj_ = ChoiceGroupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.choice_group.append(obj_)
            obj_.original_tagname_ = 'choice_group'
# end class QuestionsType


class QuestionTextType(GeneratedsSuper):
    """sub -- Allow the inclusion of arbitrary text contained within a variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sub=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
        self.sub_nsprefix_ = "inter"
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionTextType.subclass:
            return QuestionTextType.subclass(*args_, **kwargs_)
        else:
            return QuestionTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sub(self):
        return self.sub
    def set_sub(self, sub):
        self.sub = sub
    def add_sub(self, value):
        self.sub.append(value)
    def insert_sub_at(self, index, value):
        self.sub.insert(index, value)
    def replace_sub_at(self, index, value):
        self.sub[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.sub or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionTextType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionTextType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionTextType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sub_ in self.sub:
            namespaceprefix_ = self.sub_nsprefix_ + ':' if (UseCapturedNS_ and self.sub_nsprefix_) else ''
            sub_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sub', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sub':
            obj_ = SubstitutionTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sub', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sub'):
              self.add_sub(obj_.value)
            elif hasattr(self, 'set_sub'):
              self.set_sub(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class QuestionTextType


class ChoiceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, var_ref=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChoiceType.subclass:
            return ChoiceType.subclass(*args_, **kwargs_)
        else:
            return ChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_ChoiceIDPattern(self, value):
        # Validate type inter:ChoiceIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChoiceIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ChoiceIDPattern_patterns_, ))
    validate_ChoiceIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:choice:[1-9][0-9]*)$']]
    def validate_VariableIDPattern(self, value):
        # Validate type inter:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ChoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChoiceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ChoiceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ChoiceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ChoiceIDPattern(self.id)    # validate type ChoiceIDPattern
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ChoiceType


class ChoiceGroupType(GeneratedsSuper):
    """choice -- Holds the information associated with one of the
    possible responses for a choice_question.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, choice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if choice is None:
            self.choice = []
        else:
            self.choice = choice
        self.choice_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChoiceGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChoiceGroupType.subclass:
            return ChoiceGroupType.subclass(*args_, **kwargs_)
        else:
            return ChoiceGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_choice(self):
        return self.choice
    def set_choice(self, choice):
        self.choice = choice
    def add_choice(self, value):
        self.choice.append(value)
    def insert_choice_at(self, index, value):
        self.choice.insert(index, value)
    def replace_choice_at(self, index, value):
        self.choice[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_ChoiceGroupIDPattern(self, value):
        # Validate type inter:ChoiceGroupIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChoiceGroupIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ChoiceGroupIDPattern_patterns_, ))
    validate_ChoiceGroupIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:choicegroup:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.choice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceGroupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChoiceGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChoiceGroupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceGroupType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChoiceGroupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ChoiceGroupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceGroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for choice_ in self.choice:
            namespaceprefix_ = self.choice_nsprefix_ + ':' if (UseCapturedNS_ and self.choice_nsprefix_) else ''
            choice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='choice', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ChoiceGroupIDPattern(self.id)    # validate type ChoiceGroupIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'choice':
            obj_ = ChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.choice.append(obj_)
            obj_.original_tagname_ = 'choice'
# end class ChoiceGroupType


class InstructionsType(GeneratedsSuper):
    """title -- The title element contains a descriptive heading
    for the instructions.
    step -- Each step element contains a single step within the
    instructions.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, step=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.title = title
        self.title_nsprefix_ = "inter"
        if step is None:
            self.step = []
        else:
            self.step = step
        self.step_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstructionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstructionsType.subclass:
            return InstructionsType.subclass(*args_, **kwargs_)
        else:
            return InstructionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_step(self):
        return self.step
    def set_step(self, step):
        self.step = step
    def add_step(self, value):
        self.step.append(value)
    def insert_step_at(self, index, value):
        self.step.insert(index, value)
    def replace_step_at(self, index, value):
        self.step[index] = value
    def has__content(self):
        if (
            self.title is not None or
            self.step
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='InstructionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstructionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InstructionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstructionsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InstructionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='InstructionsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='InstructionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for step_ in self.step:
            namespaceprefix_ = self.step_nsprefix_ + ':' if (UseCapturedNS_ and self.step_nsprefix_) else ''
            step_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='step', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'step':
            obj_ = StepType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class InstructionsType


class ResultsType(GeneratedsSuper):
    """title -- The title element contains a descriptive heading or
    caption describing the result set.
    questionnaire_results -- The questionnare_results element contains computed
    results of all the evaluated questionnaires.
    test_action_results -- The test_action_results element contains computed
    results of all the evaluated test_action types.
    question_results -- The question_results element contains computed
    results of all evaluated question types.
    artifact_results -- The artifact_results element contains all artifacts
    that have been retrieved during evaluation. Scope is the entire
    document.
    targets -- The targets element contains all the actual target
    users, systems, and roles for which the OCIL document has been
    applied.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, start_time=None, end_time=None, title=None, questionnaire_results=None, test_action_results=None, question_results=None, artifact_results=None, targets=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.start_time = _cast(None, start_time)
        self.start_time_nsprefix_ = None
        self.end_time = _cast(None, end_time)
        self.end_time_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "inter"
        self.questionnaire_results = questionnaire_results
        self.questionnaire_results_nsprefix_ = "inter"
        self.test_action_results = test_action_results
        self.test_action_results_nsprefix_ = "inter"
        self.question_results = question_results
        self.question_results_nsprefix_ = "inter"
        self.artifact_results = artifact_results
        self.artifact_results_nsprefix_ = "inter"
        self.targets = targets
        self.targets_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResultsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResultsType.subclass:
            return ResultsType.subclass(*args_, **kwargs_)
        else:
            return ResultsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_questionnaire_results(self):
        return self.questionnaire_results
    def set_questionnaire_results(self, questionnaire_results):
        self.questionnaire_results = questionnaire_results
    def get_test_action_results(self):
        return self.test_action_results
    def set_test_action_results(self, test_action_results):
        self.test_action_results = test_action_results
    def get_question_results(self):
        return self.question_results
    def set_question_results(self, question_results):
        self.question_results = question_results
    def get_artifact_results(self):
        return self.artifact_results
    def set_artifact_results(self, artifact_results):
        self.artifact_results = artifact_results
    def get_targets(self):
        return self.targets
    def set_targets(self, targets):
        self.targets = targets
    def get_start_time(self):
        return self.start_time
    def set_start_time(self, start_time):
        self.start_time = start_time
    def get_end_time(self):
        return self.end_time
    def set_end_time(self, end_time):
        self.end_time = end_time
    def has__content(self):
        if (
            self.title is not None or
            self.questionnaire_results is not None or
            self.test_action_results is not None or
            self.question_results is not None or
            self.artifact_results is not None or
            self.targets is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ResultsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResultsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResultsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResultsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ResultsType'):
        if self.start_time is not None and 'start_time' not in already_processed:
            already_processed.add('start_time')
            outfile.write(' start_time=%s' % (quote_attrib(self.start_time), ))
        if self.end_time is not None and 'end_time' not in already_processed:
            already_processed.add('end_time')
            outfile.write(' end_time=%s' % (quote_attrib(self.end_time), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ResultsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.questionnaire_results is not None:
            namespaceprefix_ = self.questionnaire_results_nsprefix_ + ':' if (UseCapturedNS_ and self.questionnaire_results_nsprefix_) else ''
            self.questionnaire_results.export(outfile, level, namespaceprefix_, namespacedef_='', name_='questionnaire_results', pretty_print=pretty_print)
        if self.test_action_results is not None:
            namespaceprefix_ = self.test_action_results_nsprefix_ + ':' if (UseCapturedNS_ and self.test_action_results_nsprefix_) else ''
            self.test_action_results.export(outfile, level, namespaceprefix_, namespacedef_='', name_='test_action_results', pretty_print=pretty_print)
        if self.question_results is not None:
            namespaceprefix_ = self.question_results_nsprefix_ + ':' if (UseCapturedNS_ and self.question_results_nsprefix_) else ''
            self.question_results.export(outfile, level, namespaceprefix_, namespacedef_='', name_='question_results', pretty_print=pretty_print)
        if self.artifact_results is not None:
            namespaceprefix_ = self.artifact_results_nsprefix_ + ':' if (UseCapturedNS_ and self.artifact_results_nsprefix_) else ''
            self.artifact_results.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artifact_results', pretty_print=pretty_print)
        if self.targets is not None:
            namespaceprefix_ = self.targets_nsprefix_ + ':' if (UseCapturedNS_ and self.targets_nsprefix_) else ''
            self.targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targets', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('start_time', node)
        if value is not None and 'start_time' not in already_processed:
            already_processed.add('start_time')
            self.start_time = value
        value = find_attr_value_('end_time', node)
        if value is not None and 'end_time' not in already_processed:
            already_processed.add('end_time')
            self.end_time = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'questionnaire_results':
            obj_ = QuestionnaireResultsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.questionnaire_results = obj_
            obj_.original_tagname_ = 'questionnaire_results'
        elif nodeName_ == 'test_action_results':
            obj_ = TestActionResultsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action_results = obj_
            obj_.original_tagname_ = 'test_action_results'
        elif nodeName_ == 'question_results':
            obj_ = QuestionResultsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question_results = obj_
            obj_.original_tagname_ = 'question_results'
        elif nodeName_ == 'artifact_results':
            obj_ = ArtifactResultsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_results = obj_
            obj_.original_tagname_ = 'artifact_results'
        elif nodeName_ == 'targets':
            obj_ = TargetsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targets = obj_
            obj_.original_tagname_ = 'targets'
# end class ResultsType


class QuestionnaireResultsType(GeneratedsSuper):
    """questionnaire_result -- The questionnaire_result element contains
    information about the result of a particular questionnaire.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, questionnaire_result=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if questionnaire_result is None:
            self.questionnaire_result = []
        else:
            self.questionnaire_result = questionnaire_result
        self.questionnaire_result_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionnaireResultsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionnaireResultsType.subclass:
            return QuestionnaireResultsType.subclass(*args_, **kwargs_)
        else:
            return QuestionnaireResultsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_questionnaire_result(self):
        return self.questionnaire_result
    def set_questionnaire_result(self, questionnaire_result):
        self.questionnaire_result = questionnaire_result
    def add_questionnaire_result(self, value):
        self.questionnaire_result.append(value)
    def insert_questionnaire_result_at(self, index, value):
        self.questionnaire_result.insert(index, value)
    def replace_questionnaire_result_at(self, index, value):
        self.questionnaire_result[index] = value
    def has__content(self):
        if (
            self.questionnaire_result
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionnaireResultsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionnaireResultsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionnaireResultsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionnaireResultsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionnaireResultsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionnaireResultsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionnaireResultsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for questionnaire_result_ in self.questionnaire_result:
            namespaceprefix_ = self.questionnaire_result_nsprefix_ + ':' if (UseCapturedNS_ and self.questionnaire_result_nsprefix_) else ''
            questionnaire_result_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='questionnaire_result', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'questionnaire_result':
            obj_ = QuestionnaireResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.questionnaire_result.append(obj_)
            obj_.original_tagname_ = 'questionnaire_result'
# end class QuestionnaireResultsType


class TestActionResultsType(GeneratedsSuper):
    """test_action_result -- The test_action_result element contains the result
    of a test_action evaluation. One of these elements will appear for
    each test_action evaluated.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, test_action_result=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if test_action_result is None:
            self.test_action_result = []
        else:
            self.test_action_result = test_action_result
        self.test_action_result_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TestActionResultsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TestActionResultsType.subclass:
            return TestActionResultsType.subclass(*args_, **kwargs_)
        else:
            return TestActionResultsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_test_action_result(self):
        return self.test_action_result
    def set_test_action_result(self, test_action_result):
        self.test_action_result = test_action_result
    def add_test_action_result(self, value):
        self.test_action_result.append(value)
    def insert_test_action_result_at(self, index, value):
        self.test_action_result.insert(index, value)
    def replace_test_action_result_at(self, index, value):
        self.test_action_result[index] = value
    def has__content(self):
        if (
            self.test_action_result
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TestActionResultsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TestActionResultsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TestActionResultsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TestActionResultsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TestActionResultsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='TestActionResultsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TestActionResultsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for test_action_result_ in self.test_action_result:
            namespaceprefix_ = self.test_action_result_nsprefix_ + ':' if (UseCapturedNS_ and self.test_action_result_nsprefix_) else ''
            test_action_result_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='test_action_result', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'test_action_result':
            obj_ = TestActionResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action_result.append(obj_)
            obj_.original_tagname_ = 'test_action_result'
# end class TestActionResultsType


class QuestionResultsType(GeneratedsSuper):
    """question_result -- A question_result element contains result
    information associated with a specific question. The specific type
    of question_result (boolean_question_result,
    choice_question_result, etc.) depends on the type of the associated
    question (boolean_question, choice_question, etc.)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, question_result=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if question_result is None:
            self.question_result = []
        else:
            self.question_result = question_result
        self.question_result_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionResultsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionResultsType.subclass:
            return QuestionResultsType.subclass(*args_, **kwargs_)
        else:
            return QuestionResultsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_question_result(self):
        return self.question_result
    def set_question_result(self, question_result):
        self.question_result = question_result
    def add_question_result(self, value):
        self.question_result.append(value)
    def insert_question_result_at(self, index, value):
        self.question_result.insert(index, value)
    def replace_question_result_at(self, index, value):
        self.question_result[index] = value
    def has__content(self):
        if (
            self.question_result
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionResultsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionResultsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionResultsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionResultsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionResultsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionResultsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionResultsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for question_result_ in self.question_result:
            question_result_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'question_result':
            class_obj_ = self.get_class_obj_(child_, QuestionResultType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question_result.append(obj_)
            obj_.original_tagname_ = 'question_result'
        elif nodeName_ == 'boolean_question_result':
            obj_ = BooleanQuestionResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question_result.append(obj_)
            obj_.original_tagname_ = 'boolean_question_result'
        elif nodeName_ == 'choice_question_result':
            obj_ = ChoiceQuestionResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question_result.append(obj_)
            obj_.original_tagname_ = 'choice_question_result'
        elif nodeName_ == 'numeric_question_result':
            obj_ = NumericQuestionResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question_result.append(obj_)
            obj_.original_tagname_ = 'numeric_question_result'
        elif nodeName_ == 'string_question_result':
            obj_ = StringQuestionResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question_result.append(obj_)
            obj_.original_tagname_ = 'string_question_result'
# end class QuestionResultsType


class QuestionnaireResultType(GeneratedsSuper):
    """artifact_results -- The artifact_results element contains a set of
    retrieved artifacts.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, questionnaire_ref=None, result=None, artifact_results=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.questionnaire_ref = _cast(None, questionnaire_ref)
        self.questionnaire_ref_nsprefix_ = None
        self.result = _cast(None, result)
        self.result_nsprefix_ = None
        self.artifact_results = artifact_results
        self.artifact_results_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionnaireResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionnaireResultType.subclass:
            return QuestionnaireResultType.subclass(*args_, **kwargs_)
        else:
            return QuestionnaireResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artifact_results(self):
        return self.artifact_results
    def set_artifact_results(self, artifact_results):
        self.artifact_results = artifact_results
    def get_questionnaire_ref(self):
        return self.questionnaire_ref
    def set_questionnaire_ref(self, questionnaire_ref):
        self.questionnaire_ref = questionnaire_ref
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def validate_QuestionnaireIDPattern(self, value):
        # Validate type inter:QuestionnaireIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_QuestionnaireIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_QuestionnaireIDPattern_patterns_, ))
    validate_QuestionnaireIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:questionnaire:[1-9][0-9]*)$']]
    def validate_ResultType(self, value):
        # Validate type inter:ResultType, a restriction on xsd:token.
        pass
    def has__content(self):
        if (
            self.artifact_results is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionnaireResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionnaireResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionnaireResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionnaireResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionnaireResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionnaireResultType'):
        if self.questionnaire_ref is not None and 'questionnaire_ref' not in already_processed:
            already_processed.add('questionnaire_ref')
            outfile.write(' questionnaire_ref=%s' % (quote_attrib(self.questionnaire_ref), ))
        if self.result is not None and 'result' not in already_processed:
            already_processed.add('result')
            outfile.write(' result=%s' % (quote_attrib(self.result), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionnaireResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.artifact_results is not None:
            namespaceprefix_ = self.artifact_results_nsprefix_ + ':' if (UseCapturedNS_ and self.artifact_results_nsprefix_) else ''
            self.artifact_results.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artifact_results', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('questionnaire_ref', node)
        if value is not None and 'questionnaire_ref' not in already_processed:
            already_processed.add('questionnaire_ref')
            self.questionnaire_ref = value
            self.validate_QuestionnaireIDPattern(self.questionnaire_ref)    # validate type QuestionnaireIDPattern
        value = find_attr_value_('result', node)
        if value is not None and 'result' not in already_processed:
            already_processed.add('result')
            self.result = value
            self.validate_ResultType(self.result)    # validate type ResultType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artifact_results':
            obj_ = ArtifactResultsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_results = obj_
            obj_.original_tagname_ = 'artifact_results'
# end class QuestionnaireResultType


class TestActionResultType(GeneratedsSuper):
    """artifact_results -- The artifact_results element contains a set of
    retrieved artifacts.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, test_action_ref=None, result=None, artifact_results=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.test_action_ref = _cast(None, test_action_ref)
        self.test_action_ref_nsprefix_ = None
        self.result = _cast(None, result)
        self.result_nsprefix_ = None
        self.artifact_results = artifact_results
        self.artifact_results_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TestActionResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TestActionResultType.subclass:
            return TestActionResultType.subclass(*args_, **kwargs_)
        else:
            return TestActionResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artifact_results(self):
        return self.artifact_results
    def set_artifact_results(self, artifact_results):
        self.artifact_results = artifact_results
    def get_test_action_ref(self):
        return self.test_action_ref
    def set_test_action_ref(self, test_action_ref):
        self.test_action_ref = test_action_ref
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def validate_TestActionRefValuePattern(self, value):
        # Validate type inter:TestActionRefValuePattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_TestActionRefValuePattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TestActionRefValuePattern_patterns_, ))
    validate_TestActionRefValuePattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:testaction:[1-9][0-9]*)$', '^(ocil:[A-Za-z0-9_\\-\\.]+:questionnaire:[1-9][0-9]*)$']]
    def validate_ResultType(self, value):
        # Validate type inter:ResultType, a restriction on xsd:token.
        pass
    def has__content(self):
        if (
            self.artifact_results is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TestActionResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TestActionResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TestActionResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TestActionResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TestActionResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='TestActionResultType'):
        if self.test_action_ref is not None and 'test_action_ref' not in already_processed:
            already_processed.add('test_action_ref')
            outfile.write(' test_action_ref=%s' % (quote_attrib(self.test_action_ref), ))
        if self.result is not None and 'result' not in already_processed:
            already_processed.add('result')
            outfile.write(' result=%s' % (quote_attrib(self.result), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TestActionResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.artifact_results is not None:
            namespaceprefix_ = self.artifact_results_nsprefix_ + ':' if (UseCapturedNS_ and self.artifact_results_nsprefix_) else ''
            self.artifact_results.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artifact_results', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('test_action_ref', node)
        if value is not None and 'test_action_ref' not in already_processed:
            already_processed.add('test_action_ref')
            self.test_action_ref = value
            self.validate_TestActionRefValuePattern(self.test_action_ref)    # validate type TestActionRefValuePattern
        value = find_attr_value_('result', node)
        if value is not None and 'result' not in already_processed:
            already_processed.add('result')
            self.result = value
            self.validate_ResultType(self.result)    # validate type ResultType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artifact_results':
            obj_ = ArtifactResultsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_results = obj_
            obj_.original_tagname_ = 'artifact_results'
# end class TestActionResultType


class QuestionResultType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, question_ref=None, response='ANSWERED', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.question_ref = _cast(None, question_ref)
        self.question_ref_nsprefix_ = None
        self.response = _cast(None, response)
        self.response_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionResultType.subclass:
            return QuestionResultType.subclass(*args_, **kwargs_)
        else:
            return QuestionResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_question_ref(self):
        return self.question_ref
    def set_question_ref(self, question_ref):
        self.question_ref = question_ref
    def get_response(self):
        return self.response
    def set_response(self, response):
        self.response = response
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_QuestionIDPattern(self, value):
        # Validate type inter:QuestionIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_QuestionIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_QuestionIDPattern_patterns_, ))
    validate_QuestionIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:question:[1-9][0-9]*)$']]
    def validate_UserResponseType(self, value):
        # Validate type inter:UserResponseType, a restriction on xsd:token.
        pass
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='QuestionResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionResultType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionResultType'):
        if self.question_ref is not None and 'question_ref' not in already_processed:
            already_processed.add('question_ref')
            outfile.write(' question_ref=%s' % (quote_attrib(self.question_ref), ))
        if self.response != "ANSWERED" and 'response' not in already_processed:
            already_processed.add('response')
            outfile.write(' response=%s' % (quote_attrib(self.response), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='QuestionResultType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('question_ref', node)
        if value is not None and 'question_ref' not in already_processed:
            already_processed.add('question_ref')
            self.question_ref = value
            self.validate_QuestionIDPattern(self.question_ref)    # validate type QuestionIDPattern
        value = find_attr_value_('response', node)
        if value is not None and 'response' not in already_processed:
            already_processed.add('response')
            self.response = value
            self.validate_UserResponseType(self.response)    # validate type UserResponseType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class QuestionResultType


class BooleanQuestionResultType(QuestionResultType):
    """answer -- The value of the answer to the
    boolean_question. It could either be TRUE or
    FALSE.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionResultType
    def __init__(self, question_ref=None, response='ANSWERED', answer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BooleanQuestionResultType"), self).__init__(question_ref, response,  **kwargs_)
        self.answer = answer
        self.answer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanQuestionResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanQuestionResultType.subclass:
            return BooleanQuestionResultType.subclass(*args_, **kwargs_)
        else:
            return BooleanQuestionResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_answer(self):
        return self.answer
    def set_answer(self, answer):
        self.answer = answer
    def has__content(self):
        if (
            self.answer is not None or
            super(BooleanQuestionResultType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='BooleanQuestionResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanQuestionResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanQuestionResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanQuestionResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanQuestionResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='BooleanQuestionResultType'):
        super(BooleanQuestionResultType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanQuestionResultType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='BooleanQuestionResultType', fromsubclass_=False, pretty_print=True):
        super(BooleanQuestionResultType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.answer is not None:
            namespaceprefix_ = self.answer_nsprefix_ + ':' if (UseCapturedNS_ and self.answer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanswer>%s</%sanswer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.answer), input_name='answer')), namespaceprefix_ , eol_))
        if self.answer is None:
            namespaceprefix_ = self.answer_nsprefix_ + ':' if (UseCapturedNS_ and self.answer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanswer xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BooleanQuestionResultType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'answer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'answer')
            value_ = self.gds_validate_string(value_, node, 'answer')
            self.answer = value_
            self.answer_nsprefix_ = child_.prefix
        super(BooleanQuestionResultType, self)._buildChildren(child_, node, nodeName_, True)
# end class BooleanQuestionResultType


class ChoiceQuestionResultType(QuestionResultType):
    """answer -- The answer element contains a choice_ref
    attribute that identifies the selected choice.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionResultType
    def __init__(self, question_ref=None, response='ANSWERED', answer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("ChoiceQuestionResultType"), self).__init__(question_ref, response,  **kwargs_)
        self.answer = answer
        self.answer_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChoiceQuestionResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChoiceQuestionResultType.subclass:
            return ChoiceQuestionResultType.subclass(*args_, **kwargs_)
        else:
            return ChoiceQuestionResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_answer(self):
        return self.answer
    def set_answer(self, answer):
        self.answer = answer
    def has__content(self):
        if (
            self.answer is not None or
            super(ChoiceQuestionResultType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceQuestionResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChoiceQuestionResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChoiceQuestionResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceQuestionResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChoiceQuestionResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ChoiceQuestionResultType'):
        super(ChoiceQuestionResultType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceQuestionResultType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceQuestionResultType', fromsubclass_=False, pretty_print=True):
        super(ChoiceQuestionResultType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.answer is not None:
            namespaceprefix_ = self.answer_nsprefix_ + ':' if (UseCapturedNS_ and self.answer_nsprefix_) else ''
            self.answer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='answer', pretty_print=pretty_print)
        if self.answer is None:
            namespaceprefix_ = self.answer_nsprefix_ + ':' if (UseCapturedNS_ and self.answer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanswer xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ChoiceQuestionResultType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'answer':
            obj_ = ChoiceAnswerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.answer = obj_
            obj_.original_tagname_ = 'answer'
        super(ChoiceQuestionResultType, self)._buildChildren(child_, node, nodeName_, True)
# end class ChoiceQuestionResultType


class NumericQuestionResultType(QuestionResultType):
    """answer -- The decimal value of the answer to a
    numeric_question.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionResultType
    def __init__(self, question_ref=None, response='ANSWERED', answer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("NumericQuestionResultType"), self).__init__(question_ref, response,  **kwargs_)
        self.answer = answer
        self.answer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericQuestionResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericQuestionResultType.subclass:
            return NumericQuestionResultType.subclass(*args_, **kwargs_)
        else:
            return NumericQuestionResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_answer(self):
        return self.answer
    def set_answer(self, answer):
        self.answer = answer
    def has__content(self):
        if (
            self.answer is not None or
            super(NumericQuestionResultType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='NumericQuestionResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericQuestionResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericQuestionResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericQuestionResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumericQuestionResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='NumericQuestionResultType'):
        super(NumericQuestionResultType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericQuestionResultType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='NumericQuestionResultType', fromsubclass_=False, pretty_print=True):
        super(NumericQuestionResultType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.answer is not None:
            namespaceprefix_ = self.answer_nsprefix_ + ':' if (UseCapturedNS_ and self.answer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanswer>%s</%sanswer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.answer), input_name='answer')), namespaceprefix_ , eol_))
        if self.answer is None:
            namespaceprefix_ = self.answer_nsprefix_ + ':' if (UseCapturedNS_ and self.answer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanswer xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(NumericQuestionResultType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'answer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'answer')
            value_ = self.gds_validate_string(value_, node, 'answer')
            self.answer = value_
            self.answer_nsprefix_ = child_.prefix
        super(NumericQuestionResultType, self)._buildChildren(child_, node, nodeName_, True)
# end class NumericQuestionResultType


class StringQuestionResultType(QuestionResultType):
    """answer -- The string value of the answer to a
    string_question.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionResultType
    def __init__(self, question_ref=None, response='ANSWERED', answer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StringQuestionResultType"), self).__init__(question_ref, response,  **kwargs_)
        self.answer = answer
        self.answer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringQuestionResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringQuestionResultType.subclass:
            return StringQuestionResultType.subclass(*args_, **kwargs_)
        else:
            return StringQuestionResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_answer(self):
        return self.answer
    def set_answer(self, answer):
        self.answer = answer
    def has__content(self):
        if (
            self.answer is not None or
            super(StringQuestionResultType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='StringQuestionResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringQuestionResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringQuestionResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringQuestionResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringQuestionResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='StringQuestionResultType'):
        super(StringQuestionResultType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringQuestionResultType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='StringQuestionResultType', fromsubclass_=False, pretty_print=True):
        super(StringQuestionResultType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.answer is not None:
            namespaceprefix_ = self.answer_nsprefix_ + ':' if (UseCapturedNS_ and self.answer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanswer>%s</%sanswer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.answer), input_name='answer')), namespaceprefix_ , eol_))
        if self.answer is None:
            namespaceprefix_ = self.answer_nsprefix_ + ':' if (UseCapturedNS_ and self.answer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanswer xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/>%s' % (namespaceprefix_,eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StringQuestionResultType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'answer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'answer')
            value_ = self.gds_validate_string(value_, node, 'answer')
            self.answer = value_
            self.answer_nsprefix_ = child_.prefix
        super(StringQuestionResultType, self)._buildChildren(child_, node, nodeName_, True)
# end class StringQuestionResultType


class ChoiceAnswerType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, choice_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.choice_ref = _cast(None, choice_ref)
        self.choice_ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChoiceAnswerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChoiceAnswerType.subclass:
            return ChoiceAnswerType.subclass(*args_, **kwargs_)
        else:
            return ChoiceAnswerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_choice_ref(self):
        return self.choice_ref
    def set_choice_ref(self, choice_ref):
        self.choice_ref = choice_ref
    def validate_ChoiceIDPattern(self, value):
        # Validate type inter:ChoiceIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChoiceIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ChoiceIDPattern_patterns_, ))
    validate_ChoiceIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:choice:[1-9][0-9]*)$']]
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ChoiceAnswerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChoiceAnswerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChoiceAnswerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceAnswerType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChoiceAnswerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ChoiceAnswerType'):
        if self.choice_ref is not None and 'choice_ref' not in already_processed:
            already_processed.add('choice_ref')
            outfile.write(' choice_ref=%s' % (quote_attrib(self.choice_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ChoiceAnswerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('choice_ref', node)
        if value is not None and 'choice_ref' not in already_processed:
            already_processed.add('choice_ref')
            self.choice_ref = value
            self.validate_ChoiceIDPattern(self.choice_ref)    # validate type ChoiceIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ChoiceAnswerType


class ArtifactsType(GeneratedsSuper):
    """artifact -- An artifact element holds information about an
    artifact, which is evidence supporting an answer. Examples include
    a file or submitted text.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, artifact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if artifact is None:
            self.artifact = []
        else:
            self.artifact = artifact
        self.artifact_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArtifactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArtifactsType.subclass:
            return ArtifactsType.subclass(*args_, **kwargs_)
        else:
            return ArtifactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artifact(self):
        return self.artifact
    def set_artifact(self, artifact):
        self.artifact = artifact
    def add_artifact(self, value):
        self.artifact.append(value)
    def insert_artifact_at(self, index, value):
        self.artifact.insert(index, value)
    def replace_artifact_at(self, index, value):
        self.artifact[index] = value
    def has__content(self):
        if (
            self.artifact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArtifactsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArtifactsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArtifactsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArtifactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ArtifactsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for artifact_ in self.artifact:
            namespaceprefix_ = self.artifact_nsprefix_ + ':' if (UseCapturedNS_ and self.artifact_nsprefix_) else ''
            artifact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artifact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artifact':
            obj_ = ArtifactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact.append(obj_)
            obj_.original_tagname_ = 'artifact'
# end class ArtifactsType


class ArtifactRefsType(GeneratedsSuper):
    """artifact_ref -- A single reference to an artifact.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, artifact_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if artifact_ref is None:
            self.artifact_ref = []
        else:
            self.artifact_ref = artifact_ref
        self.artifact_ref_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArtifactRefsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArtifactRefsType.subclass:
            return ArtifactRefsType.subclass(*args_, **kwargs_)
        else:
            return ArtifactRefsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artifact_ref(self):
        return self.artifact_ref
    def set_artifact_ref(self, artifact_ref):
        self.artifact_ref = artifact_ref
    def add_artifact_ref(self, value):
        self.artifact_ref.append(value)
    def insert_artifact_ref_at(self, index, value):
        self.artifact_ref.insert(index, value)
    def replace_artifact_ref_at(self, index, value):
        self.artifact_ref[index] = value
    def has__content(self):
        if (
            self.artifact_ref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactRefsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArtifactRefsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArtifactRefsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArtifactRefsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArtifactRefsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ArtifactRefsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactRefsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for artifact_ref_ in self.artifact_ref:
            namespaceprefix_ = self.artifact_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.artifact_ref_nsprefix_) else ''
            artifact_ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artifact_ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artifact_ref':
            obj_ = ArtifactRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_ref.append(obj_)
            obj_.original_tagname_ = 'artifact_ref'
# end class ArtifactRefsType


class ArtifactRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idref=None, required='false', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.idref = _cast(None, idref)
        self.idref_nsprefix_ = None
        self.required = _cast(None, required)
        self.required_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArtifactRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArtifactRefType.subclass:
            return ArtifactRefType.subclass(*args_, **kwargs_)
        else:
            return ArtifactRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idref(self):
        return self.idref
    def set_idref(self, idref):
        self.idref = idref
    def get_required(self):
        return self.required
    def set_required(self, required):
        self.required = required
    def validate_ArtifactIDPattern(self, value):
        # Validate type inter:ArtifactIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ArtifactIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ArtifactIDPattern_patterns_, ))
    validate_ArtifactIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:artifact:[1-9][0-9]*)$']]
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ArtifactRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArtifactRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArtifactRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArtifactRefType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArtifactRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ArtifactRefType'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (quote_attrib(self.idref), ))
        if self.required != "false" and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required=%s' % (quote_attrib(self.required), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ArtifactRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
            self.validate_ArtifactIDPattern(self.idref)    # validate type ArtifactIDPattern
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            self.required = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ArtifactRefType


class ArtifactResultsType(GeneratedsSuper):
    """artifact_result -- The artifact_result element contains an artifact,
    its value, who submitted it, and who provided
    it.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, artifact_result=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if artifact_result is None:
            self.artifact_result = []
        else:
            self.artifact_result = artifact_result
        self.artifact_result_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArtifactResultsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArtifactResultsType.subclass:
            return ArtifactResultsType.subclass(*args_, **kwargs_)
        else:
            return ArtifactResultsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artifact_result(self):
        return self.artifact_result
    def set_artifact_result(self, artifact_result):
        self.artifact_result = artifact_result
    def add_artifact_result(self, value):
        self.artifact_result.append(value)
    def insert_artifact_result_at(self, index, value):
        self.artifact_result.insert(index, value)
    def replace_artifact_result_at(self, index, value):
        self.artifact_result[index] = value
    def has__content(self):
        if (
            self.artifact_result
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactResultsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArtifactResultsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArtifactResultsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArtifactResultsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArtifactResultsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ArtifactResultsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactResultsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for artifact_result_ in self.artifact_result:
            namespaceprefix_ = self.artifact_result_nsprefix_ + ':' if (UseCapturedNS_ and self.artifact_result_nsprefix_) else ''
            artifact_result_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='artifact_result', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artifact_result':
            obj_ = ArtifactResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_result.append(obj_)
            obj_.original_tagname_ = 'artifact_result'
# end class ArtifactResultsType


class ArtifactValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArtifactValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArtifactValueType.subclass:
            return ArtifactValueType.subclass(*args_, **kwargs_)
        else:
            return ArtifactValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ArtifactValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArtifactValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArtifactValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArtifactValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArtifactValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ArtifactValueType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ArtifactValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ArtifactValueType


class EmbeddedArtifactValueType(ArtifactValueType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArtifactValueType
    def __init__(self, mime_type=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("EmbeddedArtifactValueType"), self).__init__(extensiontype_,  **kwargs_)
        self.mime_type = _cast(None, mime_type)
        self.mime_type_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmbeddedArtifactValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmbeddedArtifactValueType.subclass:
            return EmbeddedArtifactValueType.subclass(*args_, **kwargs_)
        else:
            return EmbeddedArtifactValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mime_type(self):
        return self.mime_type
    def set_mime_type(self, mime_type):
        self.mime_type = mime_type
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            super(EmbeddedArtifactValueType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='EmbeddedArtifactValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EmbeddedArtifactValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EmbeddedArtifactValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EmbeddedArtifactValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EmbeddedArtifactValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='EmbeddedArtifactValueType'):
        super(EmbeddedArtifactValueType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EmbeddedArtifactValueType')
        if self.mime_type is not None and 'mime_type' not in already_processed:
            already_processed.add('mime_type')
            outfile.write(' mime_type=%s' % (quote_attrib(self.mime_type), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='EmbeddedArtifactValueType', fromsubclass_=False, pretty_print=True):
        super(EmbeddedArtifactValueType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mime_type', node)
        if value is not None and 'mime_type' not in already_processed:
            already_processed.add('mime_type')
            self.mime_type = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EmbeddedArtifactValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EmbeddedArtifactValueType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class EmbeddedArtifactValueType


class TextArtifactValueType(EmbeddedArtifactValueType):
    """data -- The data element contains the text of an
    artifact that was provided as a text file or a block of
    text.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EmbeddedArtifactValueType
    def __init__(self, mime_type=None, data=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TextArtifactValueType"), self).__init__(mime_type,  **kwargs_)
        self.data = data
        self.data_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextArtifactValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextArtifactValueType.subclass:
            return TextArtifactValueType.subclass(*args_, **kwargs_)
        else:
            return TextArtifactValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    def has__content(self):
        if (
            self.data is not None or
            super(TextArtifactValueType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='TextArtifactValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextArtifactValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextArtifactValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextArtifactValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextArtifactValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='TextArtifactValueType'):
        super(TextArtifactValueType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextArtifactValueType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='TextArtifactValueType', fromsubclass_=False, pretty_print=True):
        super(TextArtifactValueType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data is not None:
            namespaceprefix_ = self.data_nsprefix_ + ':' if (UseCapturedNS_ and self.data_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.data), input_name='data')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TextArtifactValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'data':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'data')
            value_ = self.gds_validate_string(value_, node, 'data')
            self.data = value_
            self.data_nsprefix_ = child_.prefix
        super(TextArtifactValueType, self)._buildChildren(child_, node, nodeName_, True)
# end class TextArtifactValueType


class BinaryArtifactValueType(EmbeddedArtifactValueType):
    """data -- The data element contains a binary file,
    which was provided as an artifact.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EmbeddedArtifactValueType
    def __init__(self, mime_type=None, data=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BinaryArtifactValueType"), self).__init__(mime_type,  **kwargs_)
        self.data = data
        self.data_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryArtifactValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryArtifactValueType.subclass:
            return BinaryArtifactValueType.subclass(*args_, **kwargs_)
        else:
            return BinaryArtifactValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    def has__content(self):
        if (
            self.data is not None or
            super(BinaryArtifactValueType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='BinaryArtifactValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryArtifactValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BinaryArtifactValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryArtifactValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BinaryArtifactValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='BinaryArtifactValueType'):
        super(BinaryArtifactValueType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryArtifactValueType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='BinaryArtifactValueType', fromsubclass_=False, pretty_print=True):
        super(BinaryArtifactValueType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data is not None:
            namespaceprefix_ = self.data_nsprefix_ + ':' if (UseCapturedNS_ and self.data_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.data), input_name='data')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BinaryArtifactValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'data':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'data')
            value_ = self.gds_validate_string(value_, node, 'data')
            self.data = value_
            self.data_nsprefix_ = child_.prefix
        super(BinaryArtifactValueType, self)._buildChildren(child_, node, nodeName_, True)
# end class BinaryArtifactValueType


class ReferenceArtifactValueType(ArtifactValueType):
    """reference -- The reference element contains a URI, which
    is a pointer to the location of an artifact.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArtifactValueType
    def __init__(self, reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReferenceArtifactValueType"), self).__init__( **kwargs_)
        self.reference = reference
        self.reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceArtifactValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceArtifactValueType.subclass:
            return ReferenceArtifactValueType.subclass(*args_, **kwargs_)
        else:
            return ReferenceArtifactValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def has__content(self):
        if (
            self.reference is not None or
            super(ReferenceArtifactValueType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ReferenceArtifactValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceArtifactValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceArtifactValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceArtifactValueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceArtifactValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ReferenceArtifactValueType'):
        super(ReferenceArtifactValueType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceArtifactValueType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ReferenceArtifactValueType', fromsubclass_=False, pretty_print=True):
        super(ReferenceArtifactValueType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            self.reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReferenceArtifactValueType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = referenceType51.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference = obj_
            obj_.original_tagname_ = 'reference'
        super(ReferenceArtifactValueType, self)._buildChildren(child_, node, nodeName_, True)
# end class ReferenceArtifactValueType


class ArtifactResultType(GeneratedsSuper):
    """artifact_value -- The artifact_value element contains either the artifact data
    itself or a pointer to it.
    provider -- The provider element contains information about the
    user or system that provided the artifact.
    submitter -- The submitter element contains information about
    the user who submitted the artifact.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, artifact_ref=None, timestamp=None, artifact_value=None, provider=None, submitter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.artifact_ref = _cast(None, artifact_ref)
        self.artifact_ref_nsprefix_ = None
        self.timestamp = _cast(None, timestamp)
        self.timestamp_nsprefix_ = None
        self.artifact_value = artifact_value
        self.artifact_value_nsprefix_ = "inter"
        self.provider = provider
        self.validate_ProviderValuePattern(self.provider)
        self.provider_nsprefix_ = "inter"
        self.submitter = submitter
        self.submitter_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArtifactResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArtifactResultType.subclass:
            return ArtifactResultType.subclass(*args_, **kwargs_)
        else:
            return ArtifactResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_artifact_value(self):
        return self.artifact_value
    def set_artifact_value(self, artifact_value):
        self.artifact_value = artifact_value
    def get_provider(self):
        return self.provider
    def set_provider(self, provider):
        self.provider = provider
    def get_submitter(self):
        return self.submitter
    def set_submitter(self, submitter):
        self.submitter = submitter
    def get_artifact_ref(self):
        return self.artifact_ref
    def set_artifact_ref(self, artifact_ref):
        self.artifact_ref = artifact_ref
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def validate_ProviderValuePattern(self, value):
        result = True
        # Validate type ProviderValuePattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ProviderValuePattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ProviderValuePattern_patterns_, ))
                result = False
        return result
    validate_ProviderValuePattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:user:[1-9][0-9]*)$', '^(ocil:[A-Za-z0-9_\\-\\.]+:system:[1-9][0-9]*)$']]
    def validate_ArtifactIDPattern(self, value):
        # Validate type inter:ArtifactIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ArtifactIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ArtifactIDPattern_patterns_, ))
    validate_ArtifactIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:artifact:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.artifact_value is not None or
            self.provider is not None or
            self.submitter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArtifactResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArtifactResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArtifactResultType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArtifactResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ArtifactResultType'):
        if self.artifact_ref is not None and 'artifact_ref' not in already_processed:
            already_processed.add('artifact_ref')
            outfile.write(' artifact_ref=%s' % (quote_attrib(self.artifact_ref), ))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp=%s' % (quote_attrib(self.timestamp), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.artifact_value is not None:
            self.artifact_value.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.provider is not None:
            namespaceprefix_ = self.provider_nsprefix_ + ':' if (UseCapturedNS_ and self.provider_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprovider>%s</%sprovider>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.provider), input_name='provider')), namespaceprefix_ , eol_))
        if self.submitter is not None:
            namespaceprefix_ = self.submitter_nsprefix_ + ':' if (UseCapturedNS_ and self.submitter_nsprefix_) else ''
            self.submitter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='submitter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('artifact_ref', node)
        if value is not None and 'artifact_ref' not in already_processed:
            already_processed.add('artifact_ref')
            self.artifact_ref = value
            self.validate_ArtifactIDPattern(self.artifact_ref)    # validate type ArtifactIDPattern
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            self.timestamp = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'artifact_value':
            class_obj_ = self.get_class_obj_(child_, ArtifactValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_value = obj_
            obj_.original_tagname_ = 'artifact_value'
        elif nodeName_ == 'text_artifact_value':
            obj_ = TextArtifactValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_value = obj_
            obj_.original_tagname_ = 'text_artifact_value'
        elif nodeName_ == 'binary_artifact_value':
            obj_ = BinaryArtifactValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_value = obj_
            obj_.original_tagname_ = 'binary_artifact_value'
        elif nodeName_ == 'reference_artifact_value':
            obj_ = ReferenceArtifactValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.artifact_value = obj_
            obj_.original_tagname_ = 'reference_artifact_value'
        elif nodeName_ == 'provider':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'provider')
            value_ = self.gds_validate_string(value_, node, 'provider')
            self.provider = value_
            self.provider_nsprefix_ = child_.prefix
            # validate type ProviderValuePattern
            self.validate_ProviderValuePattern(self.provider)
        elif nodeName_ == 'submitter':
            obj_ = UserType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.submitter = obj_
            obj_.original_tagname_ = 'submitter'
# end class ArtifactResultType


class TargetsType(GeneratedsSuper):
    """target -- A target element describes the user, system, or
    role that applies to all questionnaires in scope. For instance,
    specifying that user Joe Smith should complete this document;
    applies to system with ip address of 123.45.67.89; applies to all
    systems functioning as (role) web servers; or all (role)
    administrators should complete this document.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if target is None:
            self.target = []
        else:
            self.target = target
        self.target_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetsType.subclass:
            return TargetsType.subclass(*args_, **kwargs_)
        else:
            return TargetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def add_target(self, value):
        self.target.append(value)
    def insert_target_at(self, index, value):
        self.target.insert(index, value)
    def replace_target_at(self, index, value):
        self.target[index] = value
    def has__content(self):
        if (
            self.target
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TargetsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TargetsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='TargetsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='TargetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for target_ in self.target:
            target_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'target':
            class_obj_ = self.get_class_obj_(child_, NamedItemBaseType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target.append(obj_)
            obj_.original_tagname_ = 'target'
        elif nodeName_ == 'user':
            obj_ = UserType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target.append(obj_)
            obj_.original_tagname_ = 'user'
        elif nodeName_ == 'system':
            obj_ = system.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.target.append(obj_)
            obj_.original_tagname_ = 'system'
# end class TargetsType


class VariablesType9(GeneratedsSuper):
    """variable -- A variable element holds a value defined by the
    author, a value based on a question's answer, or a value from an
    external source.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, variable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if variable is None:
            self.variable = []
        else:
            self.variable = variable
        self.variable_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariablesType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariablesType9.subclass:
            return VariablesType9.subclass(*args_, **kwargs_)
        else:
            return VariablesType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_variable(self):
        return self.variable
    def set_variable(self, variable):
        self.variable = variable
    def add_variable(self, value):
        self.variable.append(value)
    def insert_variable_at(self, index, value):
        self.variable.insert(index, value)
    def replace_variable_at(self, index, value):
        self.variable[index] = value
    def has__content(self):
        if (
            self.variable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='VariablesType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariablesType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariablesType9':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariablesType9')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariablesType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='VariablesType9'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='VariablesType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variable_ in self.variable:
            variable_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'variable':
            class_obj_ = self.get_class_obj_(child_, VariableType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'variable'
        elif nodeName_ == 'external_variable':
            obj_ = ExternalVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'external_variable'
        elif nodeName_ == 'constant_variable':
            obj_ = ConstantVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'constant_variable'
        elif nodeName_ == 'local_variable':
            obj_ = LocalVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'local_variable'
        elif nodeName_ == 'constant_variable':
            obj_ = ConstantVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'constant_variable'
        elif nodeName_ == 'local_variable':
            obj_ = LocalVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'local_variable'
        elif nodeName_ == 'external_variable':
            obj_ = ExternalVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'external_variable'
# end class VariablesType9


class ConstantVariableType(VariableType):
    """value -- The value element holds the data stored on
    the variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = VariableType
    def __init__(self, id=None, version=None, datatype=None, comment=None, deprecated='false', Signature=None, notes=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConstantVariableType"), self).__init__(id, version, datatype, comment, deprecated, Signature, notes,  **kwargs_)
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConstantVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConstantVariableType.subclass:
            return ConstantVariableType.subclass(*args_, **kwargs_)
        else:
            return ConstantVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def has__content(self):
        if (
            self.value is not None or
            super(ConstantVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ConstantVariableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConstantVariableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConstantVariableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConstantVariableType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConstantVariableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ConstantVariableType'):
        super(ConstantVariableType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConstantVariableType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ConstantVariableType', fromsubclass_=False, pretty_print=True):
        super(ConstantVariableType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConstantVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
        super(ConstantVariableType, self)._buildChildren(child_, node, nodeName_, True)
# end class ConstantVariableType


class LocalVariableType(VariableType):
    """set -- The set element contains information
    describing how to compute the value to be stored on the
    variable. It holds the patterns, choice_refs, range or boolean
    values to be matched with the answer to the linked question;
    and the appropriate value to be stored on the variable based
    on the match.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = VariableType
    def __init__(self, id=None, version=None, datatype=None, comment=None, deprecated='false', Signature=None, notes=None, question_ref=None, set_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LocalVariableType"), self).__init__(id, version, datatype, comment, deprecated, Signature, notes,  **kwargs_)
        self.question_ref = _cast(None, question_ref)
        self.question_ref_nsprefix_ = None
        self.set_ = set_
        self.set__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalVariableType.subclass:
            return LocalVariableType.subclass(*args_, **kwargs_)
        else:
            return LocalVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_set(self):
        return self.set_
    def set_set(self, set_):
        self.set_ = set_
    def get_question_ref(self):
        return self.question_ref
    def set_question_ref(self, question_ref):
        self.question_ref = question_ref
    def validate_QuestionIDPattern(self, value):
        # Validate type inter:QuestionIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_QuestionIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_QuestionIDPattern_patterns_, ))
    validate_QuestionIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:question:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.set_ is not None or
            super(LocalVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='LocalVariableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalVariableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocalVariableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalVariableType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocalVariableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='LocalVariableType'):
        super(LocalVariableType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalVariableType')
        if self.question_ref is not None and 'question_ref' not in already_processed:
            already_processed.add('question_ref')
            outfile.write(' question_ref=%s' % (quote_attrib(self.question_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='LocalVariableType', fromsubclass_=False, pretty_print=True):
        super(LocalVariableType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.set_ is not None:
            namespaceprefix_ = self.set__nsprefix_ + ':' if (UseCapturedNS_ and self.set__nsprefix_) else ''
            self.set_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='set', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('question_ref', node)
        if value is not None and 'question_ref' not in already_processed:
            already_processed.add('question_ref')
            self.question_ref = value
            self.validate_QuestionIDPattern(self.question_ref)    # validate type QuestionIDPattern
        super(LocalVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'set':
            obj_ = set_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.set_ = obj_
            obj_.original_tagname_ = 'set'
        super(LocalVariableType, self)._buildChildren(child_, node, nodeName_, True)
# end class LocalVariableType


class set_(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, set_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if set_.subclass:
            return set_.subclass(*args_, **kwargs_)
        else:
            return set_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='set', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('set')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'set':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='set')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='set', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='oval-def:', name_='set'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='oval-def:', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"', name_='set', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class set_


class ExternalVariableType(VariableType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = VariableType
    def __init__(self, id=None, version=None, datatype=None, comment=None, deprecated='false', Signature=None, notes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("ExternalVariableType"), self).__init__(id, version, datatype, comment, deprecated, Signature, notes,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalVariableType.subclass:
            return ExternalVariableType.subclass(*args_, **kwargs_)
        else:
            return ExternalVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (
            super(ExternalVariableType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ExternalVariableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExternalVariableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExternalVariableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalVariableType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExternalVariableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ExternalVariableType'):
        super(ExternalVariableType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalVariableType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ExternalVariableType', fromsubclass_=False, pretty_print=True):
        super(ExternalVariableType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ExternalVariableType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ExternalVariableType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ExternalVariableType


class SetExpressionBaseType(GeneratedsSuper):
    """value -- The value element contains the data to be stored on
    the variable if the expression evaluates to TRUE.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetExpressionBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetExpressionBaseType.subclass:
            return SetExpressionBaseType.subclass(*args_, **kwargs_)
        else:
            return SetExpressionBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetExpressionBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SetExpressionBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetExpressionBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='SetExpressionBaseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
# end class SetExpressionBaseType


class value(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if value.subclass:
            return value.subclass(*args_, **kwargs_)
        else:
            return value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='value', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'value':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='value')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='value', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='value'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='value', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class value


class SetExpressionPatternType(SetExpressionBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SetExpressionBaseType
    def __init__(self, value=None, pattern=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("SetExpressionPatternType"), self).__init__(value,  **kwargs_)
        self.pattern = _cast(None, pattern)
        self.pattern_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetExpressionPatternType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetExpressionPatternType.subclass:
            return SetExpressionPatternType.subclass(*args_, **kwargs_)
        else:
            return SetExpressionPatternType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pattern(self):
        return self.pattern
    def set_pattern(self, pattern):
        self.pattern = pattern
    def has__content(self):
        if (
            super(SetExpressionPatternType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionPatternType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetExpressionPatternType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SetExpressionPatternType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionPatternType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetExpressionPatternType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='SetExpressionPatternType'):
        super(SetExpressionPatternType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionPatternType')
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            outfile.write(' pattern=%s' % (quote_attrib(self.pattern), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionPatternType', fromsubclass_=False, pretty_print=True):
        super(SetExpressionPatternType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pattern', node)
        if value is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            self.pattern = value
        super(SetExpressionPatternType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SetExpressionPatternType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SetExpressionPatternType


class SetExpressionChoiceType(SetExpressionBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SetExpressionBaseType
    def __init__(self, value=None, choice_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("SetExpressionChoiceType"), self).__init__(value,  **kwargs_)
        self.choice_ref = _cast(None, choice_ref)
        self.choice_ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetExpressionChoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetExpressionChoiceType.subclass:
            return SetExpressionChoiceType.subclass(*args_, **kwargs_)
        else:
            return SetExpressionChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_choice_ref(self):
        return self.choice_ref
    def set_choice_ref(self, choice_ref):
        self.choice_ref = choice_ref
    def validate_ChoiceIDPattern(self, value):
        # Validate type inter:ChoiceIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChoiceIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ChoiceIDPattern_patterns_, ))
    validate_ChoiceIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:choice:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            super(SetExpressionChoiceType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionChoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetExpressionChoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SetExpressionChoiceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionChoiceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetExpressionChoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='SetExpressionChoiceType'):
        super(SetExpressionChoiceType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionChoiceType')
        if self.choice_ref is not None and 'choice_ref' not in already_processed:
            already_processed.add('choice_ref')
            outfile.write(' choice_ref=%s' % (quote_attrib(self.choice_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionChoiceType', fromsubclass_=False, pretty_print=True):
        super(SetExpressionChoiceType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('choice_ref', node)
        if value is not None and 'choice_ref' not in already_processed:
            already_processed.add('choice_ref')
            self.choice_ref = value
            self.validate_ChoiceIDPattern(self.choice_ref)    # validate type ChoiceIDPattern
        super(SetExpressionChoiceType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SetExpressionChoiceType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SetExpressionChoiceType


class SetExpressionRangeType(SetExpressionBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SetExpressionBaseType
    def __init__(self, value=None, min=None, max=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("SetExpressionRangeType"), self).__init__(value,  **kwargs_)
        self.min = _cast(None, min)
        self.min_nsprefix_ = None
        self.max = _cast(None, max)
        self.max_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetExpressionRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetExpressionRangeType.subclass:
            return SetExpressionRangeType.subclass(*args_, **kwargs_)
        else:
            return SetExpressionRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_min(self):
        return self.min
    def set_min(self, min):
        self.min = min
    def get_max(self):
        return self.max
    def set_max(self, max):
        self.max = max
    def has__content(self):
        if (
            super(SetExpressionRangeType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionRangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetExpressionRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SetExpressionRangeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionRangeType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetExpressionRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='SetExpressionRangeType'):
        super(SetExpressionRangeType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionRangeType')
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            outfile.write(' min=%s' % (quote_attrib(self.min), ))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max=%s' % (quote_attrib(self.max), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionRangeType', fromsubclass_=False, pretty_print=True):
        super(SetExpressionRangeType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.add('min')
            self.min = value
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            self.max = value
        super(SetExpressionRangeType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SetExpressionRangeType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SetExpressionRangeType


class SetExpressionBooleanType(SetExpressionBaseType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SetExpressionBaseType
    def __init__(self, value=None, value_attr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("SetExpressionBooleanType"), self).__init__(value,  **kwargs_)
        self.value_attr = _cast(None, value_attr)
        self.value_attr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetExpressionBooleanType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetExpressionBooleanType.subclass:
            return SetExpressionBooleanType.subclass(*args_, **kwargs_)
        else:
            return SetExpressionBooleanType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value_attr(self):
        return self.value_attr
    def set_value_attr(self, value_attr):
        self.value_attr = value_attr
    def has__content(self):
        if (
            super(SetExpressionBooleanType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionBooleanType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetExpressionBooleanType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SetExpressionBooleanType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionBooleanType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetExpressionBooleanType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='SetExpressionBooleanType'):
        super(SetExpressionBooleanType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetExpressionBooleanType')
        if self.value_attr is not None and 'value_attr' not in already_processed:
            already_processed.add('value_attr')
            outfile.write(' value=%s' % (quote_attrib(self.value_attr), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SetExpressionBooleanType', fromsubclass_=False, pretty_print=True):
        super(SetExpressionBooleanType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value_attr' not in already_processed:
            already_processed.add('value_attr')
            self.value_attr = value
        super(SetExpressionBooleanType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SetExpressionBooleanType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SetExpressionBooleanType


class VariableSetType(GeneratedsSuper):
    """expression -- The expression element provides a substitution for a variety
    of expressions that can be used to compute a variable value.  Each expression
    must be evaluated in order until one expression matches.  The computed value
    of the set is the value of first expression that matches.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, expression=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if expression is None:
            self.expression = []
        else:
            self.expression = expression
        self.expression_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableSetType.subclass:
            return VariableSetType.subclass(*args_, **kwargs_)
        else:
            return VariableSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_expression(self):
        return self.expression
    def set_expression(self, expression):
        self.expression = expression
    def add_expression(self, value):
        self.expression.append(value)
    def insert_expression_at(self, index, value):
        self.expression.insert(index, value)
    def replace_expression_at(self, index, value):
        self.expression[index] = value
    def has__content(self):
        if (
            self.expression
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='VariableSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariableSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableSetType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariableSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='VariableSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='VariableSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for expression_ in self.expression:
            expression_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'expression':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()["" + type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <expression> element')
            self.expression.append(obj_)
            obj_.original_tagname_ = 'expression'
        elif nodeName_ == 'when_pattern':
            obj_ = SetExpressionPatternType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expression.append(obj_)
            obj_.original_tagname_ = 'when_pattern'
        elif nodeName_ == 'when_choice':
            obj_ = SetExpressionChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expression.append(obj_)
            obj_.original_tagname_ = 'when_choice'
        elif nodeName_ == 'when_range':
            obj_ = SetExpressionRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expression.append(obj_)
            obj_.original_tagname_ = 'when_range'
        elif nodeName_ == 'when_boolean':
            obj_ = SetExpressionBooleanType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expression.append(obj_)
            obj_.original_tagname_ = 'when_boolean'
# end class VariableSetType


class SubstitutionTextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, var_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubstitutionTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubstitutionTextType.subclass:
            return SubstitutionTextType.subclass(*args_, **kwargs_)
        else:
            return SubstitutionTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def validate_VariableIDPattern(self, value):
        # Validate type inter:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SubstitutionTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubstitutionTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubstitutionTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubstitutionTextType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubstitutionTextType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='SubstitutionTextType'):
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='SubstitutionTextType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SubstitutionTextType


class ReferenceType11(TextType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TextType
    def __init__(self, lang=None, href=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("ReferenceType11"), self).__init__(lang, valueOf_, mixedclass_, content_,  **kwargs_)
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType11.subclass:
            return ReferenceType11.subclass(*args_, **kwargs_)
        else:
            return ReferenceType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(ReferenceType11, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ReferenceType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceType11':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType11')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ReferenceType11'):
        super(ReferenceType11, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType11')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ReferenceType11', fromsubclass_=False, pretty_print=True):
        super(ReferenceType11, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(ReferenceType11, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ReferenceType11


class StepType(GeneratedsSuper):
    """description -- The description element contains information
    about this step.
    reference -- The reference element contains information about
    any external references related to this step.
    step -- The step element contains a substep for this
    step.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, is_done='false', is_required='true', description=None, reference=None, step=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.is_done = _cast(None, is_done)
        self.is_done_nsprefix_ = None
        self.is_required = _cast(None, is_required)
        self.is_required_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = "inter"
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = "inter"
        if step is None:
            self.step = []
        else:
            self.step = step
        self.step_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StepType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StepType.subclass:
            return StepType.subclass(*args_, **kwargs_)
        else:
            return StepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def get_step(self):
        return self.step
    def set_step(self, step):
        self.step = step
    def add_step(self, value):
        self.step.append(value)
    def insert_step_at(self, index, value):
        self.step.insert(index, value)
    def replace_step_at(self, index, value):
        self.step[index] = value
    def get_is_done(self):
        return self.is_done
    def set_is_done(self, is_done):
        self.is_done = is_done
    def get_is_required(self):
        return self.is_required
    def set_is_required(self, is_required):
        self.is_required = is_required
    def has__content(self):
        if (
            self.description is not None or
            self.reference or
            self.step
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='StepType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StepType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StepType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StepType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StepType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='StepType'):
        if self.is_done != "false" and 'is_done' not in already_processed:
            already_processed.add('is_done')
            outfile.write(' is_done=%s' % (quote_attrib(self.is_done), ))
        if self.is_required != "true" and 'is_required' not in already_processed:
            already_processed.add('is_required')
            outfile.write(' is_required=%s' % (quote_attrib(self.is_required), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='StepType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
        for step_ in self.step:
            namespaceprefix_ = self.step_nsprefix_ + ':' if (UseCapturedNS_ and self.step_nsprefix_) else ''
            step_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='step', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('is_done', node)
        if value is not None and 'is_done' not in already_processed:
            already_processed.add('is_done')
            self.is_done = value
        value = find_attr_value_('is_required', node)
        if value is not None and 'is_required' not in already_processed:
            already_processed.add('is_required')
            self.is_required = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'step':
            obj_ = StepType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class StepType


class ItemBaseType(GeneratedsSuper):
    """notes -- An optional set of notes to describe additional
    information.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, revision='0', notes=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.revision = _cast(None, revision)
        self.revision_nsprefix_ = None
        if notes is None:
            self.notes = []
        else:
            self.notes = notes
        self.notes_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemBaseType.subclass:
            return ItemBaseType.subclass(*args_, **kwargs_)
        else:
            return ItemBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_notes(self):
        return self.notes
    def set_notes(self, notes):
        self.notes = notes
    def add_notes(self, value):
        self.notes.append(value)
    def insert_notes_at(self, index, value):
        self.notes.insert(index, value)
    def replace_notes_at(self, index, value):
        self.notes[index] = value
    def get_revision(self):
        return self.revision
    def set_revision(self, revision):
        self.revision = revision
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.notes
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ItemBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ItemBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ItemBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ItemBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ItemBaseType'):
        if self.revision != "0" and 'revision' not in already_processed:
            already_processed.add('revision')
            outfile.write(' revision=%s' % (quote_attrib(self.revision), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='ItemBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notes_ in self.notes:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(notes_), input_name='notes')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('revision', node)
        if value is not None and 'revision' not in already_processed:
            already_processed.add('revision')
            self.revision = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes.append(value_)
            self.notes_nsprefix_ = child_.prefix
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notes.append(obj_)
            obj_.original_tagname_ = 'notes'
# end class ItemBaseType


class NamedItemBaseType(ItemBaseType):
    """name -- The name element holds the name of a target
    (system or user).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ItemBaseType
    def __init__(self, revision='0', notes=None, name=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("NamedItemBaseType"), self).__init__(revision, notes, extensiontype_,  **kwargs_)
        self.name = name
        self.name_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedItemBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedItemBaseType.subclass:
            return NamedItemBaseType.subclass(*args_, **kwargs_)
        else:
            return NamedItemBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.name is not None or
            super(NamedItemBaseType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='NamedItemBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedItemBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NamedItemBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedItemBaseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedItemBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='NamedItemBaseType'):
        super(NamedItemBaseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedItemBaseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='NamedItemBaseType', fromsubclass_=False, pretty_print=True):
        super(NamedItemBaseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NamedItemBaseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        super(NamedItemBaseType, self)._buildChildren(child_, node, nodeName_, True)
# end class NamedItemBaseType


class CompoundTestActionType(ItemBaseType):
    """title -- The title element contains a descriptive
    heading for the set of test_actions.
    description -- The description element holds information
    describing the set of test_actions.
    references -- The references element holds one or more
    reference elements. Examples could include references to
    other standards, including but not limited to CVE, CCE,
    or CPE.
    actions -- The actions element holds one or more
    test_action elements along with the operators used to combine
    them into a single result.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ItemBaseType
    def __init__(self, revision='0', notes=None, title=None, description=None, references=None, actions=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("CompoundTestActionType"), self).__init__(revision, notes, extensiontype_,  **kwargs_)
        self.title = title
        self.title_nsprefix_ = "inter"
        self.description = description
        self.description_nsprefix_ = "inter"
        self.references = references
        self.references_nsprefix_ = "inter"
        self.actions = actions
        self.actions_nsprefix_ = "inter"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompoundTestActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundTestActionType.subclass:
            return CompoundTestActionType.subclass(*args_, **kwargs_)
        else:
            return CompoundTestActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def get_actions(self):
        return self.actions
    def set_actions(self, actions):
        self.actions = actions
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.title is not None or
            self.description is not None or
            self.references is not None or
            self.actions is not None or
            super(CompoundTestActionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='CompoundTestActionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompoundTestActionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CompoundTestActionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompoundTestActionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompoundTestActionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='CompoundTestActionType'):
        super(CompoundTestActionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompoundTestActionType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='CompoundTestActionType', fromsubclass_=False, pretty_print=True):
        super(CompoundTestActionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        if self.references is not None:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            self.references.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
        if self.actions is not None:
            namespaceprefix_ = self.actions_nsprefix_ + ':' if (UseCapturedNS_ and self.actions_nsprefix_) else ''
            self.actions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='actions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CompoundTestActionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'references':
            obj_ = ReferencesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references = obj_
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'actions':
            obj_ = OperationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.actions = obj_
            obj_.original_tagname_ = 'actions'
        super(CompoundTestActionType, self)._buildChildren(child_, node, nodeName_, True)
# end class CompoundTestActionType


class ReferencesType12(GeneratedsSuper):
    """reference -- The reference element contains information about
    any external references. Examples could include references to other
    standards such as CVE, CCE, or CPE.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencesType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencesType12.subclass:
            return ReferencesType12.subclass(*args_, **kwargs_)
        else:
            return ReferencesType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def has__content(self):
        if (
            self.reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ReferencesType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferencesType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferencesType12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferencesType12')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferencesType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ReferencesType12'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ReferencesType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
# end class ReferencesType12


class OperationType(GeneratedsSuper):
    """test_action_ref -- The test_action_ref element holds the identifier
    of a test_action element. At least one test_action_ref must be
    included.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, operation='AND', negate='false', test_action_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        self.operation = _cast(None, operation)
        self.operation_nsprefix_ = None
        self.negate = _cast(None, negate)
        self.negate_nsprefix_ = None
        if test_action_ref is None:
            self.test_action_ref = []
        else:
            self.test_action_ref = test_action_ref
        self.test_action_ref_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OperationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OperationType.subclass:
            return OperationType.subclass(*args_, **kwargs_)
        else:
            return OperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_test_action_ref(self):
        return self.test_action_ref
    def set_test_action_ref(self, test_action_ref):
        self.test_action_ref = test_action_ref
    def add_test_action_ref(self, value):
        self.test_action_ref.append(value)
    def insert_test_action_ref_at(self, index, value):
        self.test_action_ref.insert(index, value)
    def replace_test_action_ref_at(self, index, value):
        self.test_action_ref[index] = value
    def get_operation(self):
        return self.operation
    def set_operation(self, operation):
        self.operation = operation
    def get_negate(self):
        return self.negate
    def set_negate(self, negate):
        self.negate = negate
    def validate_OperatorType(self, value):
        # Validate type inter:OperatorType, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['AND', 'OR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OperatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.test_action_ref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='OperationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OperationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OperationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OperationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OperationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='OperationType'):
        if self.operation != "AND" and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
        if self.negate != "false" and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='OperationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for test_action_ref_ in self.test_action_ref:
            namespaceprefix_ = self.test_action_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.test_action_ref_nsprefix_) else ''
            test_action_ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='test_action_ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
            self.validate_OperatorType(self.operation)    # validate type OperatorType
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'test_action_ref':
            obj_ = TestActionRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.test_action_ref.append(obj_)
            obj_.original_tagname_ = 'test_action_ref'
# end class OperationType


class TextType13(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextType13.subclass:
            return TextType13.subclass(*args_, **kwargs_)
        else:
            return TextType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='TextType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextType13':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextType13')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='TextType13'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='TextType13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TextType13


class SignatureType15(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None, Object=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.SignedInfo = SignedInfo
        self.SignedInfo_nsprefix_ = "ds"
        self.SignatureValue = SignatureValue
        self.SignatureValue_nsprefix_ = "ds"
        self.KeyInfo = KeyInfo
        self.KeyInfo_nsprefix_ = "ds"
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
        self.Object_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType15.subclass:
            return SignatureType15.subclass(*args_, **kwargs_)
        else:
            return SignatureType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SignedInfo(self):
        return self.SignedInfo
    def set_SignedInfo(self, SignedInfo):
        self.SignedInfo = SignedInfo
    def get_SignatureValue(self):
        return self.SignatureValue
    def set_SignatureValue(self, SignatureValue):
        self.SignatureValue = SignatureValue
    def get_KeyInfo(self):
        return self.KeyInfo
    def set_KeyInfo(self, KeyInfo):
        self.KeyInfo = KeyInfo
    def get_Object(self):
        return self.Object
    def set_Object(self, Object):
        self.Object = Object
    def add_Object(self, value):
        self.Object.append(value)
    def insert_Object_at(self, index, value):
        self.Object.insert(index, value)
    def replace_Object_at(self, index, value):
        self.Object[index] = value
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def has__content(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None or
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignatureType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureType15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureType15')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignatureType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureType15'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignatureType15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            namespaceprefix_ = self.SignedInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.SignedInfo_nsprefix_) else ''
            self.SignedInfo.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            namespaceprefix_ = self.SignatureValue_nsprefix_ + ':' if (UseCapturedNS_ and self.SignatureValue_nsprefix_) else ''
            self.SignatureValue.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            namespaceprefix_ = self.KeyInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.KeyInfo_nsprefix_) else ''
            self.KeyInfo.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='KeyInfo', pretty_print=pretty_print)
        for Object_ in self.Object:
            namespaceprefix_ = self.Object_nsprefix_ + ':' if (UseCapturedNS_ and self.Object_nsprefix_) else ''
            Object_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Object', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
        elif nodeName_ == 'Object':
            obj_ = ObjectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Object.append(obj_)
            obj_.original_tagname_ = 'Object'
# end class SignatureType15


class SignatureValueType16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType16.subclass:
            return SignatureValueType16.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"', name_='SignatureValueType16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureValueType16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureValueType16')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureValueType16'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"', name_='SignatureValueType16', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SignatureValueType16


class SignedInfoType17(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.CanonicalizationMethod = CanonicalizationMethod
        self.CanonicalizationMethod_nsprefix_ = "ds"
        self.SignatureMethod = SignatureMethod
        self.SignatureMethod_nsprefix_ = "ds"
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType17.subclass:
            return SignedInfoType17.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CanonicalizationMethod(self):
        return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod):
        self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self):
        return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod):
        self.SignatureMethod = SignatureMethod
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def has__content(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignedInfoType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignedInfoType17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignedInfoType17')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignedInfoType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignedInfoType17'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignedInfoType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            namespaceprefix_ = self.CanonicalizationMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.CanonicalizationMethod_nsprefix_) else ''
            self.CanonicalizationMethod.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            namespaceprefix_ = self.SignatureMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.SignatureMethod_nsprefix_) else ''
            self.SignatureMethod.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignatureMethod', pretty_print=pretty_print)
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType17


class CanonicalizationMethodType18(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType18.subclass:
            return CanonicalizationMethodType18.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='CanonicalizationMethodType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CanonicalizationMethodType18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CanonicalizationMethodType18')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='CanonicalizationMethodType18'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='CanonicalizationMethodType18', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class CanonicalizationMethodType18


class SignatureMethodType19(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, HMACOutputLength=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        self.HMACOutputLength = HMACOutputLength
        self.validate_HMACOutputLengthType(self.HMACOutputLength)
        self.HMACOutputLength_nsprefix_ = "ds"
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType19.subclass:
            return SignatureMethodType19.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HMACOutputLength(self):
        return self.HMACOutputLength
    def set_HMACOutputLength(self, HMACOutputLength):
        self.HMACOutputLength = HMACOutputLength
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HMACOutputLengthType(self, value):
        result = True
        # Validate type HMACOutputLengthType, a restriction on integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def has__content(self):
        if (
            self.HMACOutputLength is not None or
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SignatureMethodType19', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureMethodType19':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureMethodType19')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureMethodType19'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SignatureMethodType19', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HMACOutputLength is not None:
            namespaceprefix_ = self.HMACOutputLength_nsprefix_ + ':' if (UseCapturedNS_ and self.HMACOutputLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHMACOutputLength>%s</%sHMACOutputLength>%s' % (namespaceprefix_ , self.gds_format_integer(self.HMACOutputLength, input_name='HMACOutputLength'), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HMACOutputLength' and child_.text is not None:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'HMACOutputLength')
            ival_ = self.gds_validate_integer(ival_, node, 'HMACOutputLength')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeInteger, 'HMACOutputLength', ival_)
            self.content_.append(obj_)
            self.HMACOutputLength_nsprefix_ = child_.prefix
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignatureMethodType19


class ReferenceType20(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.URI = _cast(None, URI)
        self.URI_nsprefix_ = None
        self.Type = _cast(None, Type)
        self.Type_nsprefix_ = None
        self.Transforms = Transforms
        self.Transforms_nsprefix_ = "ds"
        self.DigestMethod = DigestMethod
        self.DigestMethod_nsprefix_ = "ds"
        self.DigestValue = DigestValue
        self.DigestValue_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType20.subclass:
            return ReferenceType20.subclass(*args_, **kwargs_)
        else:
            return ReferenceType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Transforms(self):
        return self.Transforms
    def set_Transforms(self, Transforms):
        self.Transforms = Transforms
    def get_DigestMethod(self):
        return self.DigestMethod
    def set_DigestMethod(self, DigestMethod):
        self.DigestMethod = DigestMethod
    def get_DigestValue(self):
        return self.DigestValue
    def set_DigestValue(self, DigestValue):
        self.DigestValue = DigestValue
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_URI(self):
        return self.URI
    def set_URI(self, URI):
        self.URI = URI
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def has__content(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='ReferenceType20', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceType20':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType20')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ReferenceType20'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='ReferenceType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            namespaceprefix_ = self.Transforms_nsprefix_ + ':' if (UseCapturedNS_ and self.Transforms_nsprefix_) else ''
            self.Transforms.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            namespaceprefix_ = self.DigestMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.DigestMethod_nsprefix_) else ''
            self.DigestMethod.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            namespaceprefix_ = self.DigestValue_nsprefix_ + ':' if (UseCapturedNS_ and self.DigestValue_nsprefix_) else ''
            self.DigestValue.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='DigestValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            obj_ = DigestValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DigestValue = obj_
            obj_.original_tagname_ = 'DigestValue'
# end class ReferenceType20


class TransformsType21(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Transform=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
        self.Transform_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType21.subclass:
            return TransformsType21.subclass(*args_, **kwargs_)
        else:
            return TransformsType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Transform(self):
        return self.Transform
    def set_Transform(self, Transform):
        self.Transform = Transform
    def add_Transform(self, value):
        self.Transform.append(value)
    def insert_Transform_at(self, index, value):
        self.Transform.insert(index, value)
    def replace_Transform_at(self, index, value):
        self.Transform[index] = value
    def has__content(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='TransformsType21', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransformsType21':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformsType21')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransformsType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformsType21'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='TransformsType21', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            namespaceprefix_ = self.Transform_nsprefix_ + ':' if (UseCapturedNS_ and self.Transform_nsprefix_) else ''
            Transform_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Transform', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType21


class TransformType22(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, XPath=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
        self.XPath_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType22.subclass:
            return TransformType22.subclass(*args_, **kwargs_)
        else:
            return TransformType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_XPath(self):
        return self.XPath
    def set_XPath(self, XPath):
        self.XPath = XPath
    def add_XPath(self, value):
        self.XPath.append(value)
    def insert_XPath_at(self, index, value):
        self.XPath.insert(index, value)
    def replace_XPath_at(self, index, value):
        self.XPath[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None or
            self.XPath or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='TransformType22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransformType22':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformType22')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformType22'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='TransformType22', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            namespaceprefix_ = self.XPath_nsprefix_ + ':' if (UseCapturedNS_ and self.XPath_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sXPath>%s</%sXPath>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(XPath_), input_name='XPath')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        elif nodeName_ == 'XPath' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'XPath')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'XPath')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'XPath', valuestr_)
            self.content_.append(obj_)
            self.XPath_nsprefix_ = child_.prefix
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TransformType22


class DigestMethodType23(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType23.subclass:
            return DigestMethodType23.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='DigestMethodType23', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DigestMethodType23':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DigestMethodType23')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='DigestMethodType23'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='DigestMethodType23', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class DigestMethodType23


class KeyInfoType24(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, KeyName=None, KeyValue=None, RetrievalMethod=None, X509Data=None, PGPData=None, SPKIData=None, MgmtData=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        if KeyName is None:
            self.KeyName = []
        else:
            self.KeyName = KeyName
        self.KeyName_nsprefix_ = "ds"
        if KeyValue is None:
            self.KeyValue = []
        else:
            self.KeyValue = KeyValue
        self.KeyValue_nsprefix_ = "ds"
        if RetrievalMethod is None:
            self.RetrievalMethod = []
        else:
            self.RetrievalMethod = RetrievalMethod
        self.RetrievalMethod_nsprefix_ = "ds"
        if X509Data is None:
            self.X509Data = []
        else:
            self.X509Data = X509Data
        self.X509Data_nsprefix_ = "ds"
        if PGPData is None:
            self.PGPData = []
        else:
            self.PGPData = PGPData
        self.PGPData_nsprefix_ = "ds"
        if SPKIData is None:
            self.SPKIData = []
        else:
            self.SPKIData = SPKIData
        self.SPKIData_nsprefix_ = "ds"
        if MgmtData is None:
            self.MgmtData = []
        else:
            self.MgmtData = MgmtData
        self.MgmtData_nsprefix_ = "ds"
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType24.subclass:
            return KeyInfoType24.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_KeyName(self):
        return self.KeyName
    def set_KeyName(self, KeyName):
        self.KeyName = KeyName
    def add_KeyName(self, value):
        self.KeyName.append(value)
    def insert_KeyName_at(self, index, value):
        self.KeyName.insert(index, value)
    def replace_KeyName_at(self, index, value):
        self.KeyName[index] = value
    def get_KeyValue(self):
        return self.KeyValue
    def set_KeyValue(self, KeyValue):
        self.KeyValue = KeyValue
    def add_KeyValue(self, value):
        self.KeyValue.append(value)
    def insert_KeyValue_at(self, index, value):
        self.KeyValue.insert(index, value)
    def replace_KeyValue_at(self, index, value):
        self.KeyValue[index] = value
    def get_RetrievalMethod(self):
        return self.RetrievalMethod
    def set_RetrievalMethod(self, RetrievalMethod):
        self.RetrievalMethod = RetrievalMethod
    def add_RetrievalMethod(self, value):
        self.RetrievalMethod.append(value)
    def insert_RetrievalMethod_at(self, index, value):
        self.RetrievalMethod.insert(index, value)
    def replace_RetrievalMethod_at(self, index, value):
        self.RetrievalMethod[index] = value
    def get_X509Data(self):
        return self.X509Data
    def set_X509Data(self, X509Data):
        self.X509Data = X509Data
    def add_X509Data(self, value):
        self.X509Data.append(value)
    def insert_X509Data_at(self, index, value):
        self.X509Data.insert(index, value)
    def replace_X509Data_at(self, index, value):
        self.X509Data[index] = value
    def get_PGPData(self):
        return self.PGPData
    def set_PGPData(self, PGPData):
        self.PGPData = PGPData
    def add_PGPData(self, value):
        self.PGPData.append(value)
    def insert_PGPData_at(self, index, value):
        self.PGPData.insert(index, value)
    def replace_PGPData_at(self, index, value):
        self.PGPData[index] = value
    def get_SPKIData(self):
        return self.SPKIData
    def set_SPKIData(self, SPKIData):
        self.SPKIData = SPKIData
    def add_SPKIData(self, value):
        self.SPKIData.append(value)
    def insert_SPKIData_at(self, index, value):
        self.SPKIData.insert(index, value)
    def replace_SPKIData_at(self, index, value):
        self.SPKIData[index] = value
    def get_MgmtData(self):
        return self.MgmtData
    def set_MgmtData(self, MgmtData):
        self.MgmtData = MgmtData
    def add_MgmtData(self, value):
        self.MgmtData.append(value)
    def insert_MgmtData_at(self, index, value):
        self.MgmtData.insert(index, value)
    def replace_MgmtData_at(self, index, value):
        self.MgmtData[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.KeyName or
            self.KeyValue or
            self.RetrievalMethod or
            self.X509Data or
            self.PGPData or
            self.SPKIData or
            self.MgmtData or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='KeyInfoType24', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KeyInfoType24':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyInfoType24')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='KeyInfoType24'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='KeyInfoType24', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for KeyName_ in self.KeyName:
            namespaceprefix_ = self.KeyName_nsprefix_ + ':' if (UseCapturedNS_ and self.KeyName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyName>%s</%sKeyName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(KeyName_), input_name='KeyName')), namespaceprefix_ , eol_))
        for KeyValue_ in self.KeyValue:
            namespaceprefix_ = self.KeyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.KeyValue_nsprefix_) else ''
            KeyValue_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='KeyValue', pretty_print=pretty_print)
        for RetrievalMethod_ in self.RetrievalMethod:
            namespaceprefix_ = self.RetrievalMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.RetrievalMethod_nsprefix_) else ''
            RetrievalMethod_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='RetrievalMethod', pretty_print=pretty_print)
        for X509Data_ in self.X509Data:
            namespaceprefix_ = self.X509Data_nsprefix_ + ':' if (UseCapturedNS_ and self.X509Data_nsprefix_) else ''
            X509Data_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='X509Data', pretty_print=pretty_print)
        for PGPData_ in self.PGPData:
            namespaceprefix_ = self.PGPData_nsprefix_ + ':' if (UseCapturedNS_ and self.PGPData_nsprefix_) else ''
            PGPData_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='PGPData', pretty_print=pretty_print)
        for SPKIData_ in self.SPKIData:
            namespaceprefix_ = self.SPKIData_nsprefix_ + ':' if (UseCapturedNS_ and self.SPKIData_nsprefix_) else ''
            SPKIData_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SPKIData', pretty_print=pretty_print)
        for MgmtData_ in self.MgmtData:
            namespaceprefix_ = self.MgmtData_nsprefix_ + ':' if (UseCapturedNS_ and self.MgmtData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMgmtData>%s</%sMgmtData>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(MgmtData_), input_name='MgmtData')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'KeyName' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'KeyName')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'KeyName')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'KeyName', valuestr_)
            self.content_.append(obj_)
            self.KeyName_nsprefix_ = child_.prefix
        elif nodeName_ == 'KeyValue':
            obj_ = KeyValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'KeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_KeyValue'):
              self.add_KeyValue(obj_.value)
            elif hasattr(self, 'set_KeyValue'):
              self.set_KeyValue(obj_.value)
        elif nodeName_ == 'RetrievalMethod':
            obj_ = RetrievalMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RetrievalMethod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_RetrievalMethod'):
              self.add_RetrievalMethod(obj_.value)
            elif hasattr(self, 'set_RetrievalMethod'):
              self.set_RetrievalMethod(obj_.value)
        elif nodeName_ == 'X509Data':
            obj_ = X509DataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'X509Data', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_X509Data'):
              self.add_X509Data(obj_.value)
            elif hasattr(self, 'set_X509Data'):
              self.set_X509Data(obj_.value)
        elif nodeName_ == 'PGPData':
            obj_ = PGPDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'PGPData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_PGPData'):
              self.add_PGPData(obj_.value)
            elif hasattr(self, 'set_PGPData'):
              self.set_PGPData(obj_.value)
        elif nodeName_ == 'SPKIData':
            obj_ = SPKIDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'SPKIData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_SPKIData'):
              self.add_SPKIData(obj_.value)
            elif hasattr(self, 'set_SPKIData'):
              self.set_SPKIData(obj_.value)
        elif nodeName_ == 'MgmtData' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'MgmtData')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'MgmtData')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'MgmtData', valuestr_)
            self.content_.append(obj_)
            self.MgmtData_nsprefix_ = child_.prefix
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyInfoType24


class KeyValueType25(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DSAKeyValue=None, RSAKeyValue=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DSAKeyValue = DSAKeyValue
        self.DSAKeyValue_nsprefix_ = "ds"
        self.RSAKeyValue = RSAKeyValue
        self.RSAKeyValue_nsprefix_ = "ds"
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyValueType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyValueType25.subclass:
            return KeyValueType25.subclass(*args_, **kwargs_)
        else:
            return KeyValueType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DSAKeyValue(self):
        return self.DSAKeyValue
    def set_DSAKeyValue(self, DSAKeyValue):
        self.DSAKeyValue = DSAKeyValue
    def get_RSAKeyValue(self):
        return self.RSAKeyValue
    def set_RSAKeyValue(self, RSAKeyValue):
        self.RSAKeyValue = RSAKeyValue
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.DSAKeyValue is not None or
            self.RSAKeyValue is not None or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='KeyValueType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyValueType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KeyValueType25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyValueType25')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='KeyValueType25'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='KeyValueType25', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DSAKeyValue is not None:
            namespaceprefix_ = self.DSAKeyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.DSAKeyValue_nsprefix_) else ''
            self.DSAKeyValue.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='DSAKeyValue', pretty_print=pretty_print)
        if self.RSAKeyValue is not None:
            namespaceprefix_ = self.RSAKeyValue_nsprefix_ + ':' if (UseCapturedNS_ and self.RSAKeyValue_nsprefix_) else ''
            self.RSAKeyValue.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='RSAKeyValue', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DSAKeyValue':
            obj_ = DSAKeyValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'DSAKeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_DSAKeyValue'):
              self.add_DSAKeyValue(obj_.value)
            elif hasattr(self, 'set_DSAKeyValue'):
              self.set_DSAKeyValue(obj_.value)
        elif nodeName_ == 'RSAKeyValue':
            obj_ = RSAKeyValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RSAKeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_RSAKeyValue'):
              self.add_RSAKeyValue(obj_.value)
            elif hasattr(self, 'set_RSAKeyValue'):
              self.set_RSAKeyValue(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyValueType25


class RetrievalMethodType26(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, URI=None, Type=None, Transforms=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.URI = _cast(None, URI)
        self.URI_nsprefix_ = None
        self.Type = _cast(None, Type)
        self.Type_nsprefix_ = None
        self.Transforms = Transforms
        self.Transforms_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetrievalMethodType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetrievalMethodType26.subclass:
            return RetrievalMethodType26.subclass(*args_, **kwargs_)
        else:
            return RetrievalMethodType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Transforms(self):
        return self.Transforms
    def set_Transforms(self, Transforms):
        self.Transforms = Transforms
    def get_URI(self):
        return self.URI
    def set_URI(self, URI):
        self.URI = URI
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def has__content(self):
        if (
            self.Transforms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='RetrievalMethodType26', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RetrievalMethodType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RetrievalMethodType26':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RetrievalMethodType26')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RetrievalMethodType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='RetrievalMethodType26'):
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='RetrievalMethodType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            namespaceprefix_ = self.Transforms_nsprefix_ + ':' if (UseCapturedNS_ and self.Transforms_nsprefix_) else ''
            self.Transforms.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Transforms', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
# end class RetrievalMethodType26


class X509DataType27(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, X509IssuerSerial=None, X509SKI=None, X509SubjectName=None, X509Certificate=None, X509CRL=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if X509IssuerSerial is None:
            self.X509IssuerSerial = []
        else:
            self.X509IssuerSerial = X509IssuerSerial
        self.X509IssuerSerial_nsprefix_ = "ds"
        if X509SKI is None:
            self.X509SKI = []
        else:
            self.X509SKI = X509SKI
        self.X509SKI_nsprefix_ = None
        if X509SubjectName is None:
            self.X509SubjectName = []
        else:
            self.X509SubjectName = X509SubjectName
        self.X509SubjectName_nsprefix_ = None
        if X509Certificate is None:
            self.X509Certificate = []
        else:
            self.X509Certificate = X509Certificate
        self.X509Certificate_nsprefix_ = None
        if X509CRL is None:
            self.X509CRL = []
        else:
            self.X509CRL = X509CRL
        self.X509CRL_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType27.subclass:
            return X509DataType27.subclass(*args_, **kwargs_)
        else:
            return X509DataType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X509IssuerSerial(self):
        return self.X509IssuerSerial
    def set_X509IssuerSerial(self, X509IssuerSerial):
        self.X509IssuerSerial = X509IssuerSerial
    def add_X509IssuerSerial(self, value):
        self.X509IssuerSerial.append(value)
    def insert_X509IssuerSerial_at(self, index, value):
        self.X509IssuerSerial.insert(index, value)
    def replace_X509IssuerSerial_at(self, index, value):
        self.X509IssuerSerial[index] = value
    def get_X509SKI(self):
        return self.X509SKI
    def set_X509SKI(self, X509SKI):
        self.X509SKI = X509SKI
    def add_X509SKI(self, value):
        self.X509SKI.append(value)
    def insert_X509SKI_at(self, index, value):
        self.X509SKI.insert(index, value)
    def replace_X509SKI_at(self, index, value):
        self.X509SKI[index] = value
    def get_X509SubjectName(self):
        return self.X509SubjectName
    def set_X509SubjectName(self, X509SubjectName):
        self.X509SubjectName = X509SubjectName
    def add_X509SubjectName(self, value):
        self.X509SubjectName.append(value)
    def insert_X509SubjectName_at(self, index, value):
        self.X509SubjectName.insert(index, value)
    def replace_X509SubjectName_at(self, index, value):
        self.X509SubjectName[index] = value
    def get_X509Certificate(self):
        return self.X509Certificate
    def set_X509Certificate(self, X509Certificate):
        self.X509Certificate = X509Certificate
    def add_X509Certificate(self, value):
        self.X509Certificate.append(value)
    def insert_X509Certificate_at(self, index, value):
        self.X509Certificate.insert(index, value)
    def replace_X509Certificate_at(self, index, value):
        self.X509Certificate[index] = value
    def get_X509CRL(self):
        return self.X509CRL
    def set_X509CRL(self, X509CRL):
        self.X509CRL = X509CRL
    def add_X509CRL(self, value):
        self.X509CRL.append(value)
    def insert_X509CRL_at(self, index, value):
        self.X509CRL.insert(index, value)
    def replace_X509CRL_at(self, index, value):
        self.X509CRL[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def has__content(self):
        if (
            self.X509IssuerSerial or
            self.X509SKI or
            self.X509SubjectName or
            self.X509Certificate or
            self.X509CRL or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='X509DataType27', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType27')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'X509DataType27':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509DataType27')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='X509DataType27', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='X509DataType27'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='X509DataType27', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for X509IssuerSerial_ in self.X509IssuerSerial:
            namespaceprefix_ = self.X509IssuerSerial_nsprefix_ + ':' if (UseCapturedNS_ and self.X509IssuerSerial_nsprefix_) else ''
            X509IssuerSerial_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X509IssuerSerial', pretty_print=pretty_print)
        for X509SKI_ in self.X509SKI:
            namespaceprefix_ = self.X509SKI_nsprefix_ + ':' if (UseCapturedNS_ and self.X509SKI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SKI>%s</%sX509SKI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(X509SKI_), input_name='X509SKI')), namespaceprefix_ , eol_))
        for X509SubjectName_ in self.X509SubjectName:
            namespaceprefix_ = self.X509SubjectName_nsprefix_ + ':' if (UseCapturedNS_ and self.X509SubjectName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SubjectName>%s</%sX509SubjectName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(X509SubjectName_), input_name='X509SubjectName')), namespaceprefix_ , eol_))
        for X509Certificate_ in self.X509Certificate:
            namespaceprefix_ = self.X509Certificate_nsprefix_ + ':' if (UseCapturedNS_ and self.X509Certificate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509Certificate>%s</%sX509Certificate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(X509Certificate_), input_name='X509Certificate')), namespaceprefix_ , eol_))
        for X509CRL_ in self.X509CRL:
            namespaceprefix_ = self.X509CRL_nsprefix_ + ':' if (UseCapturedNS_ and self.X509CRL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509CRL>%s</%sX509CRL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(X509CRL_), input_name='X509CRL')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X509IssuerSerial':
            obj_ = X509IssuerSerialType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X509IssuerSerial.append(obj_)
            obj_.original_tagname_ = 'X509IssuerSerial'
        elif nodeName_ == 'X509SKI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509SKI')
            value_ = self.gds_validate_string(value_, node, 'X509SKI')
            self.X509SKI.append(value_)
            self.X509SKI_nsprefix_ = child_.prefix
        elif nodeName_ == 'X509SubjectName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509SubjectName')
            value_ = self.gds_validate_string(value_, node, 'X509SubjectName')
            self.X509SubjectName.append(value_)
            self.X509SubjectName_nsprefix_ = child_.prefix
        elif nodeName_ == 'X509Certificate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509Certificate')
            value_ = self.gds_validate_string(value_, node, 'X509Certificate')
            self.X509Certificate.append(value_)
            self.X509Certificate_nsprefix_ = child_.prefix
        elif nodeName_ == 'X509CRL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509CRL')
            value_ = self.gds_validate_string(value_, node, 'X509CRL')
            self.X509CRL.append(value_)
            self.X509CRL_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'X509DataType27')
            self.set_anytypeobjs_(content_)
# end class X509DataType27


class X509IssuerSerialType28(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, X509IssuerName=None, X509SerialNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.X509IssuerName = X509IssuerName
        self.X509IssuerName_nsprefix_ = None
        self.X509SerialNumber = X509SerialNumber
        self.X509SerialNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509IssuerSerialType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509IssuerSerialType28.subclass:
            return X509IssuerSerialType28.subclass(*args_, **kwargs_)
        else:
            return X509IssuerSerialType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X509IssuerName(self):
        return self.X509IssuerName
    def set_X509IssuerName(self, X509IssuerName):
        self.X509IssuerName = X509IssuerName
    def get_X509SerialNumber(self):
        return self.X509SerialNumber
    def set_X509SerialNumber(self, X509SerialNumber):
        self.X509SerialNumber = X509SerialNumber
    def has__content(self):
        if (
            self.X509IssuerName is not None or
            self.X509SerialNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='X509IssuerSerialType28', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509IssuerSerialType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'X509IssuerSerialType28':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509IssuerSerialType28')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='X509IssuerSerialType28', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='X509IssuerSerialType28'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='X509IssuerSerialType28', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509IssuerName is not None:
            namespaceprefix_ = self.X509IssuerName_nsprefix_ + ':' if (UseCapturedNS_ and self.X509IssuerName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509IssuerName>%s</%sX509IssuerName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.X509IssuerName), input_name='X509IssuerName')), namespaceprefix_ , eol_))
        if self.X509SerialNumber is not None:
            namespaceprefix_ = self.X509SerialNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.X509SerialNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509SerialNumber>%s</%sX509SerialNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.X509SerialNumber), input_name='X509SerialNumber')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X509IssuerName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509IssuerName')
            value_ = self.gds_validate_string(value_, node, 'X509IssuerName')
            self.X509IssuerName = value_
            self.X509IssuerName_nsprefix_ = child_.prefix
        elif nodeName_ == 'X509SerialNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509SerialNumber')
            value_ = self.gds_validate_string(value_, node, 'X509SerialNumber')
            self.X509SerialNumber = value_
            self.X509SerialNumber_nsprefix_ = child_.prefix
# end class X509IssuerSerialType28


class PGPDataType29(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PGPKeyID=None, PGPKeyPacket=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PGPKeyID = PGPKeyID
        self.PGPKeyID_nsprefix_ = None
        self.PGPKeyPacket = PGPKeyPacket
        self.PGPKeyPacket_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PGPDataType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PGPDataType29.subclass:
            return PGPDataType29.subclass(*args_, **kwargs_)
        else:
            return PGPDataType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PGPKeyID(self):
        return self.PGPKeyID
    def set_PGPKeyID(self, PGPKeyID):
        self.PGPKeyID = PGPKeyID
    def get_PGPKeyPacket(self):
        return self.PGPKeyPacket
    def set_PGPKeyPacket(self, PGPKeyPacket):
        self.PGPKeyPacket = PGPKeyPacket
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def has__content(self):
        if (
            self.PGPKeyID is not None or
            self.PGPKeyPacket is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='PGPDataType29', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PGPDataType29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PGPDataType29':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PGPDataType29')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PGPDataType29', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='PGPDataType29'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='PGPDataType29', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PGPKeyID is not None:
            namespaceprefix_ = self.PGPKeyID_nsprefix_ + ':' if (UseCapturedNS_ and self.PGPKeyID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPGPKeyID>%s</%sPGPKeyID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyID), input_name='PGPKeyID')), namespaceprefix_ , eol_))
        if self.PGPKeyPacket is not None:
            namespaceprefix_ = self.PGPKeyPacket_nsprefix_ + ':' if (UseCapturedNS_ and self.PGPKeyPacket_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPGPKeyPacket>%s</%sPGPKeyPacket>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyPacket), input_name='PGPKeyPacket')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PGPKeyID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PGPKeyID')
            value_ = self.gds_validate_string(value_, node, 'PGPKeyID')
            self.PGPKeyID = value_
            self.PGPKeyID_nsprefix_ = child_.prefix
        elif nodeName_ == 'PGPKeyPacket':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PGPKeyPacket')
            value_ = self.gds_validate_string(value_, node, 'PGPKeyPacket')
            self.PGPKeyPacket = value_
            self.PGPKeyPacket_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'PGPDataType29')
            self.anytypeobjs_.append(content_)
# end class PGPDataType29


class SPKIDataType30(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SPKISexp=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SPKISexp is None:
            self.SPKISexp = []
        else:
            self.SPKISexp = SPKISexp
        self.SPKISexp_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPKIDataType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPKIDataType30.subclass:
            return SPKIDataType30.subclass(*args_, **kwargs_)
        else:
            return SPKIDataType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SPKISexp(self):
        return self.SPKISexp
    def set_SPKISexp(self, SPKISexp):
        self.SPKISexp = SPKISexp
    def add_SPKISexp(self, value):
        self.SPKISexp.append(value)
    def insert_SPKISexp_at(self, index, value):
        self.SPKISexp.insert(index, value)
    def replace_SPKISexp_at(self, index, value):
        self.SPKISexp[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def has__content(self):
        if (
            self.SPKISexp or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SPKIDataType30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SPKIDataType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SPKIDataType30':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SPKIDataType30')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SPKIDataType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SPKIDataType30'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SPKIDataType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SPKISexp_ in self.SPKISexp:
            namespaceprefix_ = self.SPKISexp_nsprefix_ + ':' if (UseCapturedNS_ and self.SPKISexp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPKISexp>%s</%sSPKISexp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(SPKISexp_), input_name='SPKISexp')), namespaceprefix_ , eol_))
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SPKISexp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SPKISexp')
            value_ = self.gds_validate_string(value_, node, 'SPKISexp')
            self.SPKISexp.append(value_)
            self.SPKISexp_nsprefix_ = child_.prefix
        else:
            content_ = self.gds_build_any(child_, 'SPKIDataType30')
            self.set_anytypeobjs_(content_)
# end class SPKIDataType30


class ObjectType31(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, MimeType=None, Encoding=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.MimeType = _cast(None, MimeType)
        self.MimeType_nsprefix_ = None
        self.Encoding = _cast(None, Encoding)
        self.Encoding_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectType31.subclass:
            return ObjectType31.subclass(*args_, **kwargs_)
        else:
            return ObjectType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_MimeType(self):
        return self.MimeType
    def set_MimeType(self, MimeType):
        self.MimeType = MimeType
    def get_Encoding(self):
        return self.Encoding
    def set_Encoding(self, Encoding):
        self.Encoding = Encoding
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ObjectType31', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjectType31':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectType31')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ObjectType31'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.MimeType is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            outfile.write(' MimeType=%s' % (quote_attrib(self.MimeType), ))
        if self.Encoding is not None and 'Encoding' not in already_processed:
            already_processed.add('Encoding')
            outfile.write(' Encoding=%s' % (quote_attrib(self.Encoding), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='ObjectType31', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('MimeType', node)
        if value is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            self.MimeType = value
        value = find_attr_value_('Encoding', node)
        if value is not None and 'Encoding' not in already_processed:
            already_processed.add('Encoding')
            self.Encoding = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ObjectType31


class ManifestType32(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManifestType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManifestType32.subclass:
            return ManifestType32.subclass(*args_, **kwargs_)
        else:
            return ManifestType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def has__content(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='ManifestType32', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManifestType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManifestType32':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManifestType32')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManifestType32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ManifestType32'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='ManifestType32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ManifestType32


class SignaturePropertiesType33(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignatureProperty=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        if SignatureProperty is None:
            self.SignatureProperty = []
        else:
            self.SignatureProperty = SignatureProperty
        self.SignatureProperty_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignaturePropertiesType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignaturePropertiesType33.subclass:
            return SignaturePropertiesType33.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertiesType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SignatureProperty(self):
        return self.SignatureProperty
    def set_SignatureProperty(self, SignatureProperty):
        self.SignatureProperty = SignatureProperty
    def add_SignatureProperty(self, value):
        self.SignatureProperty.append(value)
    def insert_SignatureProperty_at(self, index, value):
        self.SignatureProperty.insert(index, value)
    def replace_SignatureProperty_at(self, index, value):
        self.SignatureProperty[index] = value
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def has__content(self):
        if (
            self.SignatureProperty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignaturePropertiesType33', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignaturePropertiesType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignaturePropertiesType33':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignaturePropertiesType33')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignaturePropertiesType33', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignaturePropertiesType33'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='SignaturePropertiesType33', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SignatureProperty_ in self.SignatureProperty:
            namespaceprefix_ = self.SignatureProperty_nsprefix_ + ':' if (UseCapturedNS_ and self.SignatureProperty_nsprefix_) else ''
            SignatureProperty_.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignatureProperty', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SignatureProperty':
            obj_ = SignaturePropertyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignatureProperty.append(obj_)
            obj_.original_tagname_ = 'SignatureProperty'
# end class SignaturePropertiesType33


class SignaturePropertyType34(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Target=None, Id=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Target = _cast(None, Target)
        self.Target_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignaturePropertyType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignaturePropertyType34.subclass:
            return SignaturePropertyType34.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertyType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Target(self):
        return self.Target
    def set_Target(self, Target):
        self.Target = Target
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SignaturePropertyType34', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignaturePropertyType34')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignaturePropertyType34':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignaturePropertyType34')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignaturePropertyType34'):
        if self.Target is not None and 'Target' not in already_processed:
            already_processed.add('Target')
            outfile.write(' Target=%s' % (quote_attrib(self.Target), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='SignaturePropertyType34', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Target', node)
        if value is not None and 'Target' not in already_processed:
            already_processed.add('Target')
            self.Target = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignaturePropertyType34


class DSAKeyValueType35(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, P=None, Q=None, G=None, Y=None, J=None, Seed=None, PgenCounter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.P = P
        self.validate_CryptoBinary(self.P)
        self.P_nsprefix_ = "ds"
        self.Q = Q
        self.validate_CryptoBinary(self.Q)
        self.Q_nsprefix_ = "ds"
        self.G = G
        self.validate_CryptoBinary(self.G)
        self.G_nsprefix_ = "ds"
        self.Y = Y
        self.validate_CryptoBinary(self.Y)
        self.Y_nsprefix_ = "ds"
        self.J = J
        self.validate_CryptoBinary(self.J)
        self.J_nsprefix_ = "ds"
        self.Seed = Seed
        self.validate_CryptoBinary(self.Seed)
        self.Seed_nsprefix_ = "ds"
        self.PgenCounter = PgenCounter
        self.validate_CryptoBinary(self.PgenCounter)
        self.PgenCounter_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DSAKeyValueType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DSAKeyValueType35.subclass:
            return DSAKeyValueType35.subclass(*args_, **kwargs_)
        else:
            return DSAKeyValueType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_P(self):
        return self.P
    def set_P(self, P):
        self.P = P
    def get_Q(self):
        return self.Q
    def set_Q(self, Q):
        self.Q = Q
    def get_G(self):
        return self.G
    def set_G(self, G):
        self.G = G
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_J(self):
        return self.J
    def set_J(self, J):
        self.J = J
    def get_Seed(self):
        return self.Seed
    def set_Seed(self, Seed):
        self.Seed = Seed
    def get_PgenCounter(self):
        return self.PgenCounter
    def set_PgenCounter(self, PgenCounter):
        self.PgenCounter = PgenCounter
    def validate_CryptoBinary(self, value):
        result = True
        # Validate type CryptoBinary, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def has__content(self):
        if (
            self.P is not None or
            self.Q is not None or
            self.G is not None or
            self.Y is not None or
            self.J is not None or
            self.Seed is not None or
            self.PgenCounter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='DSAKeyValueType35', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DSAKeyValueType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DSAKeyValueType35':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DSAKeyValueType35')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DSAKeyValueType35', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='DSAKeyValueType35'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='DSAKeyValueType35', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.P is not None:
            namespaceprefix_ = self.P_nsprefix_ + ':' if (UseCapturedNS_ and self.P_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sP>%s</%sP>%s' % (namespaceprefix_ , self.gds_format_base64(self.P, input_name='P'), namespaceprefix_ , eol_))
        if self.Q is not None:
            namespaceprefix_ = self.Q_nsprefix_ + ':' if (UseCapturedNS_ and self.Q_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQ>%s</%sQ>%s' % (namespaceprefix_ , self.gds_format_base64(self.Q, input_name='Q'), namespaceprefix_ , eol_))
        if self.G is not None:
            namespaceprefix_ = self.G_nsprefix_ + ':' if (UseCapturedNS_ and self.G_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sG>%s</%sG>%s' % (namespaceprefix_ , self.gds_format_base64(self.G, input_name='G'), namespaceprefix_ , eol_))
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY>%s</%sY>%s' % (namespaceprefix_ , self.gds_format_base64(self.Y, input_name='Y'), namespaceprefix_ , eol_))
        if self.J is not None:
            namespaceprefix_ = self.J_nsprefix_ + ':' if (UseCapturedNS_ and self.J_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJ>%s</%sJ>%s' % (namespaceprefix_ , self.gds_format_base64(self.J, input_name='J'), namespaceprefix_ , eol_))
        if self.Seed is not None:
            namespaceprefix_ = self.Seed_nsprefix_ + ':' if (UseCapturedNS_ and self.Seed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeed>%s</%sSeed>%s' % (namespaceprefix_ , self.gds_format_base64(self.Seed, input_name='Seed'), namespaceprefix_ , eol_))
        if self.PgenCounter is not None:
            namespaceprefix_ = self.PgenCounter_nsprefix_ + ':' if (UseCapturedNS_ and self.PgenCounter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPgenCounter>%s</%sPgenCounter>%s' % (namespaceprefix_ , self.gds_format_base64(self.PgenCounter, input_name='PgenCounter'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'P':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'P')
            else:
                bval_ = None
            self.P = bval_
            self.P_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.P)
        elif nodeName_ == 'Q':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Q')
            else:
                bval_ = None
            self.Q = bval_
            self.Q_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Q)
        elif nodeName_ == 'G':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'G')
            else:
                bval_ = None
            self.G = bval_
            self.G_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.G)
        elif nodeName_ == 'Y':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Y')
            else:
                bval_ = None
            self.Y = bval_
            self.Y_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Y)
        elif nodeName_ == 'J':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'J')
            else:
                bval_ = None
            self.J = bval_
            self.J_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.J)
        elif nodeName_ == 'Seed':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Seed')
            else:
                bval_ = None
            self.Seed = bval_
            self.Seed_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Seed)
        elif nodeName_ == 'PgenCounter':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'PgenCounter')
            else:
                bval_ = None
            self.PgenCounter = bval_
            self.PgenCounter_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.PgenCounter)
# end class DSAKeyValueType35


class RSAKeyValueType36(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Modulus=None, Exponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "dsig"
        self.Modulus = Modulus
        self.validate_CryptoBinary(self.Modulus)
        self.Modulus_nsprefix_ = "ds"
        self.Exponent = Exponent
        self.validate_CryptoBinary(self.Exponent)
        self.Exponent_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RSAKeyValueType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RSAKeyValueType36.subclass:
            return RSAKeyValueType36.subclass(*args_, **kwargs_)
        else:
            return RSAKeyValueType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Modulus(self):
        return self.Modulus
    def set_Modulus(self, Modulus):
        self.Modulus = Modulus
    def get_Exponent(self):
        return self.Exponent
    def set_Exponent(self, Exponent):
        self.Exponent = Exponent
    def validate_CryptoBinary(self, value):
        result = True
        # Validate type CryptoBinary, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def has__content(self):
        if (
            self.Modulus is not None or
            self.Exponent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='RSAKeyValueType36', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RSAKeyValueType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RSAKeyValueType36':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RSAKeyValueType36')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RSAKeyValueType36', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='RSAKeyValueType36'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2" ', name_='RSAKeyValueType36', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Modulus is not None:
            namespaceprefix_ = self.Modulus_nsprefix_ + ':' if (UseCapturedNS_ and self.Modulus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModulus>%s</%sModulus>%s' % (namespaceprefix_ , self.gds_format_base64(self.Modulus, input_name='Modulus'), namespaceprefix_ , eol_))
        if self.Exponent is not None:
            namespaceprefix_ = self.Exponent_nsprefix_ + ':' if (UseCapturedNS_ and self.Exponent_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExponent>%s</%sExponent>%s' % (namespaceprefix_ , self.gds_format_base64(self.Exponent, input_name='Exponent'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Modulus':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Modulus')
            else:
                bval_ = None
            self.Modulus = bval_
            self.Modulus_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Modulus)
        elif nodeName_ == 'Exponent':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Exponent')
            else:
                bval_ = None
            self.Exponent = bval_
            self.Exponent_nsprefix_ = child_.prefix
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Exponent)
# end class RSAKeyValueType36


class catalog(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, prefer=None, public=None, system=None, uri=None, rewriteSystem=None, rewriteURI=None, uriSuffix=None, systemSuffix=None, delegatePublic=None, delegateSystem=None, delegateURI=None, nextCatalog=None, group=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.prefer = _cast(None, prefer)
        self.prefer_nsprefix_ = None
        if public is None:
            self.public = []
        else:
            self.public = public
        self.public_nsprefix_ = "er"
        if system is None:
            self.system = []
        else:
            self.system = system
        self.system_nsprefix_ = "er"
        if uri is None:
            self.uri = []
        else:
            self.uri = uri
        self.uri_nsprefix_ = "er"
        if rewriteSystem is None:
            self.rewriteSystem = []
        else:
            self.rewriteSystem = rewriteSystem
        self.rewriteSystem_nsprefix_ = "er"
        if rewriteURI is None:
            self.rewriteURI = []
        else:
            self.rewriteURI = rewriteURI
        self.rewriteURI_nsprefix_ = "er"
        if uriSuffix is None:
            self.uriSuffix = []
        else:
            self.uriSuffix = uriSuffix
        self.uriSuffix_nsprefix_ = "er"
        if systemSuffix is None:
            self.systemSuffix = []
        else:
            self.systemSuffix = systemSuffix
        self.systemSuffix_nsprefix_ = "er"
        if delegatePublic is None:
            self.delegatePublic = []
        else:
            self.delegatePublic = delegatePublic
        self.delegatePublic_nsprefix_ = "er"
        if delegateSystem is None:
            self.delegateSystem = []
        else:
            self.delegateSystem = delegateSystem
        self.delegateSystem_nsprefix_ = "er"
        if delegateURI is None:
            self.delegateURI = []
        else:
            self.delegateURI = delegateURI
        self.delegateURI_nsprefix_ = "er"
        if nextCatalog is None:
            self.nextCatalog = []
        else:
            self.nextCatalog = nextCatalog
        self.nextCatalog_nsprefix_ = "er"
        if group is None:
            self.group = []
        else:
            self.group = group
        self.group_nsprefix_ = "er"
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, catalog)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if catalog.subclass:
            return catalog.subclass(*args_, **kwargs_)
        else:
            return catalog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_public(self):
        return self.public
    def set_public(self, public):
        self.public = public
    def add_public(self, value):
        self.public.append(value)
    def insert_public_at(self, index, value):
        self.public.insert(index, value)
    def replace_public_at(self, index, value):
        self.public[index] = value
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def add_system(self, value):
        self.system.append(value)
    def insert_system_at(self, index, value):
        self.system.insert(index, value)
    def replace_system_at(self, index, value):
        self.system[index] = value
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def add_uri(self, value):
        self.uri.append(value)
    def insert_uri_at(self, index, value):
        self.uri.insert(index, value)
    def replace_uri_at(self, index, value):
        self.uri[index] = value
    def get_rewriteSystem(self):
        return self.rewriteSystem
    def set_rewriteSystem(self, rewriteSystem):
        self.rewriteSystem = rewriteSystem
    def add_rewriteSystem(self, value):
        self.rewriteSystem.append(value)
    def insert_rewriteSystem_at(self, index, value):
        self.rewriteSystem.insert(index, value)
    def replace_rewriteSystem_at(self, index, value):
        self.rewriteSystem[index] = value
    def get_rewriteURI(self):
        return self.rewriteURI
    def set_rewriteURI(self, rewriteURI):
        self.rewriteURI = rewriteURI
    def add_rewriteURI(self, value):
        self.rewriteURI.append(value)
    def insert_rewriteURI_at(self, index, value):
        self.rewriteURI.insert(index, value)
    def replace_rewriteURI_at(self, index, value):
        self.rewriteURI[index] = value
    def get_uriSuffix(self):
        return self.uriSuffix
    def set_uriSuffix(self, uriSuffix):
        self.uriSuffix = uriSuffix
    def add_uriSuffix(self, value):
        self.uriSuffix.append(value)
    def insert_uriSuffix_at(self, index, value):
        self.uriSuffix.insert(index, value)
    def replace_uriSuffix_at(self, index, value):
        self.uriSuffix[index] = value
    def get_systemSuffix(self):
        return self.systemSuffix
    def set_systemSuffix(self, systemSuffix):
        self.systemSuffix = systemSuffix
    def add_systemSuffix(self, value):
        self.systemSuffix.append(value)
    def insert_systemSuffix_at(self, index, value):
        self.systemSuffix.insert(index, value)
    def replace_systemSuffix_at(self, index, value):
        self.systemSuffix[index] = value
    def get_delegatePublic(self):
        return self.delegatePublic
    def set_delegatePublic(self, delegatePublic):
        self.delegatePublic = delegatePublic
    def add_delegatePublic(self, value):
        self.delegatePublic.append(value)
    def insert_delegatePublic_at(self, index, value):
        self.delegatePublic.insert(index, value)
    def replace_delegatePublic_at(self, index, value):
        self.delegatePublic[index] = value
    def get_delegateSystem(self):
        return self.delegateSystem
    def set_delegateSystem(self, delegateSystem):
        self.delegateSystem = delegateSystem
    def add_delegateSystem(self, value):
        self.delegateSystem.append(value)
    def insert_delegateSystem_at(self, index, value):
        self.delegateSystem.insert(index, value)
    def replace_delegateSystem_at(self, index, value):
        self.delegateSystem[index] = value
    def get_delegateURI(self):
        return self.delegateURI
    def set_delegateURI(self, delegateURI):
        self.delegateURI = delegateURI
    def add_delegateURI(self, value):
        self.delegateURI.append(value)
    def insert_delegateURI_at(self, index, value):
        self.delegateURI.insert(index, value)
    def replace_delegateURI_at(self, index, value):
        self.delegateURI[index] = value
    def get_nextCatalog(self):
        return self.nextCatalog
    def set_nextCatalog(self, nextCatalog):
        self.nextCatalog = nextCatalog
    def add_nextCatalog(self, value):
        self.nextCatalog.append(value)
    def insert_nextCatalog_at(self, index, value):
        self.nextCatalog.insert(index, value)
    def replace_nextCatalog_at(self, index, value):
        self.nextCatalog[index] = value
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_prefer(self):
        return self.prefer
    def set_prefer(self, prefer):
        self.prefer = prefer
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_systemOrPublic(self, value):
        # Validate type er:systemOrPublic, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'public']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on systemOrPublic' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.public or
            self.system or
            self.uri or
            self.rewriteSystem or
            self.rewriteURI or
            self.uriSuffix or
            self.systemSuffix or
            self.delegatePublic or
            self.delegateSystem or
            self.delegateURI or
            self.nextCatalog or
            self.group or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='catalog', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('catalog')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'catalog':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='catalog')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='catalog', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='catalog'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.prefer is not None and 'prefer' not in already_processed:
            already_processed.add('prefer')
            outfile.write(' prefer=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prefer), input_name='prefer')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='catalog', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for public_ in self.public:
            namespaceprefix_ = self.public_nsprefix_ + ':' if (UseCapturedNS_ and self.public_nsprefix_) else ''
            public_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='public', pretty_print=pretty_print)
        for system_ in self.system:
            namespaceprefix_ = self.system_nsprefix_ + ':' if (UseCapturedNS_ and self.system_nsprefix_) else ''
            system_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='system', pretty_print=pretty_print)
        for uri_ in self.uri:
            namespaceprefix_ = self.uri_nsprefix_ + ':' if (UseCapturedNS_ and self.uri_nsprefix_) else ''
            uri_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='uri', pretty_print=pretty_print)
        for rewriteSystem_ in self.rewriteSystem:
            namespaceprefix_ = self.rewriteSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.rewriteSystem_nsprefix_) else ''
            rewriteSystem_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='rewriteSystem', pretty_print=pretty_print)
        for rewriteURI_ in self.rewriteURI:
            namespaceprefix_ = self.rewriteURI_nsprefix_ + ':' if (UseCapturedNS_ and self.rewriteURI_nsprefix_) else ''
            rewriteURI_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='rewriteURI', pretty_print=pretty_print)
        for uriSuffix_ in self.uriSuffix:
            namespaceprefix_ = self.uriSuffix_nsprefix_ + ':' if (UseCapturedNS_ and self.uriSuffix_nsprefix_) else ''
            uriSuffix_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='uriSuffix', pretty_print=pretty_print)
        for systemSuffix_ in self.systemSuffix:
            namespaceprefix_ = self.systemSuffix_nsprefix_ + ':' if (UseCapturedNS_ and self.systemSuffix_nsprefix_) else ''
            systemSuffix_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='systemSuffix', pretty_print=pretty_print)
        for delegatePublic_ in self.delegatePublic:
            namespaceprefix_ = self.delegatePublic_nsprefix_ + ':' if (UseCapturedNS_ and self.delegatePublic_nsprefix_) else ''
            delegatePublic_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='delegatePublic', pretty_print=pretty_print)
        for delegateSystem_ in self.delegateSystem:
            namespaceprefix_ = self.delegateSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.delegateSystem_nsprefix_) else ''
            delegateSystem_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='delegateSystem', pretty_print=pretty_print)
        for delegateURI_ in self.delegateURI:
            namespaceprefix_ = self.delegateURI_nsprefix_ + ':' if (UseCapturedNS_ and self.delegateURI_nsprefix_) else ''
            delegateURI_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='delegateURI', pretty_print=pretty_print)
        for nextCatalog_ in self.nextCatalog:
            namespaceprefix_ = self.nextCatalog_nsprefix_ + ':' if (UseCapturedNS_ and self.nextCatalog_nsprefix_) else ''
            nextCatalog_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='nextCatalog', pretty_print=pretty_print)
        for group_ in self.group:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            group_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='group', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('prefer', node)
        if value is not None and 'prefer' not in already_processed:
            already_processed.add('prefer')
            self.prefer = value
            self.validate_systemOrPublic(self.prefer)    # validate type systemOrPublic
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'public':
            obj_ = public.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.public.append(obj_)
            obj_.original_tagname_ = 'public'
        elif nodeName_ == 'system':
            obj_ = system.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.system.append(obj_)
            obj_.original_tagname_ = 'system'
        elif nodeName_ == 'uri':
            obj_ = uri.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uri.append(obj_)
            obj_.original_tagname_ = 'uri'
        elif nodeName_ == 'rewriteSystem':
            obj_ = rewriteSystem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rewriteSystem.append(obj_)
            obj_.original_tagname_ = 'rewriteSystem'
        elif nodeName_ == 'rewriteURI':
            obj_ = rewriteURI.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rewriteURI.append(obj_)
            obj_.original_tagname_ = 'rewriteURI'
        elif nodeName_ == 'uriSuffix':
            obj_ = uriSuffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uriSuffix.append(obj_)
            obj_.original_tagname_ = 'uriSuffix'
        elif nodeName_ == 'systemSuffix':
            obj_ = systemSuffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.systemSuffix.append(obj_)
            obj_.original_tagname_ = 'systemSuffix'
        elif nodeName_ == 'delegatePublic':
            obj_ = delegatePublic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delegatePublic.append(obj_)
            obj_.original_tagname_ = 'delegatePublic'
        elif nodeName_ == 'delegateSystem':
            obj_ = delegateSystem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delegateSystem.append(obj_)
            obj_.original_tagname_ = 'delegateSystem'
        elif nodeName_ == 'delegateURI':
            obj_ = delegateURI.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delegateURI.append(obj_)
            obj_.original_tagname_ = 'delegateURI'
        elif nodeName_ == 'nextCatalog':
            obj_ = nextCatalog.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nextCatalog.append(obj_)
            obj_.original_tagname_ = 'nextCatalog'
        elif nodeName_ == 'group':
            obj_ = group.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        else:
            content_ = self.gds_build_any(child_, 'catalog')
            self.set_anytypeobjs_(content_)
# end class catalog


class public(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, publicId=None, uri=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.publicId = _cast(None, publicId)
        self.publicId_nsprefix_ = None
        self.uri = _cast(None, uri)
        self.uri_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, public)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if public.subclass:
            return public.subclass(*args_, **kwargs_)
        else:
            return public(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_publicId(self):
        return self.publicId
    def set_publicId(self, publicId):
        self.publicId = publicId
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_publicIdentifier(self, value):
        # Validate type er:publicIdentifier, a restriction on er:pubIdChars.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_publicIdentifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_publicIdentifier_patterns_, ))
    validate_publicIdentifier_patterns_ = [["^([a-zA-Z0-9\\-'\\(\\)+,./:=?;!*#@$_%]*)$"]]
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='public', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('public')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'public':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='public')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='public', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='public'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.publicId is not None and 'publicId' not in already_processed:
            already_processed.add('publicId')
            outfile.write(' publicId=%s' % (quote_attrib(self.publicId), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='public', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('publicId', node)
        if value is not None and 'publicId' not in already_processed:
            already_processed.add('publicId')
            self.publicId = value
            self.validate_publicIdentifier(self.publicId)    # validate type publicIdentifier
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class public


class system(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, systemId=None, uri=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.systemId = _cast(None, systemId)
        self.systemId_nsprefix_ = None
        self.uri = _cast(None, uri)
        self.uri_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, system)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if system.subclass:
            return system.subclass(*args_, **kwargs_)
        else:
            return system(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_systemId(self):
        return self.systemId
    def set_systemId(self, systemId):
        self.systemId = systemId
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='system', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('system')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'system':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='system')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='system', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='system'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.systemId is not None and 'systemId' not in already_processed:
            already_processed.add('systemId')
            outfile.write(' systemId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.systemId), input_name='systemId')), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='system', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('systemId', node)
        if value is not None and 'systemId' not in already_processed:
            already_processed.add('systemId')
            self.systemId = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class system


class uri(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, uri_member=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.uri = _cast(None, uri_member)
        self.uri_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, uri)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if uri.subclass:
            return uri.subclass(*args_, **kwargs_)
        else:
            return uri(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='uri', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('uri')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'uri':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='uri')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='uri', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='uri'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='uri', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class uri


class rewriteSystem(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, systemIdStartString=None, rewritePrefix=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.systemIdStartString = _cast(None, systemIdStartString)
        self.systemIdStartString_nsprefix_ = None
        self.rewritePrefix = _cast(None, rewritePrefix)
        self.rewritePrefix_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rewriteSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rewriteSystem.subclass:
            return rewriteSystem.subclass(*args_, **kwargs_)
        else:
            return rewriteSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_systemIdStartString(self):
        return self.systemIdStartString
    def set_systemIdStartString(self, systemIdStartString):
        self.systemIdStartString = systemIdStartString
    def get_rewritePrefix(self):
        return self.rewritePrefix
    def set_rewritePrefix(self, rewritePrefix):
        self.rewritePrefix = rewritePrefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='rewriteSystem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rewriteSystem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rewriteSystem':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rewriteSystem')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rewriteSystem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='rewriteSystem'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.systemIdStartString is not None and 'systemIdStartString' not in already_processed:
            already_processed.add('systemIdStartString')
            outfile.write(' systemIdStartString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.systemIdStartString), input_name='systemIdStartString')), ))
        if self.rewritePrefix is not None and 'rewritePrefix' not in already_processed:
            already_processed.add('rewritePrefix')
            outfile.write(' rewritePrefix=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rewritePrefix), input_name='rewritePrefix')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='rewriteSystem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('systemIdStartString', node)
        if value is not None and 'systemIdStartString' not in already_processed:
            already_processed.add('systemIdStartString')
            self.systemIdStartString = value
        value = find_attr_value_('rewritePrefix', node)
        if value is not None and 'rewritePrefix' not in already_processed:
            already_processed.add('rewritePrefix')
            self.rewritePrefix = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class rewriteSystem


class rewriteURI(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uriStartString=None, rewritePrefix=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.uriStartString = _cast(None, uriStartString)
        self.uriStartString_nsprefix_ = None
        self.rewritePrefix = _cast(None, rewritePrefix)
        self.rewritePrefix_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rewriteURI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rewriteURI.subclass:
            return rewriteURI.subclass(*args_, **kwargs_)
        else:
            return rewriteURI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uriStartString(self):
        return self.uriStartString
    def set_uriStartString(self, uriStartString):
        self.uriStartString = uriStartString
    def get_rewritePrefix(self):
        return self.rewritePrefix
    def set_rewritePrefix(self, rewritePrefix):
        self.rewritePrefix = rewritePrefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='rewriteURI', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rewriteURI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rewriteURI':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rewriteURI')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rewriteURI', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='rewriteURI'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.uriStartString is not None and 'uriStartString' not in already_processed:
            already_processed.add('uriStartString')
            outfile.write(' uriStartString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uriStartString), input_name='uriStartString')), ))
        if self.rewritePrefix is not None and 'rewritePrefix' not in already_processed:
            already_processed.add('rewritePrefix')
            outfile.write(' rewritePrefix=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rewritePrefix), input_name='rewritePrefix')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='rewriteURI', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uriStartString', node)
        if value is not None and 'uriStartString' not in already_processed:
            already_processed.add('uriStartString')
            self.uriStartString = value
        value = find_attr_value_('rewritePrefix', node)
        if value is not None and 'rewritePrefix' not in already_processed:
            already_processed.add('rewritePrefix')
            self.rewritePrefix = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class rewriteURI


class systemSuffix(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, systemIdSuffix=None, uri=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.systemIdSuffix = _cast(None, systemIdSuffix)
        self.systemIdSuffix_nsprefix_ = None
        self.uri = _cast(None, uri)
        self.uri_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemSuffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemSuffix.subclass:
            return systemSuffix.subclass(*args_, **kwargs_)
        else:
            return systemSuffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_systemIdSuffix(self):
        return self.systemIdSuffix
    def set_systemIdSuffix(self, systemIdSuffix):
        self.systemIdSuffix = systemIdSuffix
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='systemSuffix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemSuffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'systemSuffix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='systemSuffix')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='systemSuffix', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='systemSuffix'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.systemIdSuffix is not None and 'systemIdSuffix' not in already_processed:
            already_processed.add('systemIdSuffix')
            outfile.write(' systemIdSuffix=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.systemIdSuffix), input_name='systemIdSuffix')), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='systemSuffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('systemIdSuffix', node)
        if value is not None and 'systemIdSuffix' not in already_processed:
            already_processed.add('systemIdSuffix')
            self.systemIdSuffix = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class systemSuffix


class uriSuffix(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uriSuffix_member=None, uri=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.uriSuffix = _cast(None, uriSuffix_member)
        self.uriSuffix_nsprefix_ = None
        self.uri = _cast(None, uri)
        self.uri_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, uriSuffix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if uriSuffix.subclass:
            return uriSuffix.subclass(*args_, **kwargs_)
        else:
            return uriSuffix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uriSuffix(self):
        return self.uriSuffix
    def set_uriSuffix(self, uriSuffix):
        self.uriSuffix = uriSuffix
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='uriSuffix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('uriSuffix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'uriSuffix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='uriSuffix')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='uriSuffix', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='uriSuffix'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.uriSuffix is not None and 'uriSuffix' not in already_processed:
            already_processed.add('uriSuffix')
            outfile.write(' uriSuffix=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uriSuffix), input_name='uriSuffix')), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uri), input_name='uri')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='uriSuffix', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uriSuffix', node)
        if value is not None and 'uriSuffix' not in already_processed:
            already_processed.add('uriSuffix')
            self.uriSuffix = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class uriSuffix


class delegatePublic(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, publicIdStartString=None, catalog=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.publicIdStartString = _cast(None, publicIdStartString)
        self.publicIdStartString_nsprefix_ = None
        self.catalog = _cast(None, catalog)
        self.catalog_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, delegatePublic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if delegatePublic.subclass:
            return delegatePublic.subclass(*args_, **kwargs_)
        else:
            return delegatePublic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_publicIdStartString(self):
        return self.publicIdStartString
    def set_publicIdStartString(self, publicIdStartString):
        self.publicIdStartString = publicIdStartString
    def get_catalog(self):
        return self.catalog
    def set_catalog(self, catalog):
        self.catalog = catalog
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_partialPublicIdentifier(self, value):
        # Validate type er:partialPublicIdentifier, a restriction on er:pubIdChars.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_partialPublicIdentifier_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_partialPublicIdentifier_patterns_, ))
    validate_partialPublicIdentifier_patterns_ = [["^([a-zA-Z0-9\\-'\\(\\)+,./:=?;!*#@$_%]*)$"]]
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='delegatePublic', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('delegatePublic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'delegatePublic':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='delegatePublic')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='delegatePublic', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='delegatePublic'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.publicIdStartString is not None and 'publicIdStartString' not in already_processed:
            already_processed.add('publicIdStartString')
            outfile.write(' publicIdStartString=%s' % (quote_attrib(self.publicIdStartString), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.catalog), input_name='catalog')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='delegatePublic', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('publicIdStartString', node)
        if value is not None and 'publicIdStartString' not in already_processed:
            already_processed.add('publicIdStartString')
            self.publicIdStartString = value
            self.validate_partialPublicIdentifier(self.publicIdStartString)    # validate type partialPublicIdentifier
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class delegatePublic


class delegateSystem(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, systemIdStartString=None, catalog=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.systemIdStartString = _cast(None, systemIdStartString)
        self.systemIdStartString_nsprefix_ = None
        self.catalog = _cast(None, catalog)
        self.catalog_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, delegateSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if delegateSystem.subclass:
            return delegateSystem.subclass(*args_, **kwargs_)
        else:
            return delegateSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_systemIdStartString(self):
        return self.systemIdStartString
    def set_systemIdStartString(self, systemIdStartString):
        self.systemIdStartString = systemIdStartString
    def get_catalog(self):
        return self.catalog
    def set_catalog(self, catalog):
        self.catalog = catalog
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='delegateSystem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('delegateSystem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'delegateSystem':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='delegateSystem')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='delegateSystem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='delegateSystem'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.systemIdStartString is not None and 'systemIdStartString' not in already_processed:
            already_processed.add('systemIdStartString')
            outfile.write(' systemIdStartString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.systemIdStartString), input_name='systemIdStartString')), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.catalog), input_name='catalog')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='delegateSystem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('systemIdStartString', node)
        if value is not None and 'systemIdStartString' not in already_processed:
            already_processed.add('systemIdStartString')
            self.systemIdStartString = value
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class delegateSystem


class delegateURI(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, uriStartString=None, catalog=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.uriStartString = _cast(None, uriStartString)
        self.uriStartString_nsprefix_ = None
        self.catalog = _cast(None, catalog)
        self.catalog_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, delegateURI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if delegateURI.subclass:
            return delegateURI.subclass(*args_, **kwargs_)
        else:
            return delegateURI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_uriStartString(self):
        return self.uriStartString
    def set_uriStartString(self, uriStartString):
        self.uriStartString = uriStartString
    def get_catalog(self):
        return self.catalog
    def set_catalog(self, catalog):
        self.catalog = catalog
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='delegateURI', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('delegateURI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'delegateURI':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='delegateURI')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='delegateURI', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='delegateURI'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.uriStartString is not None and 'uriStartString' not in already_processed:
            already_processed.add('uriStartString')
            outfile.write(' uriStartString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uriStartString), input_name='uriStartString')), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.catalog), input_name='catalog')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='delegateURI', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uriStartString', node)
        if value is not None and 'uriStartString' not in already_processed:
            already_processed.add('uriStartString')
            self.uriStartString = value
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class delegateURI


class nextCatalog(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, catalog=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "cat"
        self.catalog = _cast(None, catalog)
        self.catalog_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nextCatalog)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nextCatalog.subclass:
            return nextCatalog.subclass(*args_, **kwargs_)
        else:
            return nextCatalog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_catalog(self):
        return self.catalog
    def set_catalog(self, catalog):
        self.catalog = catalog
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='nextCatalog', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nextCatalog')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'nextCatalog':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nextCatalog')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='nextCatalog', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='nextCatalog'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.catalog), input_name='catalog')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"', name_='nextCatalog', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class nextCatalog


class group(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, prefer=None, id=None, public=None, system=None, uri=None, rewriteSystem=None, rewriteURI=None, uriSuffix=None, systemSuffix=None, delegatePublic=None, delegateSystem=None, delegateURI=None, nextCatalog=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.prefer = _cast(None, prefer)
        self.prefer_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if public is None:
            self.public = []
        else:
            self.public = public
        self.public_nsprefix_ = "er"
        if system is None:
            self.system = []
        else:
            self.system = system
        self.system_nsprefix_ = "er"
        if uri is None:
            self.uri = []
        else:
            self.uri = uri
        self.uri_nsprefix_ = "er"
        if rewriteSystem is None:
            self.rewriteSystem = []
        else:
            self.rewriteSystem = rewriteSystem
        self.rewriteSystem_nsprefix_ = "er"
        if rewriteURI is None:
            self.rewriteURI = []
        else:
            self.rewriteURI = rewriteURI
        self.rewriteURI_nsprefix_ = "er"
        if uriSuffix is None:
            self.uriSuffix = []
        else:
            self.uriSuffix = uriSuffix
        self.uriSuffix_nsprefix_ = "er"
        if systemSuffix is None:
            self.systemSuffix = []
        else:
            self.systemSuffix = systemSuffix
        self.systemSuffix_nsprefix_ = "er"
        if delegatePublic is None:
            self.delegatePublic = []
        else:
            self.delegatePublic = delegatePublic
        self.delegatePublic_nsprefix_ = "er"
        if delegateSystem is None:
            self.delegateSystem = []
        else:
            self.delegateSystem = delegateSystem
        self.delegateSystem_nsprefix_ = "er"
        if delegateURI is None:
            self.delegateURI = []
        else:
            self.delegateURI = delegateURI
        self.delegateURI_nsprefix_ = "er"
        if nextCatalog is None:
            self.nextCatalog = []
        else:
            self.nextCatalog = nextCatalog
        self.nextCatalog_nsprefix_ = "er"
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, group)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if group.subclass:
            return group.subclass(*args_, **kwargs_)
        else:
            return group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_public(self):
        return self.public
    def set_public(self, public):
        self.public = public
    def add_public(self, value):
        self.public.append(value)
    def insert_public_at(self, index, value):
        self.public.insert(index, value)
    def replace_public_at(self, index, value):
        self.public[index] = value
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def add_system(self, value):
        self.system.append(value)
    def insert_system_at(self, index, value):
        self.system.insert(index, value)
    def replace_system_at(self, index, value):
        self.system[index] = value
    def get_uri(self):
        return self.uri
    def set_uri(self, uri):
        self.uri = uri
    def add_uri(self, value):
        self.uri.append(value)
    def insert_uri_at(self, index, value):
        self.uri.insert(index, value)
    def replace_uri_at(self, index, value):
        self.uri[index] = value
    def get_rewriteSystem(self):
        return self.rewriteSystem
    def set_rewriteSystem(self, rewriteSystem):
        self.rewriteSystem = rewriteSystem
    def add_rewriteSystem(self, value):
        self.rewriteSystem.append(value)
    def insert_rewriteSystem_at(self, index, value):
        self.rewriteSystem.insert(index, value)
    def replace_rewriteSystem_at(self, index, value):
        self.rewriteSystem[index] = value
    def get_rewriteURI(self):
        return self.rewriteURI
    def set_rewriteURI(self, rewriteURI):
        self.rewriteURI = rewriteURI
    def add_rewriteURI(self, value):
        self.rewriteURI.append(value)
    def insert_rewriteURI_at(self, index, value):
        self.rewriteURI.insert(index, value)
    def replace_rewriteURI_at(self, index, value):
        self.rewriteURI[index] = value
    def get_uriSuffix(self):
        return self.uriSuffix
    def set_uriSuffix(self, uriSuffix):
        self.uriSuffix = uriSuffix
    def add_uriSuffix(self, value):
        self.uriSuffix.append(value)
    def insert_uriSuffix_at(self, index, value):
        self.uriSuffix.insert(index, value)
    def replace_uriSuffix_at(self, index, value):
        self.uriSuffix[index] = value
    def get_systemSuffix(self):
        return self.systemSuffix
    def set_systemSuffix(self, systemSuffix):
        self.systemSuffix = systemSuffix
    def add_systemSuffix(self, value):
        self.systemSuffix.append(value)
    def insert_systemSuffix_at(self, index, value):
        self.systemSuffix.insert(index, value)
    def replace_systemSuffix_at(self, index, value):
        self.systemSuffix[index] = value
    def get_delegatePublic(self):
        return self.delegatePublic
    def set_delegatePublic(self, delegatePublic):
        self.delegatePublic = delegatePublic
    def add_delegatePublic(self, value):
        self.delegatePublic.append(value)
    def insert_delegatePublic_at(self, index, value):
        self.delegatePublic.insert(index, value)
    def replace_delegatePublic_at(self, index, value):
        self.delegatePublic[index] = value
    def get_delegateSystem(self):
        return self.delegateSystem
    def set_delegateSystem(self, delegateSystem):
        self.delegateSystem = delegateSystem
    def add_delegateSystem(self, value):
        self.delegateSystem.append(value)
    def insert_delegateSystem_at(self, index, value):
        self.delegateSystem.insert(index, value)
    def replace_delegateSystem_at(self, index, value):
        self.delegateSystem[index] = value
    def get_delegateURI(self):
        return self.delegateURI
    def set_delegateURI(self, delegateURI):
        self.delegateURI = delegateURI
    def add_delegateURI(self, value):
        self.delegateURI.append(value)
    def insert_delegateURI_at(self, index, value):
        self.delegateURI.insert(index, value)
    def replace_delegateURI_at(self, index, value):
        self.delegateURI[index] = value
    def get_nextCatalog(self):
        return self.nextCatalog
    def set_nextCatalog(self, nextCatalog):
        self.nextCatalog = nextCatalog
    def add_nextCatalog(self, value):
        self.nextCatalog.append(value)
    def insert_nextCatalog_at(self, index, value):
        self.nextCatalog.insert(index, value)
    def replace_nextCatalog_at(self, index, value):
        self.nextCatalog[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_prefer(self):
        return self.prefer
    def set_prefer(self, prefer):
        self.prefer = prefer
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_systemOrPublic(self, value):
        # Validate type er:systemOrPublic, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['system', 'public']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on systemOrPublic' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.public or
            self.system or
            self.uri or
            self.rewriteSystem or
            self.rewriteURI or
            self.uriSuffix or
            self.systemSuffix or
            self.delegatePublic or
            self.delegateSystem or
            self.delegateURI or
            self.nextCatalog or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='group', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'group':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='group')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='er:', name_='group'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.prefer is not None and 'prefer' not in already_processed:
            already_processed.add('prefer')
            outfile.write(' prefer=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prefer), input_name='prefer')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='er:', namespacedef_='xmlns:cat="urn:oasis:names:tc:entity:xmlns:xml:catalog" xmlns:er="urn:oasis:names:tc:entity:xmlns:xml:catalog"  xmlns:None="http://www.w3.org/1999/xhtml" ', name_='group', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for public_ in self.public:
            namespaceprefix_ = self.public_nsprefix_ + ':' if (UseCapturedNS_ and self.public_nsprefix_) else ''
            public_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='public', pretty_print=pretty_print)
        for system_ in self.system:
            namespaceprefix_ = self.system_nsprefix_ + ':' if (UseCapturedNS_ and self.system_nsprefix_) else ''
            system_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='system', pretty_print=pretty_print)
        for uri_ in self.uri:
            namespaceprefix_ = self.uri_nsprefix_ + ':' if (UseCapturedNS_ and self.uri_nsprefix_) else ''
            uri_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='uri', pretty_print=pretty_print)
        for rewriteSystem_ in self.rewriteSystem:
            namespaceprefix_ = self.rewriteSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.rewriteSystem_nsprefix_) else ''
            rewriteSystem_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='rewriteSystem', pretty_print=pretty_print)
        for rewriteURI_ in self.rewriteURI:
            namespaceprefix_ = self.rewriteURI_nsprefix_ + ':' if (UseCapturedNS_ and self.rewriteURI_nsprefix_) else ''
            rewriteURI_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='rewriteURI', pretty_print=pretty_print)
        for uriSuffix_ in self.uriSuffix:
            namespaceprefix_ = self.uriSuffix_nsprefix_ + ':' if (UseCapturedNS_ and self.uriSuffix_nsprefix_) else ''
            uriSuffix_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='uriSuffix', pretty_print=pretty_print)
        for systemSuffix_ in self.systemSuffix:
            namespaceprefix_ = self.systemSuffix_nsprefix_ + ':' if (UseCapturedNS_ and self.systemSuffix_nsprefix_) else ''
            systemSuffix_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='systemSuffix', pretty_print=pretty_print)
        for delegatePublic_ in self.delegatePublic:
            namespaceprefix_ = self.delegatePublic_nsprefix_ + ':' if (UseCapturedNS_ and self.delegatePublic_nsprefix_) else ''
            delegatePublic_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='delegatePublic', pretty_print=pretty_print)
        for delegateSystem_ in self.delegateSystem:
            namespaceprefix_ = self.delegateSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.delegateSystem_nsprefix_) else ''
            delegateSystem_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='delegateSystem', pretty_print=pretty_print)
        for delegateURI_ in self.delegateURI:
            namespaceprefix_ = self.delegateURI_nsprefix_ + ':' if (UseCapturedNS_ and self.delegateURI_nsprefix_) else ''
            delegateURI_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='delegateURI', pretty_print=pretty_print)
        for nextCatalog_ in self.nextCatalog:
            namespaceprefix_ = self.nextCatalog_nsprefix_ + ':' if (UseCapturedNS_ and self.nextCatalog_nsprefix_) else ''
            nextCatalog_.export(outfile, level, namespaceprefix_='er:', namespacedef_='', name_='nextCatalog', pretty_print=pretty_print)
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('prefer', node)
        if value is not None and 'prefer' not in already_processed:
            already_processed.add('prefer')
            self.prefer = value
            self.validate_systemOrPublic(self.prefer)    # validate type systemOrPublic
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'public':
            obj_ = public.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.public.append(obj_)
            obj_.original_tagname_ = 'public'
        elif nodeName_ == 'system':
            obj_ = system.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.system.append(obj_)
            obj_.original_tagname_ = 'system'
        elif nodeName_ == 'uri':
            obj_ = uri.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uri.append(obj_)
            obj_.original_tagname_ = 'uri'
        elif nodeName_ == 'rewriteSystem':
            obj_ = rewriteSystem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rewriteSystem.append(obj_)
            obj_.original_tagname_ = 'rewriteSystem'
        elif nodeName_ == 'rewriteURI':
            obj_ = rewriteURI.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rewriteURI.append(obj_)
            obj_.original_tagname_ = 'rewriteURI'
        elif nodeName_ == 'uriSuffix':
            obj_ = uriSuffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uriSuffix.append(obj_)
            obj_.original_tagname_ = 'uriSuffix'
        elif nodeName_ == 'systemSuffix':
            obj_ = systemSuffix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.systemSuffix.append(obj_)
            obj_.original_tagname_ = 'systemSuffix'
        elif nodeName_ == 'delegatePublic':
            obj_ = delegatePublic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delegatePublic.append(obj_)
            obj_.original_tagname_ = 'delegatePublic'
        elif nodeName_ == 'delegateSystem':
            obj_ = delegateSystem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delegateSystem.append(obj_)
            obj_.original_tagname_ = 'delegateSystem'
        elif nodeName_ == 'delegateURI':
            obj_ = delegateURI.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.delegateURI.append(obj_)
            obj_.original_tagname_ = 'delegateURI'
        elif nodeName_ == 'nextCatalog':
            obj_ = nextCatalog.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nextCatalog.append(obj_)
            obj_.original_tagname_ = 'nextCatalog'
        else:
            content_ = self.gds_build_any(child_, 'group')
            self.set_anytypeobjs_(content_)
# end class group


class simple(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='simple', href=None, role=None, arcrole=None, title=None, show=None, actuate=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, simple)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if simple.subclass:
            return simple.subclass(*args_, **kwargs_)
        else:
            return simple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_typeType(self, value):
        # Validate type xlink:typeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simple', 'extended', 'title', 'resource', 'locator', 'arc']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_hrefType(self, value):
        # Validate type xlink:hrefType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_roleType(self, value):
        # Validate type xlink:roleType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on roleType' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_arcroleType(self, value):
        # Validate type xlink:arcroleType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on arcroleType' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_titleAttrType(self, value):
        # Validate type xlink:titleAttrType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_showType(self, value):
        # Validate type xlink:showType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['new', 'replace', 'embed', 'other', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on showType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_actuateType(self, value):
        # Validate type xlink:actuateType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['onLoad', 'onRequest', 'other', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on actuateType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='simple', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('simple')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'simple':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='simple')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='xlink:', name_='simple'):
        if self.type_ != "simple" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' xlink:href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' xlink:role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' xlink:arcrole=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arcrole), input_name='arcrole')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' xlink:title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' xlink:show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' xlink:actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='simple', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
            self.validate_hrefType(self.href)    # validate type hrefType
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.validate_roleType(self.role)    # validate type roleType
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
            self.validate_arcroleType(self.arcrole)    # validate type arcroleType
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.validate_titleAttrType(self.title)    # validate type titleAttrType
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
            self.show = ' '.join(self.show.split())
            self.validate_showType(self.show)    # validate type showType
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
            self.actuate = ' '.join(self.actuate.split())
            self.validate_actuateType(self.actuate)    # validate type actuateType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class simple


class extended(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='extended', role=None, title_attr=None, title=None, resource=None, locator=None, arc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.title_attr = _cast(None, title_attr)
        self.title_attr_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if resource is None:
            self.resource = []
        else:
            self.resource = resource
        self.resource_nsprefix_ = None
        if locator is None:
            self.locator = []
        else:
            self.locator = locator
        self.locator_nsprefix_ = None
        if arc is None:
            self.arc = []
        else:
            self.arc = arc
        self.arc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extended)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extended.subclass:
            return extended.subclass(*args_, **kwargs_)
        else:
            return extended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_resource(self):
        return self.resource
    def set_resource(self, resource):
        self.resource = resource
    def add_resource(self, value):
        self.resource.append(value)
    def insert_resource_at(self, index, value):
        self.resource.insert(index, value)
    def replace_resource_at(self, index, value):
        self.resource[index] = value
    def get_locator(self):
        return self.locator
    def set_locator(self, locator):
        self.locator = locator
    def add_locator(self, value):
        self.locator.append(value)
    def insert_locator_at(self, index, value):
        self.locator.insert(index, value)
    def replace_locator_at(self, index, value):
        self.locator[index] = value
    def get_arc(self):
        return self.arc
    def set_arc(self, arc):
        self.arc = arc
    def add_arc(self, value):
        self.arc.append(value)
    def insert_arc_at(self, index, value):
        self.arc.insert(index, value)
    def replace_arc_at(self, index, value):
        self.arc[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_title_attr(self):
        return self.title_attr
    def set_title_attr(self, title_attr):
        self.title_attr = title_attr
    def validate_typeType(self, value):
        # Validate type xlink:typeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simple', 'extended', 'title', 'resource', 'locator', 'arc']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_roleType(self, value):
        # Validate type xlink:roleType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on roleType' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_titleAttrType(self, value):
        # Validate type xlink:titleAttrType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.title or
            self.resource or
            self.locator or
            self.arc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink"', name_='extended', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extended')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extended':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extended')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extended', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='xlink:', name_='extended'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' xlink:role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title_attr), input_name='title_attr')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink"', name_='extended', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespaceprefix_, name_='title', namespacedef_='', pretty_print=pretty_print)
        for resource_ in self.resource:
            resource_.export(outfile, level, namespaceprefix_, name_='resource', namespacedef_='', pretty_print=pretty_print)
        for locator_ in self.locator:
            locator_.export(outfile, level, namespaceprefix_, name_='locator', namespacedef_='', pretty_print=pretty_print)
        for arc_ in self.arc:
            arc_.export(outfile, level, namespaceprefix_, name_='arc', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.validate_roleType(self.role)    # validate type roleType
        value = find_attr_value_('title', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            self.title_attr = value
            self.validate_titleAttrType(self.title_attr)    # validate type titleAttrType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            obj_ = titleEltType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'resource':
            obj_ = resourceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.resource.append(obj_)
            obj_.original_tagname_ = 'resource'
        elif nodeName_ == 'locator':
            obj_ = locatorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.locator.append(obj_)
            obj_.original_tagname_ = 'locator'
        elif nodeName_ == 'arc':
            obj_ = arcType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arc.append(obj_)
            obj_.original_tagname_ = 'arc'
# end class extended


class titleEltType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='title', lang=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, titleEltType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if titleEltType.subclass:
            return titleEltType.subclass(*args_, **kwargs_)
        else:
            return titleEltType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_typeType(self, value):
        # Validate type xlink:typeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simple', 'extended', 'title', 'resource', 'locator', 'arc']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='titleEltType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('titleEltType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'titleEltType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='titleEltType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='xlink:', name_='titleEltType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='titleEltType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class titleEltType


class resourceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='resource', role=None, title=None, label=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resourceType.subclass:
            return resourceType.subclass(*args_, **kwargs_)
        else:
            return resourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_typeType(self, value):
        # Validate type xlink:typeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simple', 'extended', 'title', 'resource', 'locator', 'arc']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_roleType(self, value):
        # Validate type xlink:roleType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on roleType' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_titleAttrType(self, value):
        # Validate type xlink:titleAttrType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_labelType(self, value):
        # Validate type xlink:labelType, a restriction on xs:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='resourceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resourceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resourceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resourceType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='xlink:', name_='resourceType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' xlink:role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' xlink:title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' xlink:label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:None="http://www.w3.org/1999/xhtml" ', name_='resourceType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.validate_roleType(self.role)    # validate type roleType
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.validate_titleAttrType(self.title)    # validate type titleAttrType
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_labelType(self.label)    # validate type labelType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class resourceType


class locatorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='locator', href=None, role=None, title_attr=None, label=None, title=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.title_attr = _cast(None, title_attr)
        self.title_attr_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, locatorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if locatorType.subclass:
            return locatorType.subclass(*args_, **kwargs_)
        else:
            return locatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_title_attr(self):
        return self.title_attr
    def set_title_attr(self, title_attr):
        self.title_attr = title_attr
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def validate_typeType(self, value):
        # Validate type xlink:typeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simple', 'extended', 'title', 'resource', 'locator', 'arc']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_hrefType(self, value):
        # Validate type xlink:hrefType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_roleType(self, value):
        # Validate type xlink:roleType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on roleType' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_titleAttrType(self, value):
        # Validate type xlink:titleAttrType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_labelType(self, value):
        # Validate type xlink:labelType, a restriction on xs:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.title
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink"', name_='locatorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('locatorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'locatorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='locatorType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='locatorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='xlink:', name_='locatorType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' xlink:href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' xlink:role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title_attr), input_name='title_attr')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' xlink:label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink"', name_='locatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespaceprefix_, name_='title', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
            self.validate_hrefType(self.href)    # validate type hrefType
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
            self.validate_roleType(self.role)    # validate type roleType
        value = find_attr_value_('title', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            self.title_attr = value
            self.validate_titleAttrType(self.title_attr)    # validate type titleAttrType
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_labelType(self.label)    # validate type labelType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            obj_ = titleEltType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
# end class locatorType


class arcType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='arc', arcrole=None, title_attr=None, show=None, actuate=None, from_=None, to=None, title=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.arcrole = _cast(None, arcrole)
        self.arcrole_nsprefix_ = None
        self.title_attr = _cast(None, title_attr)
        self.title_attr_nsprefix_ = None
        self.show = _cast(None, show)
        self.show_nsprefix_ = None
        self.actuate = _cast(None, actuate)
        self.actuate_nsprefix_ = None
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, arcType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if arcType.subclass:
            return arcType.subclass(*args_, **kwargs_)
        else:
            return arcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_arcrole(self):
        return self.arcrole
    def set_arcrole(self, arcrole):
        self.arcrole = arcrole
    def get_title_attr(self):
        return self.title_attr
    def set_title_attr(self, title_attr):
        self.title_attr = title_attr
    def get_show(self):
        return self.show
    def set_show(self, show):
        self.show = show
    def get_actuate(self):
        return self.actuate
    def set_actuate(self, actuate):
        self.actuate = actuate
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    def validate_typeType(self, value):
        # Validate type xlink:typeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['simple', 'extended', 'title', 'resource', 'locator', 'arc']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_arcroleType(self, value):
        # Validate type xlink:arcroleType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on arcroleType' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_titleAttrType(self, value):
        # Validate type xlink:titleAttrType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_showType(self, value):
        # Validate type xlink:showType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['new', 'replace', 'embed', 'other', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on showType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_actuateType(self, value):
        # Validate type xlink:actuateType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['onLoad', 'onRequest', 'other', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on actuateType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_fromType(self, value):
        # Validate type xlink:fromType, a restriction on xs:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_toType(self, value):
        # Validate type xlink:toType, a restriction on xs:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def has__content(self):
        if (
            self.title
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink"', name_='arcType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('arcType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'arcType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='arcType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='arcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='xlink:', name_='arcType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' xlink:type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.arcrole is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            outfile.write(' xlink:arcrole=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arcrole), input_name='arcrole')), ))
        if self.title_attr is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title_attr), input_name='title_attr')), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.add('show')
            outfile.write(' xlink:show=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.show), input_name='show')), ))
        if self.actuate is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            outfile.write(' xlink:actuate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.actuate), input_name='actuate')), ))
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' xlink:from=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.from_), input_name='from')), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' xlink:to=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.to), input_name='to')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='xlink:', namespacedef_='xmlns:xlink="http://www.w3.org/1999/xlink"', name_='arcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespaceprefix_, name_='title', namespacedef_='', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('arcrole', node)
        if value is not None and 'arcrole' not in already_processed:
            already_processed.add('arcrole')
            self.arcrole = value
            self.validate_arcroleType(self.arcrole)    # validate type arcroleType
        value = find_attr_value_('title', node)
        if value is not None and 'title_attr' not in already_processed:
            already_processed.add('title_attr')
            self.title_attr = value
            self.validate_titleAttrType(self.title_attr)    # validate type titleAttrType
        value = find_attr_value_('show', node)
        if value is not None and 'show' not in already_processed:
            already_processed.add('show')
            self.show = value
            self.show = ' '.join(self.show.split())
            self.validate_showType(self.show)    # validate type showType
        value = find_attr_value_('actuate', node)
        if value is not None and 'actuate' not in already_processed:
            already_processed.add('actuate')
            self.actuate = value
            self.actuate = ' '.join(self.actuate.split())
            self.validate_actuateType(self.actuate)    # validate type actuateType
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
            self.validate_fromType(self.from_)    # validate type fromType
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
            self.validate_toType(self.to)    # validate type toType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            obj_ = titleEltType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
# end class arcType


class DigestValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestValueType.subclass:
            return DigestValueType.subclass(*args_, **kwargs_)
        else:
            return DigestValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DigestValueType_impl(self, value):
        result = True
        # Validate type DigestValueType_impl, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"', name_='DigestValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DigestValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DigestValueType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DigestValueType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"', name_='DigestValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DigestValueType


class referenceType50(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referenceType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referenceType50.subclass:
            return referenceType50.subclass(*args_, **kwargs_)
        else:
            return referenceType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='referenceType50', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referenceType50')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referenceType50':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referenceType50')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referenceType50'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='referenceType50', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referenceType50


class referenceType51(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referenceType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referenceType51.subclass:
            return referenceType51.subclass(*args_, **kwargs_)
        else:
            return referenceType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='referenceType51', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referenceType51')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referenceType51':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referenceType51')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referenceType51', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referenceType51'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"', name_='referenceType51', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referenceType51


class VariableType10(ItemBaseType):
    """description -- The description element holds information
    that describes the value stored on the variable.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ItemBaseType
    def __init__(self, revision='0', notes=None, id=None, datatype=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("VariableType10"), self).__init__(revision, notes,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.datatype = _cast(None, datatype)
        self.datatype_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableType10.subclass:
            return VariableType10.subclass(*args_, **kwargs_)
        else:
            return VariableType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_datatype(self):
        return self.datatype
    def set_datatype(self, datatype):
        self.datatype = datatype
    def validate_VariableIDPattern(self, value):
        # Validate type inter:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def validate_VariableDataType(self, value):
        # Validate type inter:VariableDataType, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['TEXT', 'NUMERIC']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VariableDataType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.description is not None or
            super(VariableType10, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='VariableType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariableType10':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableType10')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariableType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='VariableType10'):
        super(VariableType10, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableType10')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='VariableType10', fromsubclass_=False, pretty_print=True):
        super(VariableType10, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_VariableIDPattern(self.id)    # validate type VariableIDPattern
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_VariableDataType(self.datatype)    # validate type VariableDataType
        super(VariableType10, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        super(VariableType10, self)._buildChildren(child_, node, nodeName_, True)
# end class VariableType10


class SystemTargetType(NamedItemBaseType):
    """organization -- The organization element specifies what
    company or institution the system belongs
    to.
    ipaddress -- The ipaddress element holds the ip address of
    a target com
    puter/network.
    TODO: define an IPv4/v6 address pattern
    description -- The description element holds information on
    what the target system is about.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedItemBaseType
    def __init__(self, revision='0', notes=None, name=None, organization=None, ipaddress=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SystemTargetType"), self).__init__(revision, notes, name,  **kwargs_)
        self.organization = organization
        self.organization_nsprefix_ = None
        if ipaddress is None:
            self.ipaddress = []
        else:
            self.ipaddress = ipaddress
        self.ipaddress_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SystemTargetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SystemTargetType.subclass:
            return SystemTargetType.subclass(*args_, **kwargs_)
        else:
            return SystemTargetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_organization(self):
        return self.organization
    def set_organization(self, organization):
        self.organization = organization
    def get_ipaddress(self):
        return self.ipaddress
    def set_ipaddress(self, ipaddress):
        self.ipaddress = ipaddress
    def add_ipaddress(self, value):
        self.ipaddress.append(value)
    def insert_ipaddress_at(self, index, value):
        self.ipaddress.insert(index, value)
    def replace_ipaddress_at(self, index, value):
        self.ipaddress[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def has__content(self):
        if (
            self.organization is not None or
            self.ipaddress or
            self.description is not None or
            super(SystemTargetType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='SystemTargetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SystemTargetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SystemTargetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SystemTargetType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SystemTargetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='SystemTargetType'):
        super(SystemTargetType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SystemTargetType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='SystemTargetType', fromsubclass_=False, pretty_print=True):
        super(SystemTargetType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.organization is not None:
            namespaceprefix_ = self.organization_nsprefix_ + ':' if (UseCapturedNS_ and self.organization_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganization>%s</%sorganization>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.organization), input_name='organization')), namespaceprefix_ , eol_))
        for ipaddress_ in self.ipaddress:
            namespaceprefix_ = self.ipaddress_nsprefix_ + ':' if (UseCapturedNS_ and self.ipaddress_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipaddress>%s</%sipaddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ipaddress_), input_name='ipaddress')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SystemTargetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'organization':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'organization')
            value_ = self.gds_validate_string(value_, node, 'organization')
            self.organization = value_
            self.organization_nsprefix_ = child_.prefix
        elif nodeName_ == 'ipaddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ipaddress')
            value_ = self.gds_validate_string(value_, node, 'ipaddress')
            self.ipaddress.append(value_)
            self.ipaddress_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        super(SystemTargetType, self)._buildChildren(child_, node, nodeName_, True)
# end class SystemTargetType


class UserType(NamedItemBaseType):
    """organization -- The organization element specifies the
    company or institution that the user belongs
    to.
    position -- The position element holds the job title or
    the position of the user within his/her
    organization.
    email -- The email element holds the email address
    where the user can be contacted.
    TODO: define an email pattern
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedItemBaseType
    def __init__(self, revision='0', notes=None, name=None, organization=None, position=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UserType"), self).__init__(revision, notes, name,  **kwargs_)
        if organization is None:
            self.organization = []
        else:
            self.organization = organization
        self.organization_nsprefix_ = None
        if position is None:
            self.position = []
        else:
            self.position = position
        self.position_nsprefix_ = None
        if email is None:
            self.email = []
        else:
            self.email = email
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UserType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UserType.subclass:
            return UserType.subclass(*args_, **kwargs_)
        else:
            return UserType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_organization(self):
        return self.organization
    def set_organization(self, organization):
        self.organization = organization
    def add_organization(self, value):
        self.organization.append(value)
    def insert_organization_at(self, index, value):
        self.organization.insert(index, value)
    def replace_organization_at(self, index, value):
        self.organization[index] = value
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def add_position(self, value):
        self.position.append(value)
    def insert_position_at(self, index, value):
        self.position.insert(index, value)
    def replace_position_at(self, index, value):
        self.position[index] = value
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def add_email(self, value):
        self.email.append(value)
    def insert_email_at(self, index, value):
        self.email.insert(index, value)
    def replace_email_at(self, index, value):
        self.email[index] = value
    def has__content(self):
        if (
            self.organization or
            self.position or
            self.email or
            super(UserType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='UserType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UserType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UserType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UserType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UserType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='UserType'):
        super(UserType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UserType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='UserType', fromsubclass_=False, pretty_print=True):
        super(UserType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for organization_ in self.organization:
            namespaceprefix_ = self.organization_nsprefix_ + ':' if (UseCapturedNS_ and self.organization_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganization>%s</%sorganization>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(organization_), input_name='organization')), namespaceprefix_ , eol_))
        for position_ in self.position:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sposition>%s</%sposition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(position_), input_name='position')), namespaceprefix_ , eol_))
        for email_ in self.email:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(email_), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(UserType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'organization':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'organization')
            value_ = self.gds_validate_string(value_, node, 'organization')
            self.organization.append(value_)
            self.organization_nsprefix_ = child_.prefix
        elif nodeName_ == 'position':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'position')
            value_ = self.gds_validate_string(value_, node, 'position')
            self.position.append(value_)
            self.position_nsprefix_ = child_.prefix
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email.append(value_)
            self.email_nsprefix_ = child_.prefix
        super(UserType, self)._buildChildren(child_, node, nodeName_, True)
# end class UserType


class ArtifactType(ItemBaseType):
    """title -- The title element holds a short summary or a
    caption about the artifact.
    description -- The description element holds information that
    describes what the artifact is about.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ItemBaseType
    def __init__(self, revision='0', notes=None, id=None, persistent='true', title=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("ArtifactType"), self).__init__(revision, notes,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.persistent = _cast(None, persistent)
        self.persistent_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "inter"
        self.description = description
        self.description_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArtifactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArtifactType.subclass:
            return ArtifactType.subclass(*args_, **kwargs_)
        else:
            return ArtifactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_persistent(self):
        return self.persistent
    def set_persistent(self, persistent):
        self.persistent = persistent
    def validate_ArtifactIDPattern(self, value):
        # Validate type inter:ArtifactIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ArtifactIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ArtifactIDPattern_patterns_, ))
    validate_ArtifactIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:artifact:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.title is not None or
            self.description is not None or
            super(ArtifactType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArtifactType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArtifactType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArtifactType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArtifactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ArtifactType'):
        super(ArtifactType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArtifactType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.persistent != "true" and 'persistent' not in already_processed:
            already_processed.add('persistent')
            outfile.write(' persistent=%s' % (quote_attrib(self.persistent), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ArtifactType', fromsubclass_=False, pretty_print=True):
        super(ArtifactType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ArtifactIDPattern(self.id)    # validate type ArtifactIDPattern
        value = find_attr_value_('persistent', node)
        if value is not None and 'persistent' not in already_processed:
            already_processed.add('persistent')
            self.persistent = value
        super(ArtifactType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        super(ArtifactType, self)._buildChildren(child_, node, nodeName_, True)
# end class ArtifactType


class QuestionType(ItemBaseType):
    """question_text -- The question_text element provides the text of
    the question to pose.
    instructions -- An optional instructions element may be
    included to hold additional instructions to assist the user
    in determining the answer to the question.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ItemBaseType
    def __init__(self, revision='0', notes=None, id=None, question_text=None, instructions=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("QuestionType"), self).__init__(revision, notes, extensiontype_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if question_text is None:
            self.question_text = []
        else:
            self.question_text = question_text
        self.question_text_nsprefix_ = "inter"
        self.instructions = instructions
        self.instructions_nsprefix_ = "inter"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionType.subclass:
            return QuestionType.subclass(*args_, **kwargs_)
        else:
            return QuestionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_question_text(self):
        return self.question_text
    def set_question_text(self, question_text):
        self.question_text = question_text
    def add_question_text(self, value):
        self.question_text.append(value)
    def insert_question_text_at(self, index, value):
        self.question_text.insert(index, value)
    def replace_question_text_at(self, index, value):
        self.question_text[index] = value
    def get_instructions(self):
        return self.instructions
    def set_instructions(self, instructions):
        self.instructions = instructions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_QuestionIDPattern(self, value):
        # Validate type inter:QuestionIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_QuestionIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_QuestionIDPattern_patterns_, ))
    validate_QuestionIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:question:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.question_text or
            self.instructions is not None or
            super(QuestionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionType'):
        super(QuestionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionType', fromsubclass_=False, pretty_print=True):
        super(QuestionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for question_text_ in self.question_text:
            namespaceprefix_ = self.question_text_nsprefix_ + ':' if (UseCapturedNS_ and self.question_text_nsprefix_) else ''
            question_text_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='question_text', pretty_print=pretty_print)
        if self.instructions is not None:
            namespaceprefix_ = self.instructions_nsprefix_ + ':' if (UseCapturedNS_ and self.instructions_nsprefix_) else ''
            self.instructions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instructions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_QuestionIDPattern(self.id)    # validate type QuestionIDPattern
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QuestionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'question_text':
            obj_ = QuestionTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.question_text.append(obj_)
            obj_.original_tagname_ = 'question_text'
        elif nodeName_ == 'instructions':
            obj_ = InstructionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instructions = obj_
            obj_.original_tagname_ = 'instructions'
        super(QuestionType, self)._buildChildren(child_, node, nodeName_, True)
# end class QuestionType


class PatternTestActionConditionType(TestActionConditionType):
    """pattern -- Each pattern element holds a regular
    expression against which the response string is to be
    compared.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TestActionConditionType
    def __init__(self, result=None, test_action_ref=None, artifact_refs=None, pattern=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("PatternTestActionConditionType"), self).__init__(result, test_action_ref, artifact_refs,  **kwargs_)
        if pattern is None:
            self.pattern = []
        else:
            self.pattern = pattern
        self.pattern_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PatternTestActionConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PatternTestActionConditionType.subclass:
            return PatternTestActionConditionType.subclass(*args_, **kwargs_)
        else:
            return PatternTestActionConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pattern(self):
        return self.pattern
    def set_pattern(self, pattern):
        self.pattern = pattern
    def add_pattern(self, value):
        self.pattern.append(value)
    def insert_pattern_at(self, index, value):
        self.pattern.insert(index, value)
    def replace_pattern_at(self, index, value):
        self.pattern[index] = value
    def has__content(self):
        if (
            self.pattern or
            super(PatternTestActionConditionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='PatternTestActionConditionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PatternTestActionConditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PatternTestActionConditionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PatternTestActionConditionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PatternTestActionConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='PatternTestActionConditionType'):
        super(PatternTestActionConditionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PatternTestActionConditionType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='PatternTestActionConditionType', fromsubclass_=False, pretty_print=True):
        super(PatternTestActionConditionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pattern_ in self.pattern:
            namespaceprefix_ = self.pattern_nsprefix_ + ':' if (UseCapturedNS_ and self.pattern_nsprefix_) else ''
            pattern_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pattern', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PatternTestActionConditionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pattern':
            obj_ = PatternType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pattern.append(obj_)
            obj_.original_tagname_ = 'pattern'
        super(PatternTestActionConditionType, self)._buildChildren(child_, node, nodeName_, True)
# end class PatternTestActionConditionType


class RangeTestActionConditionType(TestActionConditionType):
    """range -- Each range element holds a single numeric
    range.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TestActionConditionType
    def __init__(self, result=None, test_action_ref=None, artifact_refs=None, range_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("RangeTestActionConditionType"), self).__init__(result, test_action_ref, artifact_refs,  **kwargs_)
        if range_ is None:
            self.range_ = []
        else:
            self.range_ = range_
        self.range__nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RangeTestActionConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RangeTestActionConditionType.subclass:
            return RangeTestActionConditionType.subclass(*args_, **kwargs_)
        else:
            return RangeTestActionConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_range(self):
        return self.range_
    def set_range(self, range_):
        self.range_ = range_
    def add_range(self, value):
        self.range_.append(value)
    def insert_range_at(self, index, value):
        self.range_.insert(index, value)
    def replace_range_at(self, index, value):
        self.range_[index] = value
    def has__content(self):
        if (
            self.range_ or
            super(RangeTestActionConditionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='RangeTestActionConditionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RangeTestActionConditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RangeTestActionConditionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RangeTestActionConditionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RangeTestActionConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='RangeTestActionConditionType'):
        super(RangeTestActionConditionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RangeTestActionConditionType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='RangeTestActionConditionType', fromsubclass_=False, pretty_print=True):
        super(RangeTestActionConditionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for range_ in self.range_:
            namespaceprefix_ = self.range__nsprefix_ + ':' if (UseCapturedNS_ and self.range__nsprefix_) else ''
            range_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='range', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RangeTestActionConditionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'range':
            obj_ = RangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.range_.append(obj_)
            obj_.original_tagname_ = 'range'
        super(RangeTestActionConditionType, self)._buildChildren(child_, node, nodeName_, True)
# end class RangeTestActionConditionType


class EqualsTestActionConditionType(TestActionConditionType):
    """value --  Each value holds what is to be matched.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TestActionConditionType
    def __init__(self, result=None, test_action_ref=None, artifact_refs=None, var_ref=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EqualsTestActionConditionType"), self).__init__(result, test_action_ref, artifact_refs,  **kwargs_)
        self.var_ref = _cast(None, var_ref)
        self.var_ref_nsprefix_ = None
        if value is None:
            self.value = []
        else:
            self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EqualsTestActionConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EqualsTestActionConditionType.subclass:
            return EqualsTestActionConditionType.subclass(*args_, **kwargs_)
        else:
            return EqualsTestActionConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    def get_var_ref(self):
        return self.var_ref
    def set_var_ref(self, var_ref):
        self.var_ref = var_ref
    def validate_VariableIDPattern(self, value):
        # Validate type inter:VariableIDPattern, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_VariableIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VariableIDPattern_patterns_, ))
    validate_VariableIDPattern_patterns_ = [['^(oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.value or
            super(EqualsTestActionConditionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='EqualsTestActionConditionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EqualsTestActionConditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EqualsTestActionConditionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EqualsTestActionConditionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EqualsTestActionConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='EqualsTestActionConditionType'):
        super(EqualsTestActionConditionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EqualsTestActionConditionType')
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:None="http://www.w3.org/1999/xhtml"  xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='EqualsTestActionConditionType', fromsubclass_=False, pretty_print=True):
        super(EqualsTestActionConditionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(value_), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
            self.validate_VariableIDPattern(self.var_ref)    # validate type VariableIDPattern
        super(EqualsTestActionConditionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
            self.value_nsprefix_ = child_.prefix
        super(EqualsTestActionConditionType, self)._buildChildren(child_, node, nodeName_, True)
# end class EqualsTestActionConditionType


class ChoiceTestActionConditionType(TestActionConditionType):
    """choice_ref -- The choice_ref element specifies the id of a
    choice.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TestActionConditionType
    def __init__(self, result=None, test_action_ref=None, artifact_refs=None, choice_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("ChoiceTestActionConditionType"), self).__init__(result, test_action_ref, artifact_refs,  **kwargs_)
        if choice_ref is None:
            self.choice_ref = []
        else:
            self.choice_ref = choice_ref
        self.choice_ref_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChoiceTestActionConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChoiceTestActionConditionType.subclass:
            return ChoiceTestActionConditionType.subclass(*args_, **kwargs_)
        else:
            return ChoiceTestActionConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_choice_ref(self):
        return self.choice_ref
    def set_choice_ref(self, choice_ref):
        self.choice_ref = choice_ref
    def add_choice_ref(self, value):
        self.choice_ref.append(value)
    def insert_choice_ref_at(self, index, value):
        self.choice_ref.insert(index, value)
    def replace_choice_ref_at(self, index, value):
        self.choice_ref[index] = value
    def validate_ChoiceIDPattern(self, value):
        result = True
        # Validate type ChoiceIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChoiceIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ChoiceIDPattern_patterns_, ))
                result = False
        return result
    validate_ChoiceIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:choice:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.choice_ref or
            super(ChoiceTestActionConditionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceTestActionConditionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChoiceTestActionConditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChoiceTestActionConditionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceTestActionConditionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChoiceTestActionConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ChoiceTestActionConditionType'):
        super(ChoiceTestActionConditionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceTestActionConditionType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceTestActionConditionType', fromsubclass_=False, pretty_print=True):
        super(ChoiceTestActionConditionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for choice_ref_ in self.choice_ref:
            namespaceprefix_ = self.choice_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.choice_ref_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schoice_ref>%s</%schoice_ref>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(choice_ref_), input_name='choice_ref')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ChoiceTestActionConditionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'choice_ref':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'choice_ref')
            value_ = self.gds_validate_string(value_, node, 'choice_ref')
            self.choice_ref.append(value_)
            self.choice_ref_nsprefix_ = child_.prefix
            # validate type ChoiceIDPattern
            self.validate_ChoiceIDPattern(self.choice_ref[-1])
        super(ChoiceTestActionConditionType, self)._buildChildren(child_, node, nodeName_, True)
# end class ChoiceTestActionConditionType


class QuestionTestActionType(ItemBaseType):
    """title -- The title element contains a descriptive
    heading for this set of handlers.
    when_unknown --  The when_unknown element contains processing
    instructions for when the received result is UNKNOWN.
      
    * when_not_tested --  The when_not_tested element contains
      processing instructions for when the received result is
      NOT_TESTED.
    * when_not_applicable --  The when_not_applicable element contains
      processing instructions for when the received result is
      NOT_APPLICABLE.
    * when_error --  The when_error element contains processing
      instructions for when the received result is ERROR.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ItemBaseType
    def __init__(self, revision='0', notes=None, question_ref=None, id=None, title=None, when_unknown=None, when_not_tested=None, when_not_applicable=None, when_error=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("QuestionTestActionType"), self).__init__(revision, notes, extensiontype_,  **kwargs_)
        self.question_ref = _cast(None, question_ref)
        self.question_ref_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = "inter"
        self.when_unknown = when_unknown
        self.when_unknown_nsprefix_ = "inter"
        self.when_not_tested = when_not_tested
        self.when_not_tested_nsprefix_ = "inter"
        self.when_not_applicable = when_not_applicable
        self.when_not_applicable_nsprefix_ = "inter"
        self.when_error = when_error
        self.when_error_nsprefix_ = "inter"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionTestActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionTestActionType.subclass:
            return QuestionTestActionType.subclass(*args_, **kwargs_)
        else:
            return QuestionTestActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_when_unknown(self):
        return self.when_unknown
    def set_when_unknown(self, when_unknown):
        self.when_unknown = when_unknown
    def get_when_not_tested(self):
        return self.when_not_tested
    def set_when_not_tested(self, when_not_tested):
        self.when_not_tested = when_not_tested
    def get_when_not_applicable(self):
        return self.when_not_applicable
    def set_when_not_applicable(self, when_not_applicable):
        self.when_not_applicable = when_not_applicable
    def get_when_error(self):
        return self.when_error
    def set_when_error(self, when_error):
        self.when_error = when_error
    def get_question_ref(self):
        return self.question_ref
    def set_question_ref(self, question_ref):
        self.question_ref = question_ref
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_QuestionIDPattern(self, value):
        # Validate type inter:QuestionIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_QuestionIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_QuestionIDPattern_patterns_, ))
    validate_QuestionIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:question:[1-9][0-9]*)$']]
    def validate_QuestionTestActionIDPattern(self, value):
        # Validate type inter:QuestionTestActionIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_QuestionTestActionIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_QuestionTestActionIDPattern_patterns_, ))
    validate_QuestionTestActionIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:testaction:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.title is not None or
            self.when_unknown is not None or
            self.when_not_tested is not None or
            self.when_not_applicable is not None or
            self.when_error is not None or
            super(QuestionTestActionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionTestActionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionTestActionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionTestActionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionTestActionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionTestActionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionTestActionType'):
        super(QuestionTestActionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionTestActionType')
        if self.question_ref is not None and 'question_ref' not in already_processed:
            already_processed.add('question_ref')
            outfile.write(' question_ref=%s' % (quote_attrib(self.question_ref), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='QuestionTestActionType', fromsubclass_=False, pretty_print=True):
        super(QuestionTestActionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        if self.when_unknown is not None:
            namespaceprefix_ = self.when_unknown_nsprefix_ + ':' if (UseCapturedNS_ and self.when_unknown_nsprefix_) else ''
            self.when_unknown.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_unknown', pretty_print=pretty_print)
        if self.when_not_tested is not None:
            namespaceprefix_ = self.when_not_tested_nsprefix_ + ':' if (UseCapturedNS_ and self.when_not_tested_nsprefix_) else ''
            self.when_not_tested.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_not_tested', pretty_print=pretty_print)
        if self.when_not_applicable is not None:
            namespaceprefix_ = self.when_not_applicable_nsprefix_ + ':' if (UseCapturedNS_ and self.when_not_applicable_nsprefix_) else ''
            self.when_not_applicable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_not_applicable', pretty_print=pretty_print)
        if self.when_error is not None:
            namespaceprefix_ = self.when_error_nsprefix_ + ':' if (UseCapturedNS_ and self.when_error_nsprefix_) else ''
            self.when_error.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_error', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('question_ref', node)
        if value is not None and 'question_ref' not in already_processed:
            already_processed.add('question_ref')
            self.question_ref = value
            self.validate_QuestionIDPattern(self.question_ref)    # validate type QuestionIDPattern
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_QuestionTestActionIDPattern(self.id)    # validate type QuestionTestActionIDPattern
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QuestionTestActionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            class_obj_ = self.get_class_obj_(child_, TextType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'when_unknown':
            class_obj_ = self.get_class_obj_(child_, TestActionConditionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_unknown = obj_
            obj_.original_tagname_ = 'when_unknown'
        elif nodeName_ == 'when_not_tested':
            class_obj_ = self.get_class_obj_(child_, TestActionConditionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_not_tested = obj_
            obj_.original_tagname_ = 'when_not_tested'
        elif nodeName_ == 'when_not_applicable':
            class_obj_ = self.get_class_obj_(child_, TestActionConditionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_not_applicable = obj_
            obj_.original_tagname_ = 'when_not_applicable'
        elif nodeName_ == 'when_error':
            class_obj_ = self.get_class_obj_(child_, TestActionConditionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_error = obj_
            obj_.original_tagname_ = 'when_error'
        super(QuestionTestActionType, self)._buildChildren(child_, node, nodeName_, True)
# end class QuestionTestActionType


class QuestionnaireType(CompoundTestActionType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CompoundTestActionType
    def __init__(self, revision='0', notes=None, title=None, description=None, references=None, actions=None, id=None, child_only='false', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("QuestionnaireType"), self).__init__(revision, notes, title, description, references, actions,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.child_only = _cast(None, child_only)
        self.child_only_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuestionnaireType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuestionnaireType.subclass:
            return QuestionnaireType.subclass(*args_, **kwargs_)
        else:
            return QuestionnaireType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_child_only(self):
        return self.child_only
    def set_child_only(self, child_only):
        self.child_only = child_only
    def validate_QuestionnaireIDPattern(self, value):
        # Validate type inter:QuestionnaireIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_QuestionnaireIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_QuestionnaireIDPattern_patterns_, ))
    validate_QuestionnaireIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:questionnaire:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            super(QuestionnaireType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='QuestionnaireType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuestionnaireType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuestionnaireType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionnaireType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuestionnaireType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='QuestionnaireType'):
        super(QuestionnaireType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuestionnaireType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.child_only != "false" and 'child_only' not in already_processed:
            already_processed.add('child_only')
            outfile.write(' child_only=%s' % (quote_attrib(self.child_only), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='QuestionnaireType', fromsubclass_=False, pretty_print=True):
        super(QuestionnaireType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_QuestionnaireIDPattern(self.id)    # validate type QuestionnaireIDPattern
        value = find_attr_value_('child_only', node)
        if value is not None and 'child_only' not in already_processed:
            already_processed.add('child_only')
            self.child_only = value
        super(QuestionnaireType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QuestionnaireType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QuestionnaireType


class subType(idrefType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = idrefType
    def __init__(self, idref=None, use='value', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "xccdf"
        super(globals().get("subType"), self).__init__(idref,  **kwargs_)
        self.use = _cast(None, use)
        self.use_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subType.subclass:
            return subType.subclass(*args_, **kwargs_)
        else:
            return subType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_use(self):
        return self.use
    def set_use(self, use):
        self.use = use
    def validate_subUseEnumType(self, value):
        # Validate type cdf:subUseEnumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['value', 'title', 'legacy']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on subUseEnumType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(subType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='subType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'subType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='subType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='cdf:', name_='subType'):
        super(subType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subType')
        if self.use != "value" and 'use' not in already_processed:
            already_processed.add('use')
            outfile.write(' use=%s' % (quote_attrib(self.use), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='cdf:', namespacedef_='xmlns:xccdf="http://checklists.nist.gov/xccdf/1.2" xmlns:cdf="http://checklists.nist.gov/xccdf/1.2"', name_='subType', fromsubclass_=False, pretty_print=True):
        super(subType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('use', node)
        if value is not None and 'use' not in already_processed:
            already_processed.add('use')
            self.use = value
            self.validate_subUseEnumType(self.use)    # validate type subUseEnumType
        super(subType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(subType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class subType


class StringQuestionType(QuestionType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionType
    def __init__(self, revision='0', notes=None, id=None, question_text=None, instructions=None, default_answer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("StringQuestionType"), self).__init__(revision, notes, id, question_text, instructions,  **kwargs_)
        self.default_answer = _cast(None, default_answer)
        self.default_answer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringQuestionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringQuestionType.subclass:
            return StringQuestionType.subclass(*args_, **kwargs_)
        else:
            return StringQuestionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_answer(self):
        return self.default_answer
    def set_default_answer(self, default_answer):
        self.default_answer = default_answer
    def has__content(self):
        if (
            super(StringQuestionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='StringQuestionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringQuestionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringQuestionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringQuestionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringQuestionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='StringQuestionType'):
        super(StringQuestionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringQuestionType')
        if self.default_answer is not None and 'default_answer' not in already_processed:
            already_processed.add('default_answer')
            outfile.write(' default_answer=%s' % (quote_attrib(self.default_answer), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='StringQuestionType', fromsubclass_=False, pretty_print=True):
        super(StringQuestionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_answer', node)
        if value is not None and 'default_answer' not in already_processed:
            already_processed.add('default_answer')
            self.default_answer = value
        super(StringQuestionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(StringQuestionType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class StringQuestionType


class NumericQuestionType(QuestionType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionType
    def __init__(self, revision='0', notes=None, id=None, question_text=None, instructions=None, default_answer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("NumericQuestionType"), self).__init__(revision, notes, id, question_text, instructions,  **kwargs_)
        self.default_answer = _cast(None, default_answer)
        self.default_answer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericQuestionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericQuestionType.subclass:
            return NumericQuestionType.subclass(*args_, **kwargs_)
        else:
            return NumericQuestionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_answer(self):
        return self.default_answer
    def set_default_answer(self, default_answer):
        self.default_answer = default_answer
    def has__content(self):
        if (
            super(NumericQuestionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='NumericQuestionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericQuestionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericQuestionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericQuestionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumericQuestionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='NumericQuestionType'):
        super(NumericQuestionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericQuestionType')
        if self.default_answer is not None and 'default_answer' not in already_processed:
            already_processed.add('default_answer')
            outfile.write(' default_answer=%s' % (quote_attrib(self.default_answer), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='NumericQuestionType', fromsubclass_=False, pretty_print=True):
        super(NumericQuestionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_answer', node)
        if value is not None and 'default_answer' not in already_processed:
            already_processed.add('default_answer')
            self.default_answer = value
        super(NumericQuestionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NumericQuestionType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class NumericQuestionType


class ChoiceQuestionType(QuestionType):
    """choice -- Holds the information associated with one of
    the possible responses to this choice_question.
    choice_group_ref -- Holds a reference to a choice_group. The
    questions described in this choice group are used as possible
    responses for this choice_question.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionType
    def __init__(self, revision='0', notes=None, id=None, question_text=None, instructions=None, default_answer_ref=None, choice=None, choice_group_ref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("ChoiceQuestionType"), self).__init__(revision, notes, id, question_text, instructions,  **kwargs_)
        self.default_answer_ref = _cast(None, default_answer_ref)
        self.default_answer_ref_nsprefix_ = None
        if choice is None:
            self.choice = []
        else:
            self.choice = choice
        self.choice_nsprefix_ = "inter"
        if choice_group_ref is None:
            self.choice_group_ref = []
        else:
            self.choice_group_ref = choice_group_ref
        self.choice_group_ref_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChoiceQuestionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChoiceQuestionType.subclass:
            return ChoiceQuestionType.subclass(*args_, **kwargs_)
        else:
            return ChoiceQuestionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_choice(self):
        return self.choice
    def set_choice(self, choice):
        self.choice = choice
    def add_choice(self, value):
        self.choice.append(value)
    def insert_choice_at(self, index, value):
        self.choice.insert(index, value)
    def replace_choice_at(self, index, value):
        self.choice[index] = value
    def get_choice_group_ref(self):
        return self.choice_group_ref
    def set_choice_group_ref(self, choice_group_ref):
        self.choice_group_ref = choice_group_ref
    def add_choice_group_ref(self, value):
        self.choice_group_ref.append(value)
    def insert_choice_group_ref_at(self, index, value):
        self.choice_group_ref.insert(index, value)
    def replace_choice_group_ref_at(self, index, value):
        self.choice_group_ref[index] = value
    def get_default_answer_ref(self):
        return self.default_answer_ref
    def set_default_answer_ref(self, default_answer_ref):
        self.default_answer_ref = default_answer_ref
    def validate_ChoiceGroupIDPattern(self, value):
        result = True
        # Validate type ChoiceGroupIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChoiceGroupIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ChoiceGroupIDPattern_patterns_, ))
                result = False
        return result
    validate_ChoiceGroupIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:choicegroup:[1-9][0-9]*)$']]
    def validate_ChoiceIDPattern(self, value):
        # Validate type inter:ChoiceIDPattern, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChoiceIDPattern_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ChoiceIDPattern_patterns_, ))
    validate_ChoiceIDPattern_patterns_ = [['^(ocil:[A-Za-z0-9_\\-\\.]+:choice:[1-9][0-9]*)$']]
    def has__content(self):
        if (
            self.choice or
            self.choice_group_ref or
            super(ChoiceQuestionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceQuestionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChoiceQuestionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChoiceQuestionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceQuestionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChoiceQuestionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ChoiceQuestionType'):
        super(ChoiceQuestionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceQuestionType')
        if self.default_answer_ref is not None and 'default_answer_ref' not in already_processed:
            already_processed.add('default_answer_ref')
            outfile.write(' default_answer_ref=%s' % (quote_attrib(self.default_answer_ref), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceQuestionType', fromsubclass_=False, pretty_print=True):
        super(ChoiceQuestionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for choice_ in self.choice:
            namespaceprefix_ = self.choice_nsprefix_ + ':' if (UseCapturedNS_ and self.choice_nsprefix_) else ''
            choice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='choice', pretty_print=pretty_print)
        for choice_group_ref_ in self.choice_group_ref:
            namespaceprefix_ = self.choice_group_ref_nsprefix_ + ':' if (UseCapturedNS_ and self.choice_group_ref_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schoice_group_ref>%s</%schoice_group_ref>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(choice_group_ref_), input_name='choice_group_ref')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_answer_ref', node)
        if value is not None and 'default_answer_ref' not in already_processed:
            already_processed.add('default_answer_ref')
            self.default_answer_ref = value
            self.validate_ChoiceIDPattern(self.default_answer_ref)    # validate type ChoiceIDPattern
        super(ChoiceQuestionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'choice':
            obj_ = ChoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.choice.append(obj_)
            obj_.original_tagname_ = 'choice'
        elif nodeName_ == 'choice_group_ref':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'choice_group_ref')
            value_ = self.gds_validate_string(value_, node, 'choice_group_ref')
            self.choice_group_ref.append(value_)
            self.choice_group_ref_nsprefix_ = child_.prefix
            # validate type ChoiceGroupIDPattern
            self.validate_ChoiceGroupIDPattern(self.choice_group_ref[-1])
        super(ChoiceQuestionType, self)._buildChildren(child_, node, nodeName_, True)
# end class ChoiceQuestionType


class BooleanQuestionType(QuestionType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionType
    def __init__(self, revision='0', notes=None, id=None, question_text=None, instructions=None, default_answer=None, model='MODEL_YES_NO', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ocil"
        super(globals().get("BooleanQuestionType"), self).__init__(revision, notes, id, question_text, instructions,  **kwargs_)
        self.default_answer = _cast(None, default_answer)
        self.default_answer_nsprefix_ = None
        self.model = _cast(None, model)
        self.model_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanQuestionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanQuestionType.subclass:
            return BooleanQuestionType.subclass(*args_, **kwargs_)
        else:
            return BooleanQuestionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default_answer(self):
        return self.default_answer
    def set_default_answer(self, default_answer):
        self.default_answer = default_answer
    def get_model(self):
        return self.model
    def set_model(self, model):
        self.model = model
    def validate_BooleanQuestionModelType(self, value):
        # Validate type inter:BooleanQuestionModelType, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['MODEL_YES_NO', 'MODEL_TRUE_FALSE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BooleanQuestionModelType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(BooleanQuestionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='BooleanQuestionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanQuestionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanQuestionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanQuestionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanQuestionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='BooleanQuestionType'):
        super(BooleanQuestionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanQuestionType')
        if self.default_answer is not None and 'default_answer' not in already_processed:
            already_processed.add('default_answer')
            outfile.write(' default_answer=%s' % (quote_attrib(self.default_answer), ))
        if self.model != "MODEL_YES_NO" and 'model' not in already_processed:
            already_processed.add('model')
            outfile.write(' model=%s' % (quote_attrib(self.model), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0"', name_='BooleanQuestionType', fromsubclass_=False, pretty_print=True):
        super(BooleanQuestionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_answer', node)
        if value is not None and 'default_answer' not in already_processed:
            already_processed.add('default_answer')
            self.default_answer = value
        value = find_attr_value_('model', node)
        if value is not None and 'model' not in already_processed:
            already_processed.add('model')
            self.model = value
            self.validate_BooleanQuestionModelType(self.model)    # validate type BooleanQuestionModelType
        super(BooleanQuestionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BooleanQuestionType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BooleanQuestionType


class StringQuestionTestActionType(QuestionTestActionType):
    """when_pattern --  This element holds information on what to do
    when the answer matches a specified regular expression
    pattern.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionTestActionType
    def __init__(self, revision='0', notes=None, question_ref=None, id=None, title=None, when_unknown=None, when_not_tested=None, when_not_applicable=None, when_error=None, when_pattern=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("StringQuestionTestActionType"), self).__init__(revision, notes, question_ref, id, title, when_unknown, when_not_tested, when_not_applicable, when_error,  **kwargs_)
        if when_pattern is None:
            self.when_pattern = []
        else:
            self.when_pattern = when_pattern
        self.when_pattern_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringQuestionTestActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringQuestionTestActionType.subclass:
            return StringQuestionTestActionType.subclass(*args_, **kwargs_)
        else:
            return StringQuestionTestActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_when_pattern(self):
        return self.when_pattern
    def set_when_pattern(self, when_pattern):
        self.when_pattern = when_pattern
    def add_when_pattern(self, value):
        self.when_pattern.append(value)
    def insert_when_pattern_at(self, index, value):
        self.when_pattern.insert(index, value)
    def replace_when_pattern_at(self, index, value):
        self.when_pattern[index] = value
    def has__content(self):
        if (
            self.when_pattern or
            super(StringQuestionTestActionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='StringQuestionTestActionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringQuestionTestActionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringQuestionTestActionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringQuestionTestActionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringQuestionTestActionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='StringQuestionTestActionType'):
        super(StringQuestionTestActionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringQuestionTestActionType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='StringQuestionTestActionType', fromsubclass_=False, pretty_print=True):
        super(StringQuestionTestActionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for when_pattern_ in self.when_pattern:
            namespaceprefix_ = self.when_pattern_nsprefix_ + ':' if (UseCapturedNS_ and self.when_pattern_nsprefix_) else ''
            when_pattern_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_pattern', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StringQuestionTestActionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'when_pattern':
            obj_ = PatternTestActionConditionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_pattern.append(obj_)
            obj_.original_tagname_ = 'when_pattern'
        super(StringQuestionTestActionType, self)._buildChildren(child_, node, nodeName_, True)
# end class StringQuestionTestActionType


class NumericQuestionTestActionType(QuestionTestActionType):
    """when_equals --  This element holds information on what to
    do when the answer matches the specified value.
      
    * when_range --  This element holds information on what to do
      when the answer is within a specified range of values.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionTestActionType
    def __init__(self, revision='0', notes=None, question_ref=None, id=None, title=None, when_unknown=None, when_not_tested=None, when_not_applicable=None, when_error=None, when_equals=None, when_range=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("NumericQuestionTestActionType"), self).__init__(revision, notes, question_ref, id, title, when_unknown, when_not_tested, when_not_applicable, when_error,  **kwargs_)
        if when_equals is None:
            self.when_equals = []
        else:
            self.when_equals = when_equals
        self.when_equals_nsprefix_ = "inter"
        if when_range is None:
            self.when_range = []
        else:
            self.when_range = when_range
        self.when_range_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericQuestionTestActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericQuestionTestActionType.subclass:
            return NumericQuestionTestActionType.subclass(*args_, **kwargs_)
        else:
            return NumericQuestionTestActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_when_equals(self):
        return self.when_equals
    def set_when_equals(self, when_equals):
        self.when_equals = when_equals
    def add_when_equals(self, value):
        self.when_equals.append(value)
    def insert_when_equals_at(self, index, value):
        self.when_equals.insert(index, value)
    def replace_when_equals_at(self, index, value):
        self.when_equals[index] = value
    def get_when_range(self):
        return self.when_range
    def set_when_range(self, when_range):
        self.when_range = when_range
    def add_when_range(self, value):
        self.when_range.append(value)
    def insert_when_range_at(self, index, value):
        self.when_range.insert(index, value)
    def replace_when_range_at(self, index, value):
        self.when_range[index] = value
    def has__content(self):
        if (
            self.when_equals or
            self.when_range or
            super(NumericQuestionTestActionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='NumericQuestionTestActionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericQuestionTestActionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericQuestionTestActionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericQuestionTestActionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumericQuestionTestActionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='NumericQuestionTestActionType'):
        super(NumericQuestionTestActionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericQuestionTestActionType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='NumericQuestionTestActionType', fromsubclass_=False, pretty_print=True):
        super(NumericQuestionTestActionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for when_equals_ in self.when_equals:
            namespaceprefix_ = self.when_equals_nsprefix_ + ':' if (UseCapturedNS_ and self.when_equals_nsprefix_) else ''
            when_equals_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_equals', pretty_print=pretty_print)
        for when_range_ in self.when_range:
            namespaceprefix_ = self.when_range_nsprefix_ + ':' if (UseCapturedNS_ and self.when_range_nsprefix_) else ''
            when_range_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_range', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(NumericQuestionTestActionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'when_equals':
            obj_ = EqualsTestActionConditionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_equals.append(obj_)
            obj_.original_tagname_ = 'when_equals'
        elif nodeName_ == 'when_range':
            obj_ = RangeTestActionConditionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_range.append(obj_)
            obj_.original_tagname_ = 'when_range'
        super(NumericQuestionTestActionType, self)._buildChildren(child_, node, nodeName_, True)
# end class NumericQuestionTestActionType


class ChoiceQuestionTestActionType(QuestionTestActionType):
    """when_choice --  Specifies the action to perform when the
    indicated choice is selected.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionTestActionType
    def __init__(self, revision='0', notes=None, question_ref=None, id=None, title=None, when_unknown=None, when_not_tested=None, when_not_applicable=None, when_error=None, when_choice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("ChoiceQuestionTestActionType"), self).__init__(revision, notes, question_ref, id, title, when_unknown, when_not_tested, when_not_applicable, when_error,  **kwargs_)
        if when_choice is None:
            self.when_choice = []
        else:
            self.when_choice = when_choice
        self.when_choice_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChoiceQuestionTestActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChoiceQuestionTestActionType.subclass:
            return ChoiceQuestionTestActionType.subclass(*args_, **kwargs_)
        else:
            return ChoiceQuestionTestActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_when_choice(self):
        return self.when_choice
    def set_when_choice(self, when_choice):
        self.when_choice = when_choice
    def add_when_choice(self, value):
        self.when_choice.append(value)
    def insert_when_choice_at(self, index, value):
        self.when_choice.insert(index, value)
    def replace_when_choice_at(self, index, value):
        self.when_choice[index] = value
    def has__content(self):
        if (
            self.when_choice or
            super(ChoiceQuestionTestActionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceQuestionTestActionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChoiceQuestionTestActionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChoiceQuestionTestActionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceQuestionTestActionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChoiceQuestionTestActionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='ChoiceQuestionTestActionType'):
        super(ChoiceQuestionTestActionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChoiceQuestionTestActionType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='ChoiceQuestionTestActionType', fromsubclass_=False, pretty_print=True):
        super(ChoiceQuestionTestActionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for when_choice_ in self.when_choice:
            namespaceprefix_ = self.when_choice_nsprefix_ + ':' if (UseCapturedNS_ and self.when_choice_nsprefix_) else ''
            when_choice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_choice', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ChoiceQuestionTestActionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'when_choice':
            obj_ = ChoiceTestActionConditionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_choice.append(obj_)
            obj_.original_tagname_ = 'when_choice'
        super(ChoiceQuestionTestActionType, self)._buildChildren(child_, node, nodeName_, True)
# end class ChoiceQuestionTestActionType


class BooleanQuestionTestActionType(QuestionTestActionType):
    """when_true -- The element when_true specifies the action to
    do when the answer is true.
    when_false -- The element when_false specifies the action
    to do when the answer is false.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuestionTestActionType
    def __init__(self, revision='0', notes=None, question_ref=None, id=None, title=None, when_unknown=None, when_not_tested=None, when_not_applicable=None, when_error=None, when_true=None, when_false=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "inter"
        super(globals().get("BooleanQuestionTestActionType"), self).__init__(revision, notes, question_ref, id, title, when_unknown, when_not_tested, when_not_applicable, when_error,  **kwargs_)
        self.when_true = when_true
        self.when_true_nsprefix_ = "inter"
        self.when_false = when_false
        self.when_false_nsprefix_ = "inter"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanQuestionTestActionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanQuestionTestActionType.subclass:
            return BooleanQuestionTestActionType.subclass(*args_, **kwargs_)
        else:
            return BooleanQuestionTestActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_when_true(self):
        return self.when_true
    def set_when_true(self, when_true):
        self.when_true = when_true
    def get_when_false(self):
        return self.when_false
    def set_when_false(self, when_false):
        self.when_false = when_false
    def has__content(self):
        if (
            self.when_true is not None or
            self.when_false is not None or
            super(BooleanQuestionTestActionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='BooleanQuestionTestActionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanQuestionTestActionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanQuestionTestActionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanQuestionTestActionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanQuestionTestActionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='inter:', name_='BooleanQuestionTestActionType'):
        super(BooleanQuestionTestActionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanQuestionTestActionType')
    def _exportChildren(self, outfile, level, namespaceprefix_='inter:', namespacedef_='xmlns:ocil="http://scap.nist.gov/schema/ocil/2.0" xmlns:inter="http://scap.nist.gov/schema/ocil/2.0" ', name_='BooleanQuestionTestActionType', fromsubclass_=False, pretty_print=True):
        super(BooleanQuestionTestActionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.when_true is not None:
            namespaceprefix_ = self.when_true_nsprefix_ + ':' if (UseCapturedNS_ and self.when_true_nsprefix_) else ''
            self.when_true.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_true', pretty_print=pretty_print)
        if self.when_false is not None:
            namespaceprefix_ = self.when_false_nsprefix_ + ':' if (UseCapturedNS_ and self.when_false_nsprefix_) else ''
            self.when_false.export(outfile, level, namespaceprefix_, namespacedef_='', name_='when_false', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BooleanQuestionTestActionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'when_true':
            class_obj_ = self.get_class_obj_(child_, TestActionConditionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_true = obj_
            obj_.original_tagname_ = 'when_true'
        elif nodeName_ == 'when_false':
            class_obj_ = self.get_class_obj_(child_, TestActionConditionType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.when_false = obj_
            obj_.original_tagname_ = 'when_false'
        super(BooleanQuestionTestActionType, self)._buildChildren(child_, node, nodeName_, True)
# end class BooleanQuestionTestActionType


#
# End data representation classes.
#


GDSClassesMapping = {
    'CanonicalizationMethod': CanonicalizationMethodType,
    'CanonicalizationMethod': CanonicalizationMethodType,
    'DSAKeyValue': DSAKeyValueType,
    'DSAKeyValue': DSAKeyValueType,
    'DigestMethod': DigestMethodType,
    'DigestMethod': DigestMethodType,
    'DigestValue': DigestValueType,
    'DigestValue': DigestValueType,
    'Group': groupType,
    'Item': itemType,
    'KeyInfo': KeyInfoType,
    'KeyInfo': KeyInfoType,
    'KeyValue': KeyValueType,
    'KeyValue': KeyValueType,
    'Manifest': ManifestType,
    'Manifest': ManifestType,
    'Object': ObjectType,
    'Object': ObjectType,
    'PGPData': PGPDataType,
    'PGPData': PGPDataType,
    'Profile': profileType,
    'RSAKeyValue': RSAKeyValueType,
    'RSAKeyValue': RSAKeyValueType,
    'Reference': ReferenceType,
    'Reference': ReferenceType,
    'RetrievalMethod': RetrievalMethodType,
    'RetrievalMethod': RetrievalMethodType,
    'Rule': ruleType,
    'SPKIData': SPKIDataType,
    'SPKIData': SPKIDataType,
    'Signature': SignatureType,
    'Signature': SignatureType,
    'SignatureMethod': SignatureMethodType,
    'SignatureMethod': SignatureMethodType,
    'SignatureProperties': SignaturePropertiesType,
    'SignatureProperties': SignaturePropertiesType,
    'SignatureProperty': SignaturePropertyType,
    'SignatureProperty': SignaturePropertyType,
    'SignatureValue': SignatureValueType,
    'SignatureValue': SignatureValueType,
    'SignedInfo': SignedInfoType,
    'SignedInfo': SignedInfoType,
    'Tailoring': tailoringType,
    'TestResult': testResultType,
    'Transform': TransformType,
    'Transform': TransformType,
    'Transforms': TransformsType,
    'Transforms': TransformsType,
    'Value': valueType,
    'X509Data': X509DataType,
    'X509Data': X509DataType,
    'arc': arcType,
    'artifact_value': ArtifactValueType,
    'binary_artifact_value': BinaryArtifactValueType,
    'boolean_question': BooleanQuestionType,
    'boolean_question_result': BooleanQuestionResultType,
    'boolean_question_test_action': BooleanQuestionTestActionType,
    'catalog': catalog,
    'check-fact-ref': CheckFactRefType,
    'choice_question': ChoiceQuestionType,
    'choice_question_result': ChoiceQuestionResultType,
    'choice_question_test_action': ChoiceQuestionTestActionType,
    'constant_variable': ConstantVariableType,
    'cpe-item': ItemType,
    'cpe-list': ListType,
    'definition': DefinitionType,
    'delegatePublic': delegatePublic,
    'delegateSystem': delegateSystem,
    'delegateURI': delegateURI,
    'deprecated_info': DeprecatedInfoType,
    'element_mapping': ElementMapType,
    'expression': SetExpressionBaseType,
    'external_variable': ExternalVariableType,
    'fact-ref': CPEFactRefType,
    'group': group,
    'local_variable': LocalVariableType,
    'locator': locatorType,
    'logical-test': LogicalTestType,
    'nextCatalog': nextCatalog,
    'notes': NotesType,
    'numeric_question': NumericQuestionType,
    'numeric_question_result': NumericQuestionResultType,
    'numeric_question_test_action': NumericQuestionTestActionType,
    'object': ObjectType,
    'ocil': OCILType,
    'platform': PlatformType,
    'platform-configuration': PlatformBaseType,
    'platform-specification': platformSpecificationType,
    'public': public,
    'question': QuestionType,
    'question_result': QuestionResultType,
    'question_test_action': QuestionTestActionType,
    'reference_artifact_value': ReferenceArtifactValueType,
    'resource': resourceType,
    'rewriteSystem': rewriteSystem,
    'rewriteURI': rewriteURI,
    'state': StateType,
    'string_question': StringQuestionType,
    'string_question_result': StringQuestionResultType,
    'string_question_test_action': StringQuestionTestActionType,
    'system': SystemTargetType,
    'system': system,
    'systemSuffix': systemSuffix,
    'target': NamedItemBaseType,
    'test': TestType,
    'test_action': ItemBaseType,
    'text_artifact_value': TextArtifactValueType,
    'title': titleEltType,
    'uri': uri,
    'uriSuffix': uriSuffix,
    'user': UserType,
    'variable': VariableType,
    'variable': VariableType,
    'when_boolean': SetExpressionBooleanType,
    'when_choice': SetExpressionChoiceType,
    'when_pattern': SetExpressionPatternType,
    'when_range': SetExpressionRangeType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'data_stream_collection'
        rootClass = data_stream_collection
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'data_stream_collection'
        rootClass = data_stream_collection
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'data_stream_collection'
        rootClass = data_stream_collection
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ds="http://scap.nist.gov/schema/scap/source/1.2"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'data_stream_collection'
        rootClass = data_stream_collection
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from datastream_models import *\n\n')
        sys.stdout.write('import datastream_models as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
    "{http://cpe.mitre.org/dictionary/2.0}GeneratorType": "GeneratorType3",
    "{http://cpe.mitre.org/dictionary/2.0}NotesType": "NotesType5",
    "{http://cpe.mitre.org/dictionary/2.0}TextType": "TextType4",
    "{http://cpe.mitre.org/naming/2.0}cpe22Type": "cpe22Type6",
    "{http://cpe.mitre.org/naming/2.0}cpe23Type": "cpe23Type7",
    "{http://scap.nist.gov/schema/ocil/2.0}GeneratorType": "GeneratorType8",
    "{http://scap.nist.gov/schema/ocil/2.0}ReferenceType": "ReferenceType11",
    "{http://scap.nist.gov/schema/ocil/2.0}ReferencesType": "ReferencesType12",
    "{http://scap.nist.gov/schema/ocil/2.0}TextType": "TextType13",
    "{http://scap.nist.gov/schema/ocil/2.0}VariableIDPattern": "VariableIDPattern14",
    "{http://scap.nist.gov/schema/ocil/2.0}VariableType": "VariableType10",
    "{http://scap.nist.gov/schema/ocil/2.0}VariablesType": "VariablesType9",
    "{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethodType": "CanonicalizationMethodType18",
    "{http://www.w3.org/2000/09/xmldsig#}CryptoBinary": "CryptoBinary37",
    "{http://www.w3.org/2000/09/xmldsig#}DSAKeyValueType": "DSAKeyValueType35",
    "{http://www.w3.org/2000/09/xmldsig#}DigestMethodType": "DigestMethodType23",
    "{http://www.w3.org/2000/09/xmldsig#}DigestValueType": "DigestValueType38",
    "{http://www.w3.org/2000/09/xmldsig#}HMACOutputLengthType": "HMACOutputLengthType39",
    "{http://www.w3.org/2000/09/xmldsig#}KeyInfoType": "KeyInfoType24",
    "{http://www.w3.org/2000/09/xmldsig#}KeyValueType": "KeyValueType25",
    "{http://www.w3.org/2000/09/xmldsig#}ManifestType": "ManifestType32",
    "{http://www.w3.org/2000/09/xmldsig#}ObjectType": "ObjectType31",
    "{http://www.w3.org/2000/09/xmldsig#}PGPDataType": "PGPDataType29",
    "{http://www.w3.org/2000/09/xmldsig#}RSAKeyValueType": "RSAKeyValueType36",
    "{http://www.w3.org/2000/09/xmldsig#}ReferenceType": "ReferenceType20",
    "{http://www.w3.org/2000/09/xmldsig#}RetrievalMethodType": "RetrievalMethodType26",
    "{http://www.w3.org/2000/09/xmldsig#}SPKIDataType": "SPKIDataType30",
    "{http://www.w3.org/2000/09/xmldsig#}SignatureMethodType": "SignatureMethodType19",
    "{http://www.w3.org/2000/09/xmldsig#}SignaturePropertiesType": "SignaturePropertiesType33",
    "{http://www.w3.org/2000/09/xmldsig#}SignaturePropertyType": "SignaturePropertyType34",
    "{http://www.w3.org/2000/09/xmldsig#}SignatureType": "SignatureType15",
    "{http://www.w3.org/2000/09/xmldsig#}SignatureValueType": "SignatureValueType16",
    "{http://www.w3.org/2000/09/xmldsig#}SignedInfoType": "SignedInfoType17",
    "{http://www.w3.org/2000/09/xmldsig#}TransformType": "TransformType22",
    "{http://www.w3.org/2000/09/xmldsig#}TransformsType": "TransformsType21",
    "{http://www.w3.org/2000/09/xmldsig#}X509DataType": "X509DataType27",
    "{http://www.w3.org/2000/09/xmldsig#}X509IssuerSerialType": "X509IssuerSerialType28",
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://checklists.nist.gov/xccdf/1.2': [('statusType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('benchmarkIdType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('ruleIdType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('groupIdType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('valueIdType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('profileIdType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('testresultIdType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('tailoringIdType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('warningCategoryEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('fixStrategyEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('ratingEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('ccOperatorEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('weightType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('valueTypeType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('valueOperatorType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('interfaceHintType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('msgSevEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('resultEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('severityEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('roleEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('subUseEnumType',
                                           './xccdf_1.2.xsd',
                                           'ST'),
                                          ('noticeType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('dc_statusType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('plainTextType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('referenceType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('signatureType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('metadataType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('paramType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('versionType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('textType', './xccdf_1.2.xsd', 'CT'),
                                          ('htmlTextType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('htmlTextWithSubType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('profileNoteType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('textWithSubType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('subType', './xccdf_1.2.xsd', 'CT'),
                                          ('idrefType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('idrefListType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('CPE2idrefType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('overrideableCPE2idrefType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('itemType', './xccdf_1.2.xsd', 'CT'),
                                          ('selectableItemType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('groupType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('ruleType', './xccdf_1.2.xsd', 'CT'),
                                          ('identType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('warningType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('fixTextType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('fixType', './xccdf_1.2.xsd', 'CT'),
                                          ('instanceFixType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('complexCheckType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('checkType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('checkImportType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('checkExportType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('checkContentRefType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('checkContentType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('valueType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('complexValueType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('selComplexValueType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('selChoicesType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('selStringType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('selNumType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('uriRefType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('profileType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('profileSelectType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('profileSetValueType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('profileSetComplexValueType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('profileRefineValueType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('profileRefineRuleType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('testResultType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('benchmarkReferenceType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('scoreType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('targetFactsType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('targetIdRefType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('identityType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('factType', './xccdf_1.2.xsd', 'CT'),
                                          ('tailoringReferenceType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('ruleResultType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('instanceResultType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('overrideType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('messageType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('tailoringType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('tailoringBenchmarkReferenceType',
                                           './xccdf_1.2.xsd',
                                           'CT'),
                                          ('tailoringVersionType',
                                           './xccdf_1.2.xsd',
                                           'CT')],
 'http://cpe.mitre.org/dictionary/2.0': [('GeneratorType',
                                          './cpe-dictionary_2.3.xsd',
                                          'CT'),
                                         ('ItemType',
                                          './cpe-dictionary_2.3.xsd',
                                          'CT'),
                                         ('ListType',
                                          './cpe-dictionary_2.3.xsd',
                                          'CT'),
                                         ('TextType',
                                          './cpe-dictionary_2.3.xsd',
                                          'CT'),
                                         ('NotesType',
                                          './cpe-dictionary_2.3.xsd',
                                          'CT'),
                                         ('ReferencesType',
                                          './cpe-dictionary_2.3.xsd',
                                          'CT'),
                                         ('CheckType',
                                          './cpe-dictionary_2.3.xsd',
                                          'CT')],
 'http://cpe.mitre.org/language/2.0': [('operatorEnumeration',
                                        './cpe-language_2.3.xsd',
                                        'ST'),
                                       ('namePattern',
                                        './cpe-language_2.3.xsd',
                                        'ST'),
                                       ('platformSpecificationType',
                                        './cpe-language_2.3.xsd',
                                        'CT'),
                                       ('PlatformBaseType',
                                        './cpe-language_2.3.xsd',
                                        'CT'),
                                       ('PlatformType',
                                        './cpe-language_2.3.xsd',
                                        'CT'),
                                       ('LogicalTestType',
                                        './cpe-language_2.3.xsd',
                                        'CT'),
                                       ('FactRefType',
                                        './cpe-language_2.3.xsd',
                                        'CT'),
                                       ('CPEFactRefType',
                                        './cpe-language_2.3.xsd',
                                        'CT'),
                                       ('CheckFactRefType',
                                        './cpe-language_2.3.xsd',
                                        'CT'),
                                       ('TextType',
                                        './cpe-language_2.3.xsd',
                                        'CT')],
 'http://cpe.mitre.org/naming/2.0': [('cpe22Type',
                                      './cpe-naming_2.3.xsd',
                                      'ST'),
                                     ('cpe23Type',
                                      './cpe-naming_2.3.xsd',
                                      'ST'),
                                     ('cpe22Type',
                                      'https://scap.nist.gov/schema/cpe/2.3/cpe-naming_2.3.xsd',
                                      'ST'),
                                     ('cpe23Type',
                                      'https://scap.nist.gov/schema/cpe/2.3/cpe-naming_2.3.xsd',
                                      'ST')],
 'http://oval.mitre.org/XMLSchema/oval-common-5': [('CheckEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('ClassEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('SimpleDatatypeEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('ComplexDatatypeEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('DatatypeEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('ExistenceEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('FamilyEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('MessageLevelEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('OperationEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('OperatorEnumeration',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('DefinitionIDPattern',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('ObjectIDPattern',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('StateIDPattern',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('TestIDPattern',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('VariableIDPattern',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('ItemIDPattern',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('SchemaVersionPattern',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('EmptyStringType',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('NonEmptyStringType',
                                                    './oval-common-schema.xsd',
                                                    'ST'),
                                                   ('ElementMapType',
                                                    './oval-common-schema.xsd',
                                                    'CT'),
                                                   ('ElementMapItemType',
                                                    './oval-common-schema.xsd',
                                                    'CT'),
                                                   ('DeprecatedInfoType',
                                                    './oval-common-schema.xsd',
                                                    'CT'),
                                                   ('GeneratorType',
                                                    './oval-common-schema.xsd',
                                                    'CT'),
                                                   ('SchemaVersionType',
                                                    './oval-common-schema.xsd',
                                                    'CT'),
                                                   ('MessageType',
                                                    './oval-common-schema.xsd',
                                                    'CT'),
                                                   ('NotesType',
                                                    './oval-common-schema.xsd',
                                                    'CT')],
 'http://oval.mitre.org/XMLSchema/oval-definitions-5': [('ArithmeticEnumeration',
                                                         './oval-definitions-schema.xsd',
                                                         'ST'),
                                                        ('DateTimeFormatEnumeration',
                                                         './oval-definitions-schema.xsd',
                                                         'ST'),
                                                        ('FilterActionEnumeration',
                                                         './oval-definitions-schema.xsd',
                                                         'ST'),
                                                        ('SetOperatorEnumeration',
                                                         './oval-definitions-schema.xsd',
                                                         'ST'),
                                                        ('DefinitionsType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('DefinitionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('MetadataType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('AffectedType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ReferenceType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('CriteriaType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('CriterionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ExtendDefinitionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('TestsType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('TestType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ObjectRefType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('StateRefType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ObjectsType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ObjectType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('StatesType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('StateType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('VariablesType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('VariableType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('PossibleValueType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('PossibleRestrictionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('RestrictionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ValueType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('LiteralComponentType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ObjectComponentType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('VariableComponentType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ArithmeticFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('BeginFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('ConcatFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EndFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EscapeRegexFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('SplitFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('SubstringFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('TimeDifferenceFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('RegexCaptureFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('UniqueFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('CountFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('GlobToRegexFunctionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntitySimpleBaseType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityComplexBaseType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectIPAddressType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectIPAddressStringType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectAnySimpleType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectBinaryType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectBoolType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectFloatType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectIntType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectStringType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectVersionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectRecordType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityObjectFieldType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateSimpleBaseType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateComplexBaseType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateIPAddressType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateIPAddressStringType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateAnySimpleType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateBinaryType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateBoolType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateFloatType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateIntType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateEVRStringType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateDebianEVRStringType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateVersionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateFileSetRevisionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateIOSVersionType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateStringType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateRecordType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT'),
                                                        ('EntityStateFieldType',
                                                         './oval-definitions-schema.xsd',
                                                         'CT')],
 'http://scap.nist.gov/schema/ocil/2.0': [('BooleanQuestionModelType',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('ResultType',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('ExceptionalResultType',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('UserResponseType',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('VariableDataType',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('OperatorType',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('TestActionRefValuePattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('QuestionnaireIDPattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('QuestionTestActionIDPattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('QuestionIDPattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('ChoiceIDPattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('ChoiceGroupIDPattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('VariableIDPattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('ArtifactIDPattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('ProviderValuePattern',
                                           './ocil-2.0.xsd',
                                           'ST'),
                                          ('OCILType', './ocil-2.0.xsd', 'CT'),
                                          ('QuestionnairesType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionnaireType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('GeneratorType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ExtensionContainerType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('DocumentType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('TestActionsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionTestActionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('BooleanQuestionTestActionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ChoiceQuestionTestActionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('NumericQuestionTestActionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('StringQuestionTestActionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('TestActionRefType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ChoiceTestActionConditionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('EqualsTestActionConditionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('RangeTestActionConditionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('PatternTestActionConditionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('PatternType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('RangeType', './ocil-2.0.xsd', 'CT'),
                                          ('TestActionConditionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('RangeValueType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionTextType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('BooleanQuestionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ChoiceQuestionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('NumericQuestionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('StringQuestionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ChoiceType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ChoiceGroupType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('InstructionsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ResultsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionnaireResultsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('TestActionResultsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionResultsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionnaireResultType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('TestActionResultType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('QuestionResultType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('BooleanQuestionResultType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ChoiceQuestionResultType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('NumericQuestionResultType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('StringQuestionResultType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ChoiceAnswerType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ArtifactsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ArtifactType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ArtifactRefsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ArtifactRefType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ArtifactResultsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ArtifactValueType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('EmbeddedArtifactValueType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('TextArtifactValueType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('BinaryArtifactValueType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ReferenceArtifactValueType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ArtifactResultType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('TargetsType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('UserType', './ocil-2.0.xsd', 'CT'),
                                          ('SystemTargetType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('VariablesType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('VariableType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ConstantVariableType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('LocalVariableType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ExternalVariableType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('SetExpressionBaseType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('SetExpressionPatternType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('SetExpressionChoiceType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('SetExpressionRangeType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('SetExpressionBooleanType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('VariableSetType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('SubstitutionTextType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ReferenceType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('StepType', './ocil-2.0.xsd', 'CT'),
                                          ('ItemBaseType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('NamedItemBaseType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('CompoundTestActionType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('ReferencesType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('OperationType',
                                           './ocil-2.0.xsd',
                                           'CT'),
                                          ('TextType', './ocil-2.0.xsd', 'CT')],
 'http://scap.nist.gov/schema/scap/source/1.2': [('useCaseType',
                                                  '.\\scap-source-data-stream_1.3.xsd',
                                                  'ST'),
                                                 ('scapVersionType',
                                                  '.\\scap-source-data-stream_1.3.xsd',
                                                  'ST'),
                                                 ('contentSourceType',
                                                  '.\\scap-source-data-stream_1.3.xsd',
                                                  'CT'),
                                                 ('refListType',
                                                  '.\\scap-source-data-stream_1.3.xsd',
                                                  'CT')],
 'http://www.w3.org/1999/xlink': [('typeType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('hrefType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('roleType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('arcroleType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('titleAttrType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('showType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('actuateType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('labelType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('fromType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('toType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'ST'),
                                  ('simple',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'CT'),
                                  ('extended',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'CT'),
                                  ('titleEltType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'CT'),
                                  ('resourceType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'CT'),
                                  ('locatorType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'CT'),
                                  ('arcType',
                                   'https://www.w3.org/1999/xlink.xsd',
                                   'CT')],
 'http://www.w3.org/2000/09/xmldsig#': [('CryptoBinary',
                                         './xmldsig-core-schema.xsd',
                                         'ST'),
                                        ('DigestValueType',
                                         './xmldsig-core-schema.xsd',
                                         'ST'),
                                        ('HMACOutputLengthType',
                                         './xmldsig-core-schema.xsd',
                                         'ST'),
                                        ('SignatureType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignatureValueType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignedInfoType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('CanonicalizationMethodType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignatureMethodType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('ReferenceType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('TransformsType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('TransformType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('DigestMethodType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('KeyInfoType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('KeyValueType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('RetrievalMethodType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('X509DataType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('X509IssuerSerialType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('PGPDataType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SPKIDataType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('ObjectType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('ManifestType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignaturePropertiesType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignaturePropertyType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('DSAKeyValueType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('RSAKeyValueType',
                                         './xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('CryptoBinary',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'ST'),
                                        ('DigestValueType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'ST'),
                                        ('HMACOutputLengthType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'ST'),
                                        ('SignatureType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignatureValueType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignedInfoType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('CanonicalizationMethodType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignatureMethodType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('ReferenceType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('TransformsType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('TransformType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('DigestMethodType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('KeyInfoType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('KeyValueType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('RetrievalMethodType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('X509DataType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('X509IssuerSerialType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('PGPDataType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SPKIDataType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('ObjectType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('ManifestType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignaturePropertiesType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('SignaturePropertyType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('DSAKeyValueType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT'),
                                        ('RSAKeyValueType',
                                         'https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd',
                                         'CT')],
 'http://www.w3.org/XML/1998/namespace': [],
 'urn:oasis:names:tc:entity:xmlns:xml:catalog': [('pubIdChars',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'ST'),
                                                 ('publicIdentifier',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'ST'),
                                                 ('partialPublicIdentifier',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'ST'),
                                                 ('systemOrPublic',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'ST'),
                                                 ('catalog',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('public',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('system',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('uri',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('rewriteSystem',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('rewriteURI',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('systemSuffix',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('uriSuffix',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('delegatePublic',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('delegateSystem',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('delegateURI',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('nextCatalog',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT'),
                                                 ('group',
                                                  'http://www.oasis-open.org/committees/entity/release/1.1/catalog.xsd',
                                                  'CT')]}

__all__ = [
    "AffectedType",
    "ArithmeticFunctionType",
    "ArtifactRefType",
    "ArtifactRefsType",
    "ArtifactResultType",
    "ArtifactResultsType",
    "ArtifactType",
    "ArtifactValueType",
    "ArtifactsType",
    "BeginFunctionType",
    "Benchmark",
    "BinaryArtifactValueType",
    "BooleanQuestionResultType",
    "BooleanQuestionTestActionType",
    "BooleanQuestionType",
    "CPE2idrefType",
    "CPEFactRefType",
    "CanonicalizationMethodType",
    "CanonicalizationMethodType18",
    "CheckFactRefType",
    "CheckType",
    "ChoiceAnswerType",
    "ChoiceGroupType",
    "ChoiceQuestionResultType",
    "ChoiceQuestionTestActionType",
    "ChoiceQuestionType",
    "ChoiceTestActionConditionType",
    "ChoiceType",
    "CompoundTestActionType",
    "ConcatFunctionType",
    "ConstantVariableType",
    "CountFunctionType",
    "CriteriaType",
    "CriterionType",
    "DSAKeyValueType",
    "DSAKeyValueType35",
    "DefinitionType",
    "DefinitionsType",
    "DeprecatedInfoType",
    "DigestMethodType",
    "DigestMethodType23",
    "DigestValueType",
    "DocumentType",
    "ElementMapItemType",
    "ElementMapType",
    "EmbeddedArtifactValueType",
    "EndFunctionType",
    "EntityComplexBaseType",
    "EntityObjectAnySimpleType",
    "EntityObjectBinaryType",
    "EntityObjectBoolType",
    "EntityObjectFieldType",
    "EntityObjectFloatType",
    "EntityObjectIPAddressStringType",
    "EntityObjectIPAddressType",
    "EntityObjectIntType",
    "EntityObjectRecordType",
    "EntityObjectStringType",
    "EntityObjectVersionType",
    "EntitySimpleBaseType",
    "EntityStateAnySimpleType",
    "EntityStateBinaryType",
    "EntityStateBoolType",
    "EntityStateComplexBaseType",
    "EntityStateDebianEVRStringType",
    "EntityStateEVRStringType",
    "EntityStateFieldType",
    "EntityStateFileSetRevisionType",
    "EntityStateFloatType",
    "EntityStateIOSVersionType",
    "EntityStateIPAddressStringType",
    "EntityStateIPAddressType",
    "EntityStateIntType",
    "EntityStateRecordType",
    "EntityStateSimpleBaseType",
    "EntityStateStringType",
    "EntityStateVersionType",
    "EqualsTestActionConditionType",
    "EscapeRegexFunctionType",
    "ExtendDefinitionType",
    "ExtensionContainerType",
    "ExternalVariableType",
    "FactRefType",
    "GeneratorType",
    "GeneratorType3",
    "GeneratorType8",
    "GlobToRegexFunctionType",
    "InstructionsType",
    "ItemBaseType",
    "ItemType",
    "KeyInfoType",
    "KeyInfoType24",
    "KeyValueType",
    "KeyValueType25",
    "ListType",
    "LiteralComponentType",
    "LocalVariableType",
    "LogicalTestType",
    "ManifestType",
    "ManifestType32",
    "MessageType",
    "MetadataType",
    "NamedItemBaseType",
    "NotesType",
    "NotesType5",
    "NumericQuestionResultType",
    "NumericQuestionTestActionType",
    "NumericQuestionType",
    "OCILType",
    "ObjectComponentType",
    "ObjectRefType",
    "ObjectType",
    "ObjectType2",
    "ObjectType31",
    "ObjectsType",
    "OperationType",
    "PGPDataType",
    "PGPDataType29",
    "PatternTestActionConditionType",
    "PatternType",
    "PlatformBaseType",
    "PlatformType",
    "PossibleRestrictionType",
    "PossibleValueType",
    "QuestionResultType",
    "QuestionResultsType",
    "QuestionTestActionType",
    "QuestionTextType",
    "QuestionType",
    "QuestionnaireResultType",
    "QuestionnaireResultsType",
    "QuestionnaireType",
    "QuestionnairesType",
    "QuestionsType",
    "RSAKeyValueType",
    "RSAKeyValueType36",
    "RangeTestActionConditionType",
    "RangeType",
    "RangeValueType",
    "ReferenceArtifactValueType",
    "ReferenceType",
    "ReferenceType1",
    "ReferenceType11",
    "ReferenceType20",
    "ReferencesType",
    "ReferencesType12",
    "RegexCaptureFunctionType",
    "RestrictionType",
    "ResultsType",
    "RetrievalMethodType",
    "RetrievalMethodType26",
    "SPKIDataType",
    "SPKIDataType30",
    "SchemaVersionType",
    "SetExpressionBaseType",
    "SetExpressionBooleanType",
    "SetExpressionChoiceType",
    "SetExpressionPatternType",
    "SetExpressionRangeType",
    "SignatureMethodType",
    "SignatureMethodType19",
    "SignaturePropertiesType",
    "SignaturePropertiesType33",
    "SignaturePropertyType",
    "SignaturePropertyType34",
    "SignatureType",
    "SignatureType15",
    "SignatureValueType",
    "SignatureValueType16",
    "SignedInfoType",
    "SignedInfoType17",
    "SplitFunctionType",
    "StateRefType",
    "StateType",
    "StatesType",
    "StepType",
    "StringQuestionResultType",
    "StringQuestionTestActionType",
    "StringQuestionType",
    "SubstitutionTextType",
    "SubstringFunctionType",
    "SystemTargetType",
    "TargetsType",
    "TestActionConditionType",
    "TestActionRefType",
    "TestActionResultType",
    "TestActionResultsType",
    "TestActionsType",
    "TestType",
    "TestsType",
    "TextArtifactValueType",
    "TextType",
    "TextType13",
    "TextType4",
    "TimeDifferenceFunctionType",
    "TransformType",
    "TransformType22",
    "TransformsType",
    "TransformsType21",
    "UniqueFunctionType",
    "UserType",
    "ValueType",
    "VariableComponentType",
    "VariableSetType",
    "VariableType",
    "VariableType10",
    "VariablesType",
    "VariablesType9",
    "X509DataType",
    "X509DataType27",
    "X509IssuerSerialType",
    "X509IssuerSerialType28",
    "arcType",
    "benchmarkReferenceType",
    "catalog",
    "checkContentRefType",
    "checkContentType",
    "checkExportType",
    "checkImportType",
    "checkType",
    "complexCheckType",
    "complexValueType",
    "component",
    "component_ref",
    "contentSourceType",
    "data_stream",
    "data_stream_collection",
    "dc_statusType",
    "delegatePublic",
    "delegateSystem",
    "delegateURI",
    "extended",
    "extended_component",
    "factType",
    "filter",
    "fixTextType",
    "fixType",
    "group",
    "groupType",
    "htmlTextType",
    "htmlTextWithSubType",
    "identType",
    "identityType",
    "idrefListType",
    "idrefType",
    "instanceFixType",
    "instanceResultType",
    "itemType",
    "locatorType",
    "messageType",
    "metadataType",
    "model",
    "nextCatalog",
    "noticeType",
    "oval_definitions",
    "overrideType",
    "overrideableCPE2idrefType",
    "paramType",
    "plainTextType",
    "platformSpecificationType",
    "profileNoteType",
    "profileRefineRuleType",
    "profileRefineValueType",
    "profileSelectType",
    "profileSetComplexValueType",
    "profileSetValueType",
    "profileType",
    "public",
    "refListType",
    "referenceType",
    "referenceType50",
    "referenceType51",
    "resourceType",
    "rewriteSystem",
    "rewriteURI",
    "ruleResultType",
    "ruleType",
    "scoreType",
    "selChoicesType",
    "selComplexValueType",
    "selNumType",
    "selStringType",
    "selectableItemType",
    "set_",
    "signatureType",
    "simple",
    "status",
    "subType",
    "system",
    "systemSuffix",
    "tailoringBenchmarkReferenceType",
    "tailoringReferenceType",
    "tailoringType",
    "tailoringVersionType",
    "targetFactsType",
    "targetIdRefType",
    "testResultType",
    "textType",
    "textWithSubType",
    "titleEltType",
    "uri",
    "uriRefType",
    "uriSuffix",
    "value",
    "valueType",
    "versionType",
    "warningType"
]
